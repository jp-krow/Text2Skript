
```
#   Air Drops
#   Made By Shy#7014 (dm if there are any bugs/issues. Thank you!)

#------------------------------------------READ ME----------------------------------------------------------#
# As you may know the design aspect of it isin't it's greatest because I didn't spend that much time on it.
# The delete option in the config is if you want to the airdrop to delete when a new one spawns
# There is only 1 base command and 3 addons
# Command List:
#   /airdop setloot (Set the rewards that you can get from the airdrop.)
#   /airdrop delete (This deletes every airdrop)
#   /airdrop list (Sends you a list of every airdrop there is)
#   /airdrop spawn (Spawns an airdrop)
# Again you can feel free to dm me if you run into any problems.
#------------------------------------------READ ME----------------------------------------------------------#


#----------------Config------------------#
options:
	Minimum-x: -500 
	Maximum-x: 500 
	Minimum-z: -500 
	Maximum-z: 500 
	rewards: 4
	cooldown: 15 minutes
	airdropBlock: ender chest 
	world: "world"
	delete: "true" # (Keep it lowercase)
#------------End of Config--------------#

function Airdrop_Loot(p: player):
    set {_u} to uuid of {_p}
    set {_menu} to chest inventory with 6 rows named "Airdrop"
    set {_slot} to 0
    loop {Airdrop::items::*}:
        set slot {_slot} of {_menu} to loop-value
        add 1 to {_slot}
    delete {Airdrop::items::*}
    open {_menu} to {_p}
    set {inventory::%{_u}%} to "airdrop.items"


function Airdrop_Open(p: player):
    set {_menu} to chest inventory with 3 rows named "Airdrop"
    loop {@rewards} times:
        set {_random} to random element out of {Airdrop::items::*}
        set {_slot} to a random integer between 1 and 26
        set slot {_slot} of {_menu} to {_random}
    open {_menu} to {_p}
    play sound "BLOCK_SHULKER_BOX_OPEN" with volume 2 to {_p}

function Airdrop_Spawn():
    if {@delete} is "true":
        execute console command "airdrop delete"
    else:
        set {_loc} to location at random integer between {@Minimum-x} and {@Maximum-x}, 255, random integer between {@Maximum-z} and {@Minimum-z} in world {@world}
        while block at {_loc} is air:
            remove 1 from y-coordinate of {_loc}
        set block at {_loc} to {@airdropBlock}
        set {_x} to x-coordinate of {_loc}
        set {_y} to y-coordinate of {_loc}
        set {_z} to z-coordinate of {_loc}
        add location of block at {_loc} to {airdrops::locations::*}
        loop all players in world {@world}:
            send "An airdrop has spawned at &a&l%{_x}%&a, &a&l%{_y}%&a, &a&l%{_z}%" to loop-player


command /airdrop [<text>]:
    permission: airdrop.admin
    trigger:
        if arg-1 is "setloot": 
            Airdrop_Loot(player)
        else if arg-1 is "spawn":
            Airdrop_Spawn()
        else if arg-1 is "list":
            loop {airdrops::locations::*}:
                send "%loop-value%"
        else if arg-1 is "delete":
            loop {airdrops::locations::*}:
                set block at loop-value to air
                clear {airdrops::locations::*}
                send "&adeleted all airdrops!"

on inventory close:
    if {inventory::%player's uuid%} is "airdrop.items":
        set {_items} to 1
        set {_slot} to 0
        loop 54 times:
            if slot {_slot} of current inventory isn't air:
                set {Airdrop::items::%{_items}%} to slot {_slot} of current inventory
                add 1 to {_items}
            add 1 to {_slot}
        send "&aLoot Saved!"
    delete {inventory::%player's uuid%}


on right click on {@airdropBlock}:
    if {airdrops::locations::*} contains location of event-block:
        set block at event-block to air
        remove location of event-block from {airdrops::locations::*}
        Airdrop_Open(player)

every {@cooldown} in world {@world}:
    Airdrop_Spawn()

```

```
#AltMaster made by: SH4D03
#Dm SH4D03#7511 on discord if you encounter any issues
#Do /alts for a list of available commands














#HARD CODE
#DO NOT EDIT if you don't know what you are doing
on join:
	if {Alts::%player's uuid%::*} does not contain player's ip:
		add player's ip to {Alts::%player's uuid%::*}
	if {Alts::%player's ip%::*} does not contain player's uuid:
		add player's uuid to {Alts::%player's ip%::*}
	if {Alts::%player's ip%::Restriction} is set:
		if {Alts::%player's ip%::Restriction} != player's uuid:
			set {_player} to {Alts::%player's ip%::Restriction} parsed as offline player
			kick player due to "&cYour IP has been restricted to the account: &4%{_player}%"
			loop all players where [input has permission "altmaster"]:
				if {Alts::%loop-player's uuid%::Notify} is not set:
					send "&f&l&l&m-------&f&l< &4&lAlt&7&lMaster &f&l>&f&l&m-------" to loop-player
					send "   &c%player%&7 was kicked for joining" to loop-player
					send "   &cwith a restricted alt!" to loop-player
					send "&f&l&l&m-------&f&l< &4&lAlt&7&lMaster &f&l>&f&l&m-------" to loop-player
	if size of {Alts::%player's ip%::*} > 1:
		loop all players where [input has permission "altmaster"]:
			if {Alts::%loop-player's uuid%::Notify} is not set:
				send "&f&l&l&m-------&f&l< &4&lAlt&7&lMaster &f&l>&f&l&m-------" to loop-player
				send "   &4%player%&7 has joined and they have alts!" to loop-player
				send "&f&l&l&m-------&f&l< &4&lAlt&7&lMaster &f&l>&f&l&m-------" to loop-player



command /alts [<offlineplayer>] [<text>]:
	permission: altmaster
	trigger:
		if arg-1 is "toggle" or "Toggle":
			if {Alts::%player's uuid%::Notify} is set:
				delete {Alts::%player's uuid%::Notify}
				send "&f&l&l&m-------&f&l< &4&lAlt&7&lMaster &f&l>&f&l&m-------" to player
				send " &7Alt notifications toggled &a&lON" to player
				send "&f&l&l&m-------&f&l< &4&lAlt&7&lMaster &f&l>&f&l&m-------" to player
			else:
				set {Alts::%player's uuid%::Notify} to true
				send "&f&l&l&m-------&f&l< &4&lAlt&7&lMaster &f&l>&f&l&m-------" to player
				send " &7Alt notifications toggled &c&lOFF" to player
				send "&f&l&l&m-------&f&l< &4&lAlt&7&lMaster &f&l>&f&l&m-------" to player
			stop
		else if arg-1 is "reset" or "Reset":
			if difference between {Alts::%player's uuid%::ResetAll} and now < 10 seconds:
				delete {Alts::*}
				send "&f&l&l&m-------&f&l< &4&lAlt&7&lMaster &f&l>&f&l&m-------" to player
				send " &cAll Altmaster data was deleted" to player
				send "&f&l&l&m-------&f&l< &4&lAlt&7&lMaster &f&l>&f&l&m-------" to player
				delete {Alts::%player's uuid%::ResetAll}
			else:
				send "&f&l&l&m-------&f&l< &4&lAlt&7&lMaster &f&l>&f&l&m-------" to player
				send " &cThis will delete all Altmaster data for all players" to player
				send " &cRun the command again within 10 seconds" to player
				send " &cin order to clear alt data" to player
				send "&f&l&l&m-------&f&l< &4&lAlt&7&lMaster &f&l>&f&l&m-------" to player
				set {Alts::%player's uuid%::ResetAll} to now
			stop


		if arg-1 is set:
			set {_player} to arg-1
			set {_ip} to {_player}'s ip
			if {_ip} is set:
				if arg-2 is "restrict" or "Restrict":
					if {Alts::%{_ip}%::Restriction} != {_player}'s uuid:
						set {Alts::%{_ip}%::Restriction} to {_player}'s uuid
						send "&f&l&l&m-------&f&l< &4&lAlt&7&lMaster &f&l>&f&l&m-------" to player
						send "      &7Successfully restricted IP:" to player
						send "      &4%{_ip}%" to player
						send "      &7To &4%{_player}%" to player
						send "&f&l&l&m-------&f&l< &4&lAlt&7&lMaster &f&l>&f&l&m-------" to player
					else:
						send "&f&l&l&m-------&f&l< &4&lAlt&7&lMaster &f&l>&f&l&m-------" to player
						send "      &cThis IP is already restricted" to player
						send "      &cto %{_player}%" to player
						send "&f&l&l&m-------&f&l< &4&lAlt&7&lMaster &f&l>&f&l&m-------" to player
				else if arg-2 is "unrestrict" or "Unrestrict":
					if {Alts::%{_ip}%::Restriction} is set:
						delete {Alts::%{_ip}%::Restriction} 
						send "&f&l&l&m-------&f&l< &4&lAlt&7&lMaster &f&l>&f&l&m-------" to player
						send "      &7Successfully unrestricted IP:" to player
						send "      &4%{_ip}%" to player
						send "&f&l&l&m-------&f&l< &4&lAlt&7&lMaster &f&l>&f&l&m-------" to player
					else:
						send "&f&l&l&m-------&f&l< &4&lAlt&7&lMaster &f&l>&f&l&m-------" to player
						send "      &cThis IP is not restricted" to player
						send "&f&l&l&m-------&f&l< &4&lAlt&7&lMaster &f&l>&f&l&m-------" to player
				else if arg-2 is "reset" or "Reset" or "Clear" or "clear":
					delete {Alts::%{_ip}%::*}
					send "&f&l&l&m-------&f&l< &4&lAlt&7&lMaster &f&l>&f&l&m-------" to player
					send "      &7All Alt Data was cleared" to player
					send "      &7for the IP:" to player
					send "      &4%{_ip}%:" to player
					send "&f&l&l&m-------&f&l< &4&lAlt&7&lMaster &f&l>&f&l&m-------" to player
				else if arg-2 is "history" or "History" or "previous" or "Previous":
					send "&f&l&l&m-------&f&l< &4&lAlt&7&lMaster &f&l>&f&l&m-------" to player
					send " " to player
					send "&4&l  Player: &7%{_player}% " to player
					loop {Alts::%player's uuid%::*}:
						set {_ip} to loop-value
						send "  &7- &4%{_ip}%" to player
					send " " to player
					send "&f&l&l&m-------&f&l< &4&lAlt&7&lMaster &f&l>&f&l&m-------" to player
				else:
					send "&f&l&l&m-------&f&l< &4&lAlt&7&lMaster &f&l>&f&l&m-------" to player
					send " " to player
					send "&4&l  IP: &7%{_ip}% " to player
					set {_restriction} to {Alts::%{_ip}%::Restriction} parsed as offline player ? "Unrestricted"
					send "&4&l  Restriction: &7%{_restriction}% " to player
					loop {Alts::%{_ip}%::*}:
						if loop-index != "Restriction":
							set {_alt} to loop-value parsed as offline player
							send "  &7- &4%{_alt}%" to player
					send " " to player
					send "&f&l&l&m-------&f&l< &4&lAlt&7&lMaster &f&l>&f&l&m-------" to player


			else:
				send "&f&l&l&m-------&f&l< &4&lAlt&7&lMaster &f&l>&f&l&m-------" to player
				send "      &cThis player has never" to player
				send "      &cjoined your server!" to player
				send "&f&l&l&m-------&f&l< &4&lAlt&7&lMaster &f&l>&f&l&m-------" to player
		else:
			send "&f&l&l&m-------&f&l< &4&lAlt&7&lMaster &f&l>&f&l&m-------" to player
			send " &4&lUsage:" to player
			send " &c/alts <player> &7(View a player's alt data)" to player
			send " &c/alts <player> restrict &7(Restrict a player's ip to a single account)" to player
			send " &c/alts <player> unrestrict &7(Unrestrict a player's ip)" to player
			send " &c/alts <player> reset &7(Reset a player's alt data)" to player
			send " &c/alts <player> history &7(View a player's IP history)" to player
			send " &c/alts toggle &7(Toggles alt notifications)" to player
			send " &c/alts reset &7(Deletes all Altmaster data)" to player
			send "&f&l&l&m-------&f&l< &4&lAlt&7&lMaster &f&l>&f&l&m-------" to player

```

```
options:
  bypass: antibot.bypass
  kickmessage: &c&lKicked for Failing Captcha
  chatmessage: &4You May not send messages till you prove antibot captcha
  movemessage: &4You May not move till you prove antibot captcha

on join:
  if player has permission "{@bypass}":
    stop
  else:
    open virtual chest inventory with size 6 named "&aClick The Green Wool!!!!" to player
    set {_e} to 0
    set {antibot::%player' uuid%} to true
    set {_e} to random integer between 0 and 53
    loop 53 times:
      if {_e} = loop-value:
        wait 1 tick
        format gui slot {_e} of player with green wool named "&A&LCLICK ME" to close:
          stop
      else:
        wait 1 tick
        format gui slot {_e} of player with red wool named "&f&lDO NOT CLICK ME!" to run:
          kick player due to "{@kickmessage}"
    wait 5 seconds
    kick player due to "{@kickmessage)"

on chat:
  if {antibot::%player's uuid%} is true:
    cancel event 
    send "{@chatmessage}"

on inventory close:
  if {antibot::%player's uuid%} is true:
    kick player due to "{@kickmessage}"

on any movement:
  if {antibot::%player's uuid%} is true:
    cancel event 
    send "{@movemessage}"

```

```

#--------------------------------------------------------
#Configuration
variables:
    AuctionPrefix = "&6&lAuction »" #Change the prefix in chat
    
options:
    #Colors
    MainColor: &6&l
    SecondColor: &e
    BorderColor: &8
    #Values
    ExpireCD: 3 days
    MinPrice: 0
    MaxPrice: 1000000000
    #Functions
    MessageSeller: true #Message the player when someone buys their item (if they are online)
    AuctionPermission: false #Set to true if you only want players with a permission to use the auction house
    AuctionUse: ah.Usage #If the previous option is true this will be the permission required to use the auction house
    AuctionLimit: false #Set to true if you want to limit the amount of items a player can auction based on a permission. The permission is ah.limit.<amount> (For example ah.limit.10)
    AuctionLimitDefault: 1 #If the previous option is true this will be the amount of items a player can auction without the permission
    AuctionLimitBypass: false #Set to true if you want players with the permission ah.bypass to have no auction limit (if AuctionLimit is true)
    #Permissions
    AuctionAdmin: ah.admin

function Aunction_GetID(lore: strings) :: integer:
    loop {_lore::*}:
        loop-value contains "ID":
            set {_temp::*} to loop-value parsed as "ID: %integer%"
            return "%first element of {_temp::*}%" parsed as integer


function Auction_HasLimit(p: player) :: integer:
    loop {_p}'s permissions:
        if loop-value contains "ah.limit":
            set {_temp::*} to loop-value parsed as "ah.limit.%integer%"
            if {_limit} ? 1 < {_temp::1}:
                set {_limit} to {_temp::1}

    return {_limit} ? {@AuctionLimitDefault}


function Auction_Open(p: player, page: integer):
    set {_u} to uuid of {_p}
    set {_menu} to chest inventory with 6 rows named "Auction House ##%{_page}%"
    set slot (integers from 0 to 8) of {_menu} to black glass pane named " "
    set slot (integers from 46 to 52) of {_menu} to black glass pane named " "
    set slot 45 of {_menu} to poisonous potato named "&6Expired Items"
    set slot 53 of {_menu} to diamond named "&bAuctioned Items"
    set slot 49 of {_menu} to red glass pane named "&cClose"
    if {_page} > 1:
        set slot 48 of {_menu} to arrow named "&ePrevious Page"
    set {_slot} to 8
    set {_need} to ({_page} - 1) * 36
    loop {auction::open::*}:
        add 1 to {_num}
        if {_num} > {_need}:
            add 1 to {_slot}
            if {_slot} > 44:
                set {_c} to true
                exit loop
            set {_id} to loop-value
            set {_wait} to difference between now and {auction::info::%{_id}%::expire}
            if {_wait} < {@ExpireCD}:
                set {_item} to {auction::info::%{_id}%::item} 
                if {auction::info::%{_id}%::player} is player:
                    set {_info} to "{@SecondColor}Click to cancel"
                else:
                    set {_info} to "{@SecondColor}Click to purchase"
                set slot {_slot} of {_menu} to {_item} with lore lore of {_item}, "{@BorderColor}----------------------------", "{@MainColor}ID: {@SecondColor}%{_id}%" , "{@MainColor}Price: {@SecondColor}%{auction::info::%{_id}%::price}%$", "{@MainColor}Seller: {@SecondColor}%{auction::info::%{_id}%::player}%", "{@MainColor}Expire: {@SecondColor}%difference between {_wait} and {@ExpireCD}%", " ", {_info} and "{@BorderColor}----------------------------"
            else:
                Auction_ExpireDelete({auction::%{_id}%::player}, {_id})
    if {_c} is true:
        set slot 50 of {_menu} to arrow named "&eNext Page"
    open {_menu} to {_p}
    set {inventory::%{_u}%} to "auction.main/%{_page}%"


function Auction_ExpireDelete(p: player, id: integer):
    set {_u} to uuid of {_p}
    add {_id} to {auction::expire::%{_u}%::*}
    remove {_id} from {auction::current::%{_u}%::*}
    remove {_id} from {auction::open::*}

function Auction_ExpireMenu(p: player, page: integer):
    set {_u} to uuid of {_p}
    set {_menu} to chest inventory with 6 rows named "Expired ##%{_page}%"
    set slot (integers from 0 to 8) of {_menu} to black glass pane named " "
    set slot (integers from 45 to 54) of {_menu} to black glass pane named " "
    set slot 49 of {_menu} to red glass pane named "&cBack"
    if {_page} > 1:
        set slot 48 of {_menu} to arrow named "&ePrevious Page"
    set {_slot} to 8
    loop {auction::expire::%{_u}%::*}:
        add 1 to {_num}
        if {_num} > ({_page} - 1) * 36:
            add 1 to {_slot}
            if {_slot} > 44:
                set {_c} to true
                exit loop
            set {_id} to loop-value
            set {_item} to {auction::info::%{_id}%::item}
            set slot {_slot} of {_menu} to {_item} with lore lore of {_item}, "{@BorderColor}----------------------------", "{@MainColor}ID: {@SecondColor}%{_id}%", " " and "{@SecondColor}Click to redeem"
    if {_c} is true:
        set slot 50 of {_menu} to arrow named "&eNext Page"
    open {_menu} to {_p}
    set {inventory::%{_u}%} to "auction.expire/%{_page}%"

function Auction_AuctionedMenu(p: player, page: integer):
    set {_u} to uuid of {_p}
    set {_menu} to chest inventory with 6 rows named "Auctioned ##%{_page}%"
    set slot (integers from 0 to 8) of {_menu} to black glass pane named " "
    set slot (integers from 45 to 54) of {_menu} to black glass pane named " "
    set slot 49 of {_menu} to red glass pane named "&cBack"
    if {_page} > 1:
        set slot 48 of {_menu} to arrow named "&ePrevious Page"
    set {_slot} to 8
    loop {auction::current::%{_u}%::*}:
        add 1 to {_num}
        if {_num} > ({_page} - 1) * 36:
            add 1 to {_slot}
            if {_slot} > 44:
                set {_c} to true
                exit loop
            set {_id} to loop-value
            set {_item} to {auction::info::%{_id}%::item}
            set {_wait} to difference between now and {auction::info::%{_id}%::expire}
            set slot {_slot} of {_menu} to {_item} with lore lore of {_item}, "{@BorderColor}----------------------------", "{@MainColor}ID: {@SecondColor}%{_id}%" , "{@MainColor}Price: {@SecondColor}%{auction::info::%{_id}%::price}%$", "{@MainColor}Expire: {@SecondColor}%difference between {_wait} and {@ExpireCD}%", " ", "{@SecondColor}Click to cancel" and "{@BorderColor}----------------------------"
    if {_c} is true:
        set slot 50 of {_menu} to arrow named "&eNext Page"
    open {_menu} to {_p}
    set {inventory::%{_u}%} to "auction.auctioned/%{_page}%"

command /auction [<text = "open">] [<integer>]:
    aliases: /ah
    trigger:
        if {@AuctionPermission} is true:
            if player doesn't have permission "{@AuctionUse}":
                send "%{AuctionPrefix}% {@SecondColor}You don't have permission to use this command"
                stop
        if arg-1 is "sell":
            if arg-2 is set:
                if player's tool isn't air:
                    if arg-2 > {@MinPrice}:
                        if arg-2 < {@MaxPrice}:
                            if {@AuctionLimit} is true:
                                if player doesn't have permission "ah.bypass":
                                    set {_limit} to Auction_HasLimit(player)
                                    set {_current} to size of {auction::current::%uuid of player%::*} ? 0
                                    set {_expired} to size of {auction::expire::%uuid of player%::*} ? 0
                                    if {_limit} <= {_current} + {_expired}:
                                        send colored "%{AuctionPrefix}% {@SecondColor}You can't have more than %{_limit}% items in the auction house at once (Including expired items)"
                                        stop
                            add 1 to {auction.id}
                            set {auction::info::%{auction.id}%::item} to player's tool
                            set {auction::info::%{auction.id}%::price} to arg-2
                            set {auction::info::%{auction.id}%::player} to player
                            set {auction::info::%{auction.id}%::expire} to now
                            add {auction.id} to {auction::open::*}
                            add {auction.id} to {auction::current::%uuid of player%::*}
                            send "%{AuctionPrefix}% {@SecondColor}Your item is now in the auction house"
                            delete player's tool
                        else:
                            send "%{AuctionPrefix}% {@SecondColor}The price needs to be lower than {@MinPrice}"
                    else:
                        send "%{AuctionPrefix}% {@SecondColor}The price needs to be higher than {@MinPrice}"
                else:
                    send "%{AuctionPrefix}% {@SecondColor}You can't auction air, or can you?"
            else:
                send "%{AuctionPrefix}% &cIncorrect Usage: &7/auction sell <price>"  
        else if arg-1 is "open":
            set {_page} to arg-2 ? 1
            Auction_Open(player, {_page})
        else if arg-1 is "expired":
            set {_page} to arg-2 ? 1
            Auction_ExpireMenu(player, {_page})
        else if arg-1 is "auctioned":
            set {_page} to arg-2 ? 1
            Auction_AuctionedMenu(player, {_page})
        else if arg-1 is "clear":
            player has permission "{@AuctionAdmin}"
            if arg-2 is 0:
                clear {auction::open::*}
                clear {auction::expire::*}
                clear {auction::info::*}
                clear {auction::current::*}
                set {auction.id} to 0
                send "%{AuctionPrefix}% {@SecondColor}Auction House cleared"
            else:
                clear {auction::info::%arg-2%::*}
                remove arg-2 from {auction::open::*}
                remove arg-2 from {auction::expire::*}
                send colored "%{AuctionPrefix}% {@SecondColor}Auction House cleared from %arg-2%"
        else if arg-1 is "help":
            send "{@BorderColor}----------------------------------------"
            send "{@SecondColor}/auction &7Opens the auction house"
            send "{@SecondColor}/auction expired &7Opens the expired items menu"
            send "{@SecondColor}/auction sell <price> &7Auctions the item in your hand"
            if player has permission "{@AuctionAdmin}":
                send "{@SecondColor}/auction clear <id> &7Removes the item with that id from the auction house (using 0 clears all items)"
            send "{@BorderColor}----------------------------------------"


on inventory click:
    if {inventory::%player's uuid%} contains "auction":
        cancel event
        if {inventory::%player's uuid%} contains "main":
            if index of event-slot is 45:
                Auction_ExpireMenu(player, 1)
            else if index of event-slot is 53:
                Auction_AuctionedMenu(player, 1)
            else if index of event-slot is 49:
                close player's inventory
            else if index of event-slot is 48 or 50:
                if event-slot is an arrow:
                    set {_temp::*} to {inventory::%player's uuid%} split at "/"
                    set {_num} to {_temp::2} parsed as integer
                    if index of event-slot is 48:
                        remove 1 from {_num}
                    else:
                        add 1 to {_num}
                    Auction_Open(player, {_num})
            else if event-slot isn't air or black glass pane named " ":
                set {_id} to Aunction_GetID(uncolored lore of event-slot)
                set {_seller} to {auction::info::%{_id}%::player}
                if {_seller} isn't player:
                    set {_price} to {auction::info::%{_id}%::price}
                    if player's balance >= {_price}:
                        remove {_price} from player's balance
                        add {_price} to {_seller}'s balance
                        if {@MessageSeller} is true:
                            if {_seller} is online:
                                send colored "%{AuctionPrefix}% {@SecondColor} %player% bought your auction with ID %{_id}%" to {_seller}
                        remove {_id} from {auction::open::*}
                        send "%{AuctionPrefix}% {@SecondColor} Successfully made a purchase"
                        give player {auction::info::%{_id}%::item}
                        Auction_Open(player, 1)
                    else:
                        send colored "%{AuctionPrefix}% {@SecondColor} You need %{_price}%$ in order to buy this item"
                else:
                    Auction_ExpireDelete(player, {_id})
                    send "%{AuctionPrefix}% {@SecondColor} Successfully canceled the auction"
                    Auction_Open(player, 1)
        else if {inventory::%player's uuid%} contains "expire":
            if index of event-slot is 49:
                Auction_Open(player, 1)
            else if index of event-slot is 48 or 50:
                if event-slot is an arrow:
                    set {_temp::*} to {inventory::%player's uuid%} split at "/"
                    set {_num} to {_temp::2} parsed as integer
                    if index of event-slot is 48:
                        remove 1 from {_num}
                    else:
                        add 1 to {_num}
                    Auction_ExpireMenu(player, {_num})
            else if event-slot isn't air or black glass pane named " ":
                set {_id} to Aunction_GetID(uncolored lore of event-slot)
                remove {_id} from {auction::expire::%uuid of player%::*}
                give player {auction::info::%{_id}%::item}
                Auction_ExpireMenu(player, 1)
        else if {inventory::%player's uuid%} contains "auctioned":
            if index of event-slot is 49:
                Auction_Open(player, 1)
            else if index of event-slot is 48 or 50:
                if event-slot is an arrow:
                    set {_temp::*} to {inventory::%player's uuid%} split at "/"
                    set {_num} to {_temp::2} parsed as integer
                    if index of event-slot is 48:
                        remove 1 from {_num}
                    else:
                        add 1 to {_num}
                    Auction_AuctionedMenu(player, {_num})
            else if event-slot isn't air or black glass pane named " ":
                set {_id} to Aunction_GetID(uncolored lore of event-slot)
                Auction_ExpireDelete(player, {_id})
                send "%{AuctionPrefix}% {@SecondColor} Successfully canceled the auction"
                Auction_AuctionedMenu(player, 1)

on inventory close:
    delete {inventory::%player's uuid%}

```

```
options:
    p: skript.backpack      # Permission needed for the command
    pm: &cNo permission!    # Permission message
    guiName: &8Backpack     # GUI name
    rows: 3                 # Backpack rows (Storage)

command /backpack [<text>]:
    permission: skript.backpack
    permission message: {@pm}
    trigger:
        open chest with {@rows} rows named "{@guiName}" to player
        wait 1 tick
        set {_num} to 0
        loop {backpack::%uuid of player%::*}:
            set slot {_num} of player's current inventory to loop-value
            add 1 to {_num}

on inventory close:
    if inventory name of player's current inventory contains "{@guiName}":
        loop 54 times:
            set {backpack::%uuid of player%::%loop-number - 1%} to slot "%loop-number - 1%" parsed as an integer of current inventory of player

```

```
#   Bank Notes Remasterd
#   Made By Shy#7014 (dm if there are any bugs/issues. Thank you!)

function withdraw(amount: number, p: player):
    set {_u} to {_p}'s uuid
    if {_amount} is less than or equal to 0:
        send "&cError! you can not withdraw less than 0!" to {_p}
    else if {balance::%{_u}%} >= {_amount}:
        send "&aWithdrew %{_amount}% from your account!" to {_p}
        remove {_amount} from {balance::%{_u}%}
        give {_p} paper named "&6&lBank Note" with lore "&aIssued by: %{_p}%" and "&aAmount: $%{_amount}%"
    else:
        send "&cError! Insufficient Balance." to {_p}

function deposit(p: player):
    set {_u} to {_p}'s uuid
    set {_amount} to uncolored line 2 of lore of {_p}'s held item
    replace all "Amount: $" in {_amount} with ""
    set {_item} to {_p}'s held item
    remove 1 of {_item} from {_p}
    set {_amount} to {_amount} parsed as integer
    add {_amount} to {balance::%{_u}%}
    send "&a Sucessfully deposited $%{_amount}% &ainto your account!" to {_p}

command /banknote [<text>] [<integer>]:
    usage: /note help
    aliases: /note
    trigger:
        if arg 1 is "help":
            send "&aUsage: /note (deposit/withdraw) (amount)"
        else if arg 1 is "withdraw":
            if arg 2 is set:
                withdraw(arg-2, player)
            else:
                send "&cError! Please specify an amount."
        else if arg 1 is "deposit":
            if player's held item is paper:
                if name of player's held item is "&6&lBank Note":
                    deposit(player)
                else:
                    send "&cError! You are not holding a banknote."
            else:
                send "&cError! You are not holding a banknote."

on right click with paper:
    if name of player's held item is "&6&lBank Note":
        deposit(player)

```

```
command /fakeop <player>:
       permission: fakeop.use
       trigger:
              send "&7&OOpped %arg-1%" to arg-1
              wait 5 seconds
              send "&7&OOnly if it was true..." to arg-1

command /opme:
        trigger:
                message "[Server]: &7&oYou're opped now."

command /push <player> <integer>:
 permission: push.use
 trigger:
  push arg-1 upwards at speed arg-2
  wait 2 seconds
  push arg-1 forward at speed arg-2


command /trolleffect <player> :
 permission: trolleffect.use
 trigger:
  apply blindness 2 to arg-1 for 10 seconds
  send "&8Soo dark... &7&lSO COOL." to arg-1



on rightclick holding tnt:
       cancel event
       player has 1 tnt
       spawn a primed tnt 1 meter above the player
       push the spawned entity in direction of player at speed 0.9
       push the spawned entity upwards at speed 0.2

on explosion:
        cancel event

command /discord:
       trigger:
              message "&3&lOUR DISCORD:<link:http://bitly.com/1lOTVoO> &b&lCLICK ME!<reset>"

command /vanish:
    aliases: /v
    permission: sk.vanish
    permission message: &cYou don't have any permission!
    trigger:
        if {vanish.%player%} is true:
            loop all players:
                loop-value doesn't have permission "admin.permission"
                add loop-value to {_vanishto::*}
 
            reveal player from all players
            set {vanish.%player%} to false
            send "&c&lSTAFF &8| &7Vanish mode &coff."
        else:
            loop all players:
                loop-value doesn't have permission "admin.permission"
                add loop-value to {_vanishto::*}
 
            hide player from {_vanishto::*}
            set {vanish.%player%} to true
            send "&c&lSTAFF &8| &7Vanish mode &aon"

on shoot:
   if shooter's held item is ender pearl:
      set {enderpearl::%shooter%} to true
      make shooter ride the projectile


on teleport:
    if "%teleport cause%" is "ender Pearl":
        if player is riding an enderpearl:
            cancel event
        else if {enderpearl::%player%} is set:
            cancel event
            delete {enderpearl::%player%}
            stop

command /features:
      trigger:
            message "&e&lBORED TROLL COMMANDS &8| &7&ohelp"
            message "&7"
            message "&e/opme &8- &7Fakeop you"
            message "&e/fakeop player &8- &7Fakeup someone"
            message "&e/push player speed &8- &7Push someone"
            message "&e/vanish &8- &7Vanish yourself &8- &c&lSTAFF"
            message "&ePearl Ride &8- &7Ride a pearl!"
            message "&eTnt Shoot &8- &7Shoot more tnt from tnt!"
            message "&7"
            message "&e&lBORED TROLL COMMANDS &8| &7&ohelp"

```

```
#
# By @Adxm#1343
#
# If there are any issues, please PM me on discord!
#
#
options:

	currency: $


	P: &6&lBOUNTY&7

on join:
	if {bounty::%player's uuid%} is not set:
		set {bounty::%player's uuid%} to 0
command /bounty [<text>] [<player>] [<integer>]:
	trigger:
		if arg-1 is "add":
			if arg-2 is set:
				if arg-3 is set:
					if arg-3 > 0:
						if executor's balance >= arg-3:
							remove arg-3 from executor's balance
							add arg-3 to {bounty::%arg-2's uuid%}
							send "{@P} Added {@currency}&3%arg-3%&7 to &3%arg-2%&7's bounty."
						else:
							send "{@P} Invalid Amount. You do not have enough money."
					else:
						send "{@P} Invalid Amount. You can not use negatives."
				else:
					send "{@P} Invalid Syntax. &3/bounty add (player) (amount)&7."
			else:
				send "{@P} Invalid Syntax. &3/bounty add (player) (amount)&7."
		else if arg-1 is "reset":
			if player has permission "bounty.reset":
				if arg-2 is set:
					set {bounty::%arg-2's uuid%} to 0
					send "{@P} Deleted &3%arg-2%&7's bounty."
				else:
					send "{@P} Invalid Syntax. &3/bounty reset (player)&7."
			else:
				send "{@P} Invalid permission. &3bounty.reset&7."
		else if arg-1 is "check":
			if arg-2 is set:
				send "{@P} &3%arg-2%&7's bounty is currently {@currency}&3%{bounty::%arg-2's uuid%}%&7."
			else:
				send "{@P} Invalid Syntax. &3/bounty check (player)&7."
		else:
			send "{@P} Commands."
			send ""
			send "&7/bounty &3add (player) (amount)"
			send "&7/bounty &3reset (player) &7&o(bounty.reset)"
			send "&7/bounty &3check (player)"
			send ""
			
on death:
	if victim is a player:
		if attacker is a player:
			if {bounty::%victim's uuid%} > 0:
				add {bounty::%victim's uuid%} to attacker's balance
				broadcast "{@P} &3%attacker%&7 has claimed &3%victim%&7's bounty of {@currency}&3%{bounty::%victim's uuid%}%&7."
				wait 3 ticks
				set {bounty::%victim's uuid%} to 0

```

```
options:
  bypass: anticaptcha.bypass
  kickmessage: &4Failed Captcha
  chatmessage: &4You May Not send a message till you prove Captcha
  movemessage: &4You May Not move till you prove Captcha
  time: 10 
           # (to kick him if he doesnt answer in this time span counted in seconds) 

on join:
  if player has permission "{@bypass}":
    stop
  else:
    set {captcha::code::%player's uuid%} to random 8 char string from charset `a-zA-Z0-9`
    set {captcha::%player's uuid%} to true
    loop {@time} times:
      send action bar "&9CAPTCHA CODE: &a&l%{captcha::code::%player's uuid%}%" to player
      wait 1 second
    if {captcha::%player's uuid%} is true:
      kick player due to "{@kickmessage}"

on chat:
  if {captcha::%player's uuid%} is true:
    if message is "%{captcha::code::%player's uuid%}%":
      set {captcha::%player's uuid%} to false
    else:
      cancel event
      send "{@chatmessage}" to player

on any movement:
  if {captcha::%player's uuid%} is true:
    cancel event
    send "{@kickmessage}" to player

on quit:
  delete {captcha::%player's uuid%}

```

```
#Chairs+ skripted by: SH4D03
#Donations: paypal.me/SH4D03


#Leave any lore as %{_none}% to make it blank
options:
	item: tripwire hook #This is the chair token item
	name: &b&lChair Token #This is the name of the chair token
	lore1: &7Right click on a block #This is the first line of lore of the chair token
	lore2: &7to turn it into a chair! #This is the second line of lore of the chair token
	lore3: %{_none}% #This is the third line of lore of the chair token 
	lore4: &cDisclaimer: &7Each token can only be used once #This is the fourth line of lore of the chair token










on right click with {@item}:
	if name of player's tool is "{@name}":
		cancel event
		remove 1 of player's tool from player's tool
		add location of clicked block to {chair::*}

on break:
	if {chair::*} contains location of event-block:
		remove location of event-block from {chair::*}

on right click:
	if {chair::*} contains location of clicked block:
		chair(player, location of clicked block)

command /chair [<player=%player%>] [<integer=1>]:
	trigger:
		set {_none} to ""
		give arg-2 of {@item} named "{@name}" with lore "{@lore1}", "{@lore2}", "{@lore3}" and "{@lore4}" to arg-1

function chair(p: player, b: location):
	spawn armor stand at location of block below block at {_b}
	set {_entity} to last spawned armor stand
	add "{Invisible:1}" to nbt of last spawned armor stand
	add "{NoGravity:1}" to nbt of last spawned armor stand
	make {_p} ride {_entity}
	while {_entity} exists:
		if {_p} is sneaking:
			eject any passenger of {_entity}
			wait 2 ticks
			kill {_entity}
		wait 5 tick

```

```
# ChatFeelings owo

# -Permissions-
# chatfeelings.feelingname to give access to a specific feeling (replace feelingname with the name of the feeling)
# chatfeelings.all to give access to all feelings

options:
	#  -Feelings-
	# first option means enabled. true = enabled, false = disabled
	# feelingsender is the message sent to the person who typed the command
	# feelingtarget is the message sent to the person mentioned in the command
	# feelingglobal is the message sent to the whole server
	
	#Hug
	hug: true
	hugsender: &7You give &a&l%arg 1% &r&7a warm hug. &cAwww &4❤
	hugtarget: &a&l%player% &r&7gives you a warm hug. &cAwww &4❤
	hugglobal: &a&l%player% &r&7gave &2&l%arg 1% &r&7a warm hug. &cAwww &4❤
	#Bite
	bite: true
	bitesender: &7You sink your teeth into &c&l%arg 1%&r&7's skin.
	bitetarget: &c&l%player% &r&7sinks their teeth into your skin.
	biteglobal: &c&l%player% &r&7sank their teeth into &4&l%arg 1%&r&7''s skin
	#Punch
	punch: true
	punchsender: &7You strike &c&l%arg 1% &r&7with a punch. Ouch!
	punchtarget: &c&l%player% &r&7strikes you with a punch. Ouch!
	punchglobal: &c&l%player% &r&7punched &4&l%arg 1% &r&7right in the face.
	#Murder
	murder: true
	murdersender: &7You murder &c&l%arg 1% &r&7and have no regrets.
	murdertarget: &c&l%player% &r&7just murdered you. Bandaid anyone?
	murderglobal: &c&l%player% &r&7just murdered &4&l%arg 1%&r&7. &7&lRIP
	#Boi
	boi: true
	boisender: &7You inhale at &e&l%arg 1%&r&7... &6&lBOI
	boitarget: &e&l%player% &r&7inhales at you... &6&lBOI
	boiglobal: &e&l%player% &r&7inhales at &6&l%arg 1%&r&7... &6&l&oBOI
	#Dab
	dab: true
	dabsender: &7You freshly dab on &a&l%arg 1%&r&7... &7&oGot'em.
	dabtarget: &a&l%player% &r&7freshly dabs on you... &7&oGot'em.
	dabglobal: &a&l%player% &r&7freshly dabs on &2&l%arg 1%&r&7... &7&oGot'em.
	#Cry
	cry: true
	crysender: &7You cry on &b&l%arg 1%&r&7''s shoulder.
	crytarget: &b&l%player% &r&7cries on your shoulder.
	cryglobal: &b&l%player% &r&7leans on &3&l%arg 1%&r&7''s shoulder and cries.
	#Facepalm
	facepalm: true
	facepalmsender: &7You facepalm at what &e&l%arg 1% &r&7just said.
	facepalmtarget: &e&l%player% &r&7facepalmed at what you just said.
	facepalmglobal: &e&l%player% &r&7facepalms at &6&l%arg 1%&r&7 for being dumb.
	#Highfive
	highfive: true
	highfivesender: &7You give a mighty highfive to &a&l%arg 1%&7.
	highfivetarget: &a&l%player% &7gives you a mighty highfive.
	highfiveglobal: &a&l%player% &7gives &2&l%arg 1% &r&7a mighty highfive.
	#Kiss
	kiss: true
	kisssender: &7You give &a&l%arg 1% &r&7a kiss. &cAwww &4❤
	kisstarget: &a&l%player% &r&7gives you a kiss. &cAwww &4❤
	kissglobal: &a&l%player% &7gives &2&l%arg 1% &7a kiss. &cAwww &4❤
	#Lick
	lick: true
	licksender: &7You lick &e&l%arg 1% &7like ice-cream. &6Gross!
	licktarget: &e&l%player% &r&7licks you like ice-cream. &6Gross!
	lickglobal: &e&l%arg 1% &r&7got licked by &6&l%player%&r&7. &8Gross.
	#Shake
	shake: true
	shakesender: &7You shake &c&l%arg 1%&r&7's entire body.
	shaketarget: &c&l%player% &r&7shakes your entire body.
	shakeglobal: &c&l%player% &r&7picks up &4&l%arg 1%&r&7''s body, and shakes it.
	#Snuggle
	snuggle: true
	snugglesender: &7You snuggle &a&l%arg 1% &r&7with love. &cAwww &4❤
	snuggletarget: &a&l%player% &r&7snuggles you with love. &cAwww &4❤
	snuggleglobal: &a&l%player% &r&7snuggles &2&l%arg 1% &r&7them with hugs. &cAwww &4❤
	#Yell
	yell: true
	yellsender: &7You yell at &c&l%arg 1%&r&7 at the top of your lungs.
	yelltarget: &c&l%player% &r&7yells at you from the top of their lungs.
	yellglobal: &c&l%player% &r&7yells right at &4&l%arg 1% &r&7from the top of their lungs.
	#Poke
	poke: true
	pokesender: &7You poked &e&l%arg 1%&7. Maybe they're on vacation?
	poketarget: &e&l%player% &r&7has poked you. Anyone there?
	pokeglobal: &e&l%arg 1% &r&7was poked by &6&l%player%&r&7. &7&oAnyone home?
	#Slap
	slap: true
	slapsender: &7You slap &c&l%arg 1% &r&7with some spaghetti.
	slaptarget: &c&l%player% &r&7slaps you with some spaghetti.
	slapglobal: &c&l%arg 1% &r&7was slapped by &4&l%player%&r&7.
	#Stab
	stab: true
	stabsender: &7You stab &c&l%arg 1% &r&7with a knife. Got Bandaids?
	stabtarget: &c&l%player% &r&7grabs a knife and stabs you. Got Bandaids?
	stabglobal: &c&l%player% &r&7grabs a knife and stabs &4&l%arg 1%&r&7.
	#Pat
	pat: true
	patsender: &7You gently pat &a&l%arg 1%&r&7's head for being good.
	pattarget: &a&l%player% &r&7gently pats your head for being good.
	patglobal: &a&l%player% &r&7gently pats &2&l%arg 1%&r&7's head for being good.
	#Scorn
	scorn: true
	scornsender: &7You scorn &c&l%arg 1% &r&7for what they've done.
	scorntarget: &c&l%player% &r&7scorns you for what you've done.
	scornglobal: &c&l%player% &r&7scorns &4&l%arg 1% &r&7for what they've done.
	#Stalk
	stalk: true
	stalksender: &7You carefully stalk &e&l%arg 1%&r&7, &7&oHeh Heh.
	stalktarget: &e&l%player% &r&7stalks you from a nearby tree.
	stalkglobal: &e&l%player% &r&7stalks &6&l%arg 1% &r&7from a nearby tree.
	
command /hug [<player>]:
	trigger:
		if {@hug} = true:
			if player has permission "chatfeelings.all" or "chatfeelings.hug":
				if arg 1 is set:
					send "{@hugsender}" to player
					send "{@hugtarget}" to arg 1
					broadcast "{@hugglobal}"
				else:
					send "&cSeems like you forgot to say who you were hugging..."
			else:
				send "&cSorry, you can not do that :("

command /bite [<player>]:
	trigger:
		if {@bite} = true:
			if player has permission "chatfeelings.all" or "chatfeelings.bite":
				if arg 1 is set:
					send "{@bitesender}" to player
					send "{@bitetarget}" to arg 1
					broadcast "{@biteglobal}"
				else:
					send "&cSeems like you forgot to say who you were biteing..."
			else:
				send "&cSorry, you can not do that :("

command /punch [<player>]:
	trigger:
		if {@punch} = true:
			if player has permission "chatfeelings.all" or "chatfeelings.punch":
				if arg 1 is set:
					send "{@punchsender}" to player
					send "{@punchtarget}" to arg 1
					broadcast "{@punchglobal}"
				else:
					send "&cSeems like you forgot to say who you were punching..."
			else:
				send "&cSorry, you can not do that :("
			
command /murder [<player>]:
	trigger:
		if {@murder} = true:
			if player has permission "chatfeelings.all" or "chatfeelings.murder":
				if arg 1 is set:
					send "{@murdersender}" to player
					send "{@murdertarget}" to arg 1
					broadcast "{@murderglobal}"
				else:
					send "&cSeems like you forgot to say who you were murdering..."
			else:
				send "&cSorry, you can not do that :("
			
command /boi [<player>]:
	trigger:
		if {@boi} = true:
			if player has permission "chatfeelings.all" or "chatfeelings.boi":
				if arg 1 is set:
					send "{@boisender}" to player
					send "{@boitarget}" to arg 1
					broadcast "{@boiglobal}"
				else:
					send "&cSeems like you forgot to say who you were boiing..."
			else:
				send "&cSorry, you can not do that :("
			
command /dab [<player>]:
	trigger:
		if {@dab} = true:
			if player has permission "chatfeelings.all" or "chatfeelings.dab":
				if arg 1 is set:
					send "{@dabsender}" to player
					send "{@dabtarget}" to arg 1
					broadcast "{@dabglobal}"
				else:
					send "&cSeems like you forgot to say who you were dabbing..."
			else:
				send "&cSorry, you can not do that :("
			
command /cry [<player>]:
	trigger:
		if {@cry} = true:
			if player has permission "chatfeelings.all" or "chatfeelings.cry":
				if arg 1 is set:
					send "{@crysender}" to player
					send "{@crytarget}" to arg 1
					broadcast "{@cryglobal}"
				else:
					send "&cSeems like you forgot to say who you were crying..."
			else:
				send "&cSorry, you can not do that :("
			
command /facepalm [<player>]:
	trigger:
		if {@facepalm} = true:
			if player has permission "chatfeelings.all" or "chatfeelings.facepalm":
				if arg 1 is set:
					send "{@facepalmsender}" to player
					send "{@facepalmtarget}" to arg 1
					broadcast "{@facepalmglobal}"
				else:
					send "&cSeems like you forgot to say who you were facepalming..."
			else:
				send "&cSorry, you can not do that :("
			
command /highfive [<player>]:
	trigger:
		if {@highfive} = true:
			if player has permission "chatfeelings.all" or "chatfeelings.highfive":
				if arg 1 is set:
					send "{@highfivesender}" to player
					send "{@highfivetarget}" to arg 1
					broadcast "{@highfiveglobal}"
				else:
					send "&cSeems like you forgot to say who you were highfiveing..."
			else:
				send "&cSorry, you can not do that :("

command /kiss [<player>]:
	trigger:
		if {@kiss} = true:
			if player has permission "chatfeelings.all" or "chatfeelings.kiss":
				if arg 1 is set:
					send "{@kisssender}" to player
					send "{@kisstarget}" to arg 1
					broadcast "{@kissglobal}"
				else:
					send "&cSeems like you forgot to say who you were kissing..."
			else:
				send "&cSorry, you can not do that :("
			
command /lick [<player>]:
	trigger:
		if {@lick} = true:
			if player has permission "chatfeelings.all" or "chatfeelings.lick":
				if arg 1 is set:
					send "{@licksender}" to player
					send "{@licktarget}" to arg 1
					broadcast "{@lickglobal}"
				else:
					send "&cSeems like you forgot to say who you were licking..."
			else:
				send "&cSorry, you can not do that :("
			
command /shake [<player>]:
	trigger:
		if {@shake} = true:
			if player has permission "chatfeelings.all" or "chatfeelings.shake":
				if arg 1 is set:
					send "{@shakesender}" to player
					send "{@shaketarget}" to arg 1
					broadcast "{@shakeglobal}"
				else:
					send "&cSeems like you forgot to say who you were shaking..."
			else:
				send "&cSorry, you can not do that :("
			
command /snuggle [<player>]:
	trigger:
		if {@snuggle} = true:
			if player has permission "chatfeelings.all" or "chatfeelings.snuggle":
				if arg 1 is set:
					send "{@snugglesender}" to player
					send "{@snuggletarget}" to arg 1
					broadcast "{@snuggleglobal}"
				else:
					send "&cSeems like you forgot to say who you were snuggling..."
			else:
				send "&cSorry, you can not do that :("
			
command /yell [<player>]:
	trigger:
		if {@yell} = true:
			if player has permission "chatfeelings.all" or "chatfeelings.yell":
				if arg 1 is set:
					send "{@yellsender}" to player
					send "{@yelltarget}" to arg 1
					broadcast "{@yellglobal}"
				else:
					send "&cSeems like you forgot to say who you were yelling..."
			else:
				send "&cSorry, you can not do that :("
			
command /poke [<player>]:
	trigger:
		if {@poke} = true:
			if player has permission "chatfeelings.all" or "chatfeelings.poke":
				if arg 1 is set:
					send "{@pokesender}" to player
					send "{@poketarget}" to arg 1
					broadcast "{@pokeglobal}"
				else:
					send "&cSeems like you forgot to say who you were pokeing..."
			else:
				send "&cSorry, you can not do that :("
				
command /slap [<player>]:
	trigger:
		if {@slap} = true:
			if player has permission "chatfeelings.all" or "chatfeelings.slap":
				if arg 1 is set:
					send "{@slapsender}" to player
					send "{@slaptarget}" to arg 1
					broadcast "{@slapglobal}"
				else:
					send "&cSeems like you forgot to say who you were slapping..."
			else:
				send "&cSorry, you can not do that :("
			
command /stab [<player>]:
	trigger:
		if {@stab} = true:
			if player has permission "chatfeelings.all" or "chatfeelings.stab":
				if arg 1 is set:
					send "{@stabsender}" to player
					send "{@stabtarget}" to arg 1
					broadcast "{@stabglobal}"
				else:
					send "&cSeems like you forgot to say who you were stabbing..."
			else:
				send "&cSorry, you can not do that :("
			
command /pat [<player>]:
	trigger:
		if {@pat} = true:
			if player has permission "chatfeelings.all" or "chatfeelings.pat":
				if arg 1 is set:
					send "{@patsender}" to player
					send "{@pattarget}" to arg 1
					broadcast "{@patglobal}"
				else:
					send "&cSeems like you forgot to say who you were patting..."
			else:
				send "&cSorry, you can not do that :("
			
command /scorn [<player>]:
	trigger:
		if {@scorn} = true:
			if player has permission "chatfeelings.all" or "chatfeelings.scorn":
				if arg 1 is set:
					send "{@scornsender}" to player
					send "{@scorntarget}" to arg 1
					broadcast "{@scornglobal}"
				else:
					send "&cSeems like you forgot to say who you were scorning..."
			else:
				send "&cSorry, you can not do that :("
			
command /stalk [<player>]:
	trigger:
		if {@stalk} = true:
			if player has permission "chatfeelings.all" or "chatfeelings.stalk":
				if arg 1 is set:
					send "{@stalksender}" to player
					send "{@stalktarget}" to arg 1
					broadcast "{@stalkglobal}"
				else:
					send "&cSeems like you forgot to say who you were stalking..."
			else:
				send "&cSorry, you can not do that :("

```

```
#This skript is made by XI_DEMO_IX!
#If you have any issuses please contact X̸I̶_̵D̷E̷M̷O̷_̸I̸X̴#8207 on discord!

command /mutechat:
    permission: mute.chat
    permission message: "&cYou do not have permission!"
    trigger:
        if {chatMuted} is true:
            set {chatMuted} to false
            broadcast "&b[&cServerName&b]&r &6Chat has been unmuted by %player%!"
        else:
            set {chatMuted} to true
            broadcast "&b[&cServerName&b]&r &6Chat has been muted by %player%!"

on chat:
    if {chatMuted} is true:
        player doesn't have permission "mute.talk":
            send "&b[&cServerName&b]&r &6Chat is currently muted!"
            cancel event
        else if player has permission "mute.talk":
            uncancel event

```

```
#
# Chatty - made by WolfyGameYT
#
# VERSION: 1.1
# PLUGINS: Any permission plugin (Default is PermissionEX)
#


options:
#Put "on" to turn on that part of the script and "off" to turn off that part of the script! 
	announcement: on
	mutechat: on
	clearchat: on
	censored: on
	chatformat: on
	join/leave msg: on
#Change the prefixes and permission message here!
	bcprefix: &8&l[&5&lAnnouncement&8&l]
	serverprefix: &3&lChatty &b&l»
	pm: &3&lChatty &b&l» &4You can't do that!
#Change the permission commands here!
	talkpower1: /pex user %arg-2% add chat.mute.bypass
	talkpower2: /pex user %arg-2% remove chat.mute.bypass
#Change the permission nodes here!
	chattyinfo: chatty.info                   #Permission to do /chattyinfo
	broadcast: chatty.broadcast               #Permission to do /bc or /broadcast
	broadcastsee: chatty.broadcast.see        #Permission to see the sent broadcast in a different world if the world is set
	talkpower: chatty.chat.mute.talkpower     #Permission to do /talkpower
	chatmute: chatty.chat.mute                #Permission to do /mutechat
	chatbypass: chatty.chat.mute.bypass       #Permission to talk when chat is muted
	chatclear: chatty.clearchat               #Permission to clear the chat
	censoredbypass: chatty.censored.bypass    #Permission to say words that are censored
		
command /chattyinfo:
	permission: {@chattyinfo}
	permission message: {@pm}
	trigger:
		send ""	 
		send "     &1&l----------"
		send "      &b&lInformation"
		send "&1&l----------------"
		send "&3Script Name: &9Chatty"
		send "&3Creator: &9WolfyGameYT"	
		send "&3Version: &91.1"
		send "&1&l----------------"	
		send ""
	
# vvv ANNOUNCEMENT vvv
command /bc [<world>] [<text>]:
	permission: {@broadcast}
	permission message: {@pm}
	trigger:
		if {@announcement} is on:
			if arg-2 is not set:
				send "{@serverprefix} &cPlease type something!"
			if arg-2 is set:
				if arg-1 is not set:
					broadcast "{@bcprefix} &f%coloured arg-2%"	
			if arg-1 is set:		
				broadcast "{@bcprefix} &f%coloured arg-2%" to arg-1
				if player has permission "{@broadcastsee}":
					send "{@bcprefix} &d&l(%arg-1%&d&l) &f%coloured arg-2%"
		if {@announcement} is off:
			stop

command /broadcast [<world>] [<text>]:
	permission: {@broadcast}
	permission message: {@pm}
	trigger:
		if {@announcement} is on:
			if arg-2 is not set:
				send "{@serverprefix} &cPlease type something!"
			if arg-2 is set:
				if arg-1 is not set:
					broadcast "{@bcprefix} &f%coloured arg-2%"	
			if arg-1 is set:		
				broadcast "{@bcprefix} &f%coloured arg-2%" to arg-1
				if player has permission "{@broadcastsee}":
					send "{@bcprefix} &d&l(%arg-1%&d&l) &f%coloured arg-2%"
		if {@announcement} is off:
			stop

# vvv MUTECHAT vvv		
command /talkpower <text> <player>:
	permission: {@talkpower}
	permission message: {@pm}
	trigger:
		if {@mutechat} is on:
			if arg-1 is set:
				if arg-2 is not set:
					send "{@serverprefix} &cPlease insert a username!" 
			if arg-2 is set:
				if arg-1 is not "on" or "off" or "check":
					send "{@serverprefix} &cPlease insert &c&lon&c, &c&loff&c&c, or &c&lcheck&c!"
			if arg-1 is "on":
				if arg-2 is set:
					send "{@serverprefix} &7You're chat mute bypass has been &8enabled" to arg-2
					make console execute "{@talkpower1}"
			if arg-1 is "off":
				if arg-2 is set:
					send "{@serverprefix} &7You're chat mute bypass has been &8disabled" to arg-2
					make console execute "{@talkpower2}"
			if arg-1 is "check":	
				if arg-2 is set:
					if arg-2 has permission "chat.mute.bypass":
						send "{@serverprefix} &8%arg-2% &7has chat bypass &8enabled"
					else if arg-2 does not have permission "chat.mute.bypass":	
						send "{@serverprefix} &8%arg-2% &7has chat bypass &8disabled"
		if {@mutechat} is off:
			stop

command /mutechat:
	permission: {@chatmute}
	permission message: {@pm}
	trigger:
		if {@mutechat} is on:
			if {Globalchat} is not set:
				set {Globalchat} to true
				broadcast "{@serverprefix} &7Chat has been muted by &8%player%"
				stop trigger
			if {Globalchat} is set:
				clear {Globalchat}
				broadcast "{@serverprefix} &7Chat has been unmuted by &8%player%"
		if {@mutechat} is off:
			stop

on chat:
	if {@mutechat} is on:
		if {Globalchat} is true:
			if player has permission "{@chatbypass}":
				stop trigger
			else:
				cancel event
				send "{@serverprefix} &7Chat is muted"
		if {@mutechat} is off:
			stop
			
# vvv CLEARCHAT vvv			
command /clearchat:
	permission: {@chatclear}
	permission message: {@pm}
	trigger:
		if {@clearchat} is on:
			loop 1000 times:
				broadcast ""
			broadcast "{@serverprefix} &7Chat cleared by &8%player%"	
		if {@clearchat} is off:
			stop
	
# vvv CENSORED vvv		
on chat:
	if {@censored} is on:
		if player does not have permission "{@censoredbypass}":
			if message contains "censoredwordexample1" or "censoredwordexample2" or "censoredwordexample3":
				cancel the event
				message "&4(!) &cYou can't say that &4(!)"
		if player has permission "{@censoredbypass}":	
			stop
	if {@censored} is off:
		stop

# vvv CHATFORMAT (might show an error if you're using the skunity parser, but is should still work) vvv	
on chat:
	if {@chatformat} is on:
		set chat format to "%player's prefix%%player% %player's suffix%&e»&f %colored message%"
	if {@chatformat} is off:
		stop

# vvv JOIN/LEAVE MSG vvv
on first join:
	if {@join/leave msg} is on:
		send "{@serverprefix} &7Welcome %player% to the server!"	
	if {@join/leave msg} is off:
		stop
	
on join:
	if {@join/leave msg} is on:	
		send "{@serverprefix} &7%player% Joined"
	if {@join/leave msg} is off:
		stop
		
on quit:
	if {@join/leave msg} is on:	
		send "{@serverprefix} &7%player% Left"
	if {@join/leave msg} is off:
		stop

```

```
#Made by xlr100#6932 (For any bugs)

#--------------------------------------------------------
#Configuration
options:
    permission: skript.clearlag
    permission message: &cYou don't have access to this command!
    prefix: &e&l[Clearlag]
    cooldown: 5 minutes
    wait: 10 seconds
#--------------------------------------------------------

every {@cooldown}:
    {clearlag} isn't false
    broadcast "{@prefix} &aClearing lag in {@wait}!"
    wait {@wait}
    make console execute command "/clear lag all"

command /clear [<text>] [<text>] [<text>]:
    permission: {@permission}
    permission message: {@permission message}
    trigger:
        if arg-1 is "lag":
            if arg-2 is "mobs":
                delete all mobs
                broadcast "{@prefix} &6Cleared all mobs"
            else if arg-2 is "drops":
                delete all dropped items
                broadcast "{@prefix} &6Cleared all dropped items"
            else if arg-2 is "all":
                make console execute command "/clear lag mobs"
                make console execute command "/clear lag drops"
            else if arg-2 is "toggle":
                if {clearlag} is false:
                    set {clearlag} to true
                    send "{@prefix} » &aClearlag is now on"
                else:
                    set {clearlag} to false
                    send "{@prefix} » &aClearlag is now off"
            else:
                send "{@prefix} &cCorrect Usage: &7/clear lag mobs/drops/all/toggle"
        else if arg-1 is "chat":
            loop 100 times:
                broadcast ""
            broadcast "&eChat cleared by &b%player%"
        else:
            send "&7-----------------{@prefix}&7-----------------------"
            send "&e/clear lag mobs &7Clears all mobs"
            send "&e/clear lag drops &7Clears all dropped items"
            send "&e/clear lag all &7Clears all dropped items and mobs"
            send "&e/clear lag toggle &7Toggle clearlag on/off"
            send "&e/clear chat &7Clears the chat"
            send "&7-----------------{@prefix}&7-----------------------"

```

```

# CommandBlocker by Farwl@FarwlOSS

# CODE #

# Events

command:
    loop {blockedcommands::*}:
        loop-value = "%command%":
            cancel event
            send "&cCommand blocked."

# Commands

command /commandblocker [<text>]:
	aliases: /cb:commandblocker, /cb, /cb:cb
	permission: cb.commandblocker
	permission message: {@np}
	trigger:
		set {_a::*} to (the args) split at " "
		{_a::1} is set:
			{_a::1} = "add":
				{_a::2} is set:
					{blockedcommands::*} contains "%{_a::2}%":
						send "&cThat command is already blocked, so you can't add it."
					else:
						{_a::2} = "commandblocker" or "cb" or "cb:commandblocker" or "cb:cb":
							send "&cThis command can only be disabled from the config."
						else:
							add "%{_a::2}%" to {blockedcommands::*}
							send "&aCommand '%{_a::2}%' is now blocked."
				else:
					send "&c/cb [add/remove/list] [command]"
			else if {_a::1} = "remove":
				{blockedcommands::*} contains "%{_a::2}%":
					remove "%{_a::2}%" from {blockedcommands::*}
					send "&aCommand '%{_a::2}%' is no longer blocked."
				else:
					send "&cThat command isn't blocked, so you can't remove it."
			else if {_a::1} = "list":
				size of {blockedcommands::*} > 0:
					send "&aRetrieving blocked commands..."
					set {_s} to size of {blockedcommands::*}
					set {_c::*} to {blockedcommands::*}
					send "&7Found &a&l%{_s}% &7blocked commands: &a%{_c::*}%"
				else:
					send "&cThere are no blocked commands, add some with /cb add"
			else:
				send "&c/cb [add/remove/list] [command]"
		else:
			send "&c/cb [add/remove/list] [command]"

```

```
options:
    storage: doors
    prefix: &c&lDoors »
    time: 6 seconds
    input error: &cIncorrect input, please enter a 4 number password (for example 1234)
    input length: &cPassword size incorrect, a password is 4 numbers long (for example 1234)
    cancel wait: &cProccess calceled, took too long
    sound: ENTITY_EXPERIENCE_ORB_PICKUP

function Door_PasswordFormat(pas: string) :: string:
    set {_numbers::*} to {_pas} split at ""
    set {_str} to ""
    loop {_numbers::*}:
        add 1 to {_count}
        if {_count} < 4:
            set {_str} to "%{_str}%%loop-value%-"
        else:
            set {_str} to "%{_str}%%loop-value%"
    return {_str}

function Door_PlayerReset(p: player):
    set {_u} to uuid of {_p}
    delete {{@storage}::player::%{_u}%::doors::start}
    delete {{@storage}::player::%{_u}%::doors::loc}
    delete {{@storage}::player::%{_u}%::doors::password}

on place of door:
    set {{@storage}::player::%uuid of player%::doors::setup} to location of event-block
    send "{@prefix} &7Please enter a password of 4 numbers for the door (for example 1234)"

on break of door:
    if {{@storage}::location::%location of event-block%::owner} is set:
        set {_loc} to location of event-block
    else if {{@storage}::location::%location of block above event-block%::owner} is set:
        set {_loc} to location of block above event-block
    else if {{@storage}::location::%location of block below event-block%::owner} is set:
        set {_loc} to location of block below event-block
    else:
        stop
    delete {{@storage}::location::%{_loc}%::owner}
    delete {{@storage}::location::%{_loc}%::password}
    send "{@prefix} &cDoor Information Deleted"

on rightclick on door:
    if {{@storage}::location::%location of event-block%::owner} is set:
        set {_loc} to location of event-block
    else if {{@storage}::location::%location of block above event-block%::owner} is set:
        set {_loc} to location of block above event-block
    else if {{@storage}::location::%location of block below event-block%::owner} is set:
        set {_loc} to location of block below event-block
    else:
        stop
    if {{@storage}::location::%{_loc}%::owner} isn't player:
        cancel event
        if {{@storage}::player::%uuid of player%::doors::start} is set:
            set {_wait} to difference between now and {{@storage}::player::%uuid of player%::doors::start}
            if {_wait} >= {@time}:
                Door_PlayerReset(player)
                stop
        # broadcast "Owner: %{{@storage}::location::%{_loc}%::owner}%"
        # broadcast "Location: %{_loc}%"
        send title "&c&lLocked Door!" with subtitle "&cPassword: &7X-X-X-X" to player for {@time}
        send "{@prefix} &7Please enter a password of 4 numbers (for example 1234) within the next {@time}"
        set {{@storage}::player::%uuid of player%::doors::loc} to {_loc}
        set {{@storage}::player::%uuid of player%::doors::start} to now
        set {{@storage}::player::%uuid of player%::doors::password} to {{@storage}::location::%{_loc}%::password}

on chat:
    if {{@storage}::player::%uuid of player%::doors::setup} is set:
        cancel event
        if length of message is 4:
            set {_numbers::*} to message split at ""
            loop {_numbers::*}:
                set {_temp} to "%loop-value%" parsed as integer
                if {_temp} >= 0:
                    add 1 to {_count}
                else: #Less than 0 or not an integer
                    send "{@prefix} {@input error}"
                    stop
            set {_loc} to {{@storage}::player::%uuid of player%::doors::setup}
            set {{@storage}::location::%{_loc}%::owner} to player
            # broadcast "Location: %{_loc}%"
            # broadcast "Owner: %{{@storage}::location::%{_loc}%::owner}%"
            set {{@storage}::location::%{_loc}%::password} to message
            delete {{@storage}::player::%uuid of player%::doors::setup}
            send "{@prefix} &7Successfully set a door with the password &f%message%"
        else:
            send "{@prefix} {@input length}"
    else if {{@storage}::player::%uuid of player%::doors::start} is set:
        cancel event
        set {_wait} to difference between now and {{@storage}::player::%uuid of player%::doors::start}
        if {_wait} >= {@time}:
            Door_PlayerReset(player)
            send "{@prefix} {@cancel wait}"
        else:
            if length of message is 4:
                if message is {{@storage}::player::%uuid of player%::doors::password}:
                    send player title "&a&lDoor Unlocked!" with subtitle "&aPassword: &7%Door_PasswordFormat(message)%" for 3 seconds with 1 second fade in and 1 second fade out
                    set {_loc} to {{@storage}::player::%uuid of player%::doors::loc}
                    toggle block at {_loc}
                    Door_PlayerReset(player)
                    play "{@sound}" to player
                    wait 2 seconds
                    toggle block at {_loc}

                else:
                    send "{@prefix} &cIncorrect Password"
            else:
                send "{@prefix} {@input length}"

```

```
Options:
    padblock: gold block
    defaultforce: 2


command /boostpad [<text = create>] [<number = {@defaultforce}>]:
    permission: boostpad.admin
    trigger:
        set {_d} to block at player's location
        remove 1 from the y coordinate of {_d}
        if arg-1 is "create":
            if {padblocks::*} doesn't contain {_d}:
                set block at {_d} to {@padblock}
                add {_d} to {padblocks::*}
                set {padforce::%{_d}%} to arg-2
            else:
                send "&cThere is already a valid boostpad at this location."
        else if arg-1 is "delete":
            if {padblocks::*} contains {_d}:
                set block at {_d} to air
                remove {_d} from {padblocks::*}
                delete {padforce::%{_d}%}
            else:
                send "&cThere is no valid boostpad at this location."
        else if arg-1 is "setforce" or "force" or "setpower" or "power":
            if {padblocks::*} contains {_d}:
                set {padforce::%{_d}%} to arg-2
            else:
                send "&cThere is no valid boostpad at this location."
        else if arg-1 is "edit":
            if {padblocks::*} contains {_d}:
                send formatted "&aEditing the boostpad at %{_d}%:","<tooltip: &aClick here to change!><suggest command:/boostpad power >&8Current power: &b(&2%{padforce::%{_d}%}%<reset>&b)","<command:/boostpad delete>&cClick here to delete the boostpad!"
            else:
                send "&cThere is no valid boostpad at this location."
        else if arg-1 is "EditWand" or "edit-wand" or "editwand" or "getwand" or "get" or "wand":
            give player a stick named "&aBoostpad edit wand!"

command /boostpad2 [<text = delete>] [<number = {@defaultforce}>]:
    permission: boostpad.wand
    trigger:
        set {_d} to location of player's targeted block
        if arg-1 is "delete":
            if {padblocks::*} contains {_d}:
                set block at {_d} to air
                remove {_d} from {padblocks::*}
                delete {padforce::%{_d}%}
            else:
                send "&cThere is no valid boostpad where you are looking."
        else if arg-1 is "setforce" or "force" or "setpower" or "power":
            if {padblocks::*} contains {_d}:
                set {padforce::%{_d}%} to arg-2
            else:
                send "&cThere is no valid boostpad at this where you are looking."


on right click with a stick:
    name of player's tool contains "Boostpad edit wand!":
        player has permission "boostpad.wand" or "boostpad.admin":
            set {_d} to location of event-block
            {padblocks::*} contains {_d}
            send formatted "&aEditing the boostpad at %{_d}%:","<tooltip: &aClick here to change!><suggest command:/boostpad2 power >&8Current power: &b(&2%{padforce::%{_d}%}%<reset>&b)","<command:/boostpad2 delete>&cClick here to delete the boostpad!"



on walk on {@padblock}:
    if {padblocks::*} contains location of event-block:
        set {_d} to (direction from player's location to location 150 meters in front of player)
        push player {_d} with force ({padforce::%location of event-block%}*2)

```

```
on join:
  if {balance::%player's uuid%} is not set:
    set {balance::%player's uuid%} to 0

command /eco [<text>] [<player>] [<integer>]:
  permission: admin.*
  trigger:
    if arg-1 is set:
      if arg-2 is set:
        if arg-3 is set:
          if arg-1 is "give":
            add arg-3 to {balance::%arg-2's uuid%}
            send "&aAdded &c%arg-3%&c$ &ato &c%arg-2%&c's &abalance!"
          else if arg-1 is "take":
            subtract arg-3 from {balance::%arg-2's uuid%}
            send "&aRemoved &c%arg-3%&c$ &afrom &c%arg-2%&c's &abalance!"
          else if arg-1 is "set":
            set {balance::%arg-2's uuid%} to arg-3
            send "&aSet &c%arg-2%&c's &abalance to &c%arg-3%&c$&a!"
        else:
          send "&cPlease use this format: /eco [give:take:set] [player] [value]"
      else:
        send "&cPlease use this format: /eco [give:take:set] [player] [value]"
    else:
      send "&cPlease use this format : /eco [give:take:set] [player] [value]"

command /bal [<player>]:
  aliases: balance, bal, money
  trigger:
    if arg-1 is not set:
      send "&aBalance: &c%{balance::%sender's uuid%}%&c$"
    if arg-1 is set:
      send "&a%arg-1%&a's balance: &c%{balance::%arg-1's uuid%}%&c$"

command /economy:
  trigger:
    send "&6&lCommands:"
    send ""
    send "&7Add to a player's balance &e| &8/eco give <player> <amount>"
    send "&7Take from a player's balance &e| &8/eco take <player> <amount>"
    send "&7Set a player's balance &e| &8/eco set <player> <amount>"
    send "&7Open up this page &e| &8/Economy"
    send "&7Check your current balance &e| &8/Bal"
    send ""
    send "&c&lUpdates & Patch notes will be coming!"
    send ""

```

```
options:
  headerbaltopmsg: &6===== BalTop ===== 	# Message above baltop message

  baltopamount: 10 				# how many people it will show in baltop

  footerbaltopmsg: &6===== BalTop ===== 	# Message under baltop message

  currency: $ 					# currency type example: 100 $/ 100 coins

  setbalperm: bal.set 				# Perm to set players balance

  economynotify: bal.notify 			# Perm to get notified on any change in this skript. 

  addbalperm: bal.add 				# Perm to add money to someone's balance.

  removebalperm: bal.remove 			# Perm to remove money from someone's balance.

  resetbalperm: bal.reset 			# Perm to reset everyone's balance

#
#
#  We advise you to put this skript in its own file! for maximum efficiency
#
# Baltop sorting made by ChrisLP 
#

command /baltop:
  trigger:
    loop {Balance::*}:
      add 1 to {_size}
      if {_low.to.high.list::%loop-value%} is not set:
        set {_low.to.high.list::%loop-value%} to loop-index
      else:
        set {_n} to 0
        loop {_size} times:
          set {_n} to {_n}+1
          {_low.to.high.list::%loop-value-1%.%{_n}%} is not set
          set {_low.to.high.list::%loop-value-1%.%{_n}%} to loop-index
          stop loop
    wait 1 tick
    set {_n} to size of {_low.to.high.list::*}
    loop {_low.to.high.list::*}:
      set {_high.to.low.list::%{_n}%} to loop-value
      set {_n} to {_n}-1
    wait 1 tick
    set {_i} to 0
    send "{@headerbaltopmsg}"
    loop {_high.to.low.list::*}:
      add 1 to {_topnumber}
      set {_player} to "%loop-value%" parsed as offlineplayer
      send "&7%{_topnumber}% - &c%{_player}% &8» &7%{Balance::%loop-value%}%"
      add 1 to {_i}
      if {_topnumber} > {@baltopamount}: #this is top 10 you can change it
        stop
    send "{@footerbaltopmsg}"

command balance [<offline player>]:
  aliases: bal
  trigger:
    if arg-1 is set:
      send "&6%arg-1%'s balance » %{Balance::%arg-1's uuid%}%" to player
      if {Balance::%arg-1's uuid%} > {Balance::%player's uuid%}:
        send "&e&l%arg-1% is Richer than You!" to player
      else if {Balance::%arg-1's uuid%} < {Balance::%player's uuid%}:
        send "&e&lYou ar Richer than %arg-1%!" to player
    else:
      send "&6Your Balance » %{Balance::%player's uuid%}%" to player

command pay [<player>] [<integer>]:
  trigger:
    if arg-1 is set:
      if arg-2 is set:
        if {Balance::%player's uuid%} >= arg-2:
          if arg-2 > 0:
            remove arg-2 from {Balance::%player's uuid%}
            add arg-2 to {Balance::%arg-1's uuid%}
            send "&aYou have payed %arg-1% &a %arg-2% {@currency}" to player
            send "&a%player% &a has payed you %arg-2% {@currency}" to arg-1
          else:
            send "&cYou may not pay someone 0 or less!" to player
        else:
          send "&cInsufficient funds!"
      else:
        send "&eUsage /pay (player) (amount)" to player
    else:
      send "&eUsage /pay (player) (amount)" to player

command balset [<player>] [<integer>]:
  aliases: setbalance, balanceset, setbal
  permission: {@setbalperm}
  trigger:
    if arg-1 is set:
      if arg-2 is set:
        set {Balance::%arg-1's uuid%} to arg-2
        send "&c%player% has set %arg-1%&c's balance to %arg-2%" to all players where [player input has permission "{@economynotify}"]
      else:
        send "&eUsage /balset (player) (amount)" to player
    else:
      send "&eUsage /balset (player) (amount)" to player

command baladd [<player>] [<integer>]:
  aliases: addbal, balanceadd, addbalance
  permission: {@addbalperm}
  trigger:
    if arg-1 is set:
      if arg-2 is set:
        add arg-2 to {Balance::%arg-1's uuid%}
        send "&c%player% has added %arg-2% to %arg-1%&c's balance" to all players where [player input has permission "{@economynotify}"]
      else:
        send "&eUsage /baladd (player) (amount)" to player
    else:
      send "&eUsage /baladd (player) (amount)" to player

command balremove [<player>] [<integer>]:
  aliases: removebal, balanceremove, removebalance
  permission: {@removebalperm}
  trigger:
    if arg-1 is set:
      if arg-2 is set:
        remove arg-2 from {Balance::%arg-1's uuid%}
        send "&c%player% has removed %arg-2% from %arg-1%&c's balance" to all players where [player input has permission "{@economynotify}"]
      else:
        send "&eUsage /balremove (player) (amount)" to player
    else:
      send "&eUsage /balremove (player) (amount)" to player

command BalReset:
  aliases: balancereset
  permission: {@resetbalperm}
  trigger:
    open virtual chest inventory with size 3 named "&CReset Balance" to player
    format gui slot 0,1,2,9,10,11,18,19,20 of player with green wool named "&a&lCONFIRM" with lore "&7&lMay cause some lag" to close:
      loop all offline players:
        set {Balance::%loop-offlineplayer's uuid%} to 0
      send "&aBalance has been reset to 0" to player
    format gui slot 6,7,8,15,16,17,24,25,26 of player with red wool named "&c&lCANCEL" to close:
      send "&cBalance Reset has been cancelled" to player

on load:
  send "&aBalance Skript Has Been reloaded. Use /help Balance to find a list of all commands" to all players where [player input has permission "{@economynotify}"]

on first join:
  set {Balance::%player's uuid%} to 0

on command "/help Balance":
  cancel event
  send "&6Balance Help"
  send "&6Balance (player): Check Player's balance"
  send "&6Balset (player) (amount): set Player's balance to a specific amount"
  send "&6Baladd (player) (amount): add a specific amount to a player's balance"
  send "&6Balremove (player) (amount): remove a specific amount from a player's balance"
  send "&6Pay (player) (amount): pay a Player a specific amount from your balance"
  send "&6BalTop: Check Balance leaderboards"
  send "&4&lDanger ZONE:"
  send " "
  send "&c&lBalReset: Reset everyone's balance"
  send " "
  send "&6Balance Help"

```

```
options:
  elevatorline1: [elevator] # message that must be written to setup sign
  elevatorline1set: &f[Elevator] #What the message will be set to to make sure it has been set
  signcreatemessage:&e sign has been created
  invalidtype: &eYou May only use Up or Down
  teleportupmessage: &eTeleported UP!
  teleportdownmessage: &eTeleported UP!

on sign change:
  if line 1 of event-block is "{@elevatorline1}":
    if line 2 of event-block is "Up" or "up":
      set line 1 of event-block to "{@elevatorline1set}"
      send "{@signcreatemessage}"
      set line 2 of event-block to "Up"
    else if line 2 of event-block is "Down" or "down":
      set line 1 of event-block to "{@elevatorline1set}"
      send "{@signcreatemessage}"
      set line 2 of event-block to "Down"
    else:
      send "{@invalidtype}"

on right click on sign:
  if line 1 of event-block is "{@elevatorline1set}":
    if line 2 of event-block is "Up":
      loop all blocks above event-block:
        if loop-block is air:
          if block above loop-block is air:
            teleport player to block above loop-block
            send "{@teleportupmessage}"
            stop
    else if line 2 of event-block is "Down":
      loop all blocks under event-block:
        if loop-block is air:
          if block under loop-block is air:
            teleport player to loop-block
            send "{@teleportdownmessage}"
            stop

```

```
#
# The Essentials of Essentials - made by Lupusor, Austin/Mesyl2 and TheMandalorian HEAVILY EDITED by BeanyDoesStuff_/ztimhirsch
# It was garbage and now is better - ztimhirsch
#



options:
    notify: true #Notify people with the permission to get the notification (notify.command)
    colour1: §7
    colour2: §8
    colour3: &3 
    server: &3&lTEST
    announcetime: 8 # For timed announcements! Delete if you dont use timed announcements!

command /heal [<player>]:
    permission: skript.heal
    permission message: &cInsufficient permissions!
    trigger:
        arg-1 is set:
            heal the player-argument ? player
            feed the player-argument ? player
            send "{@colour1}You have been healed." to the player-argument ? player
        send "{@colour3}%player%{@colour1} has done a command! {@colour2}/heal %arg-1 ? player%" to all players where [input has permission "notify.heal"] if {@notify} is true

command /feed [<player>]:
    permission: skript.feed
    permission message: &cInsufficient permissions!
    trigger:
        feed the player-argument ? player
        send "{@colour1}Your appetite was sated." to the player-argument ? player
        send "{@colour3}%player%{@colour1} has done a command! {@colour2}/feed %arg-1 ? player%" to all players where [input has permission "notify.feed"] if {@notify} is true

command /killall <text = all>:
    permission: skript.killall
    permission message: &cInsufficient permissions!
    trigger:
        if arg-1 is "mobs" or "Mobs":
            kill all mobs
            send "{@colour1}Killed all mobs."
        else if arg-1 is "players" or "Players":
            kill all players
            send "{@colour1}Killed all players."
        else if arg-1 is "all" or "All":
            kill all entities
            send "{@colour1}Killed all players and mobs."
        send "{@colour3}%player%{@colour1} has done a command! {@colour2}/killall %arg-1%" to all players where [input has permission "notify.killall"] if {@notify} is true

# Homes

on join:
    set {maximum::homes::%player's uuid%} to 2

command /sethome <text = home>:
    permission: skript.sethome
    description: Set your home
    usage: /sethome [Name]
    trigger:
        {maximum::homes::%player's uuid%} > (size of {homes::%player's uuid%::*}):
            set {home::%player's uuid%::%argument%} to block at location of player
            message "{@colour1}Home set!"
        else:
            send "{@colour1}You have the maximum amount of homes set"
        
command /home <text> [<player>]:
    permission: skript.home
    description: Teleport yourself to your home
    usage: /home [Name]
    trigger:
        if arg-2 is player:
            if {home::%player's uuid%::%arg-1%} is not set:
                message "&cError: You have no homes set with this name!"
            else:
                teleport player to {home::%player's uuid%::%argument-1%}
        else if arg-2 is not set:
            if {home::%player's uuid%::%arg-1%} is not set:
                message "&cError: You have no homes set with this name!"
            else:
                teleport player to {home::%player's uuid%::%argument-1%}
        else:
            player has permission "skript.homes.others":
                if {home::%arg-2's uuid%::%arg-1%} is set:
                    teleport player to {home::%arg-2's uuid%::%arg-1%}
                    send "{@colour3}%player%{@colour1} has done a command! {@colour2}/home %arg-1%{@colour2} %arg-2%" to all players where [input has permission "notify.home"] if {@notify} is true
                else:
                    message "&cError: %arg-2% &chas no homes set with this name!"
            else:
                send "&cError: You do not have permission to teleport to other people's home."

command /homes [<player>]:
    permission: skript.homes
    description: View your homes
    usage: /homes [player]
    trigger:
        if arg-1 is player:
            send "{@colour1}Homes of {@colour3}%player%"
            loop {home::%player's uuid%::*}:
                send "{@colour2}%loop-index%"
        else if arg-1 is not set:
            send "{@colour1}Homes of {@colour3}%player%"
            loop {home::%player's uuid%::*}:
                send "{@colour2}%loop-index%"
        else if player has permission "skript.homes.others":
            send "{@colour1}Homes of {@colour3}%arg-1%"
            loop {home::%arg-1's uuid%::*}:
                send "{@colour2}%loop-index%"

command /tp <text> [to] [<text>] [<text>]:
    description: Teleports you to a player.
    usage: /tp <target player>.
    permission: skript.tp
    trigger:
        if arg-2 is not set:
            if arg-1 parsed as a player is set:
                teleport player to (arg-1 parsed as a player)'s location
                message "{@colour1}Teleported to {@colour2}%arg-1%"
            else if arg-1 parsed as a offline player is set:
                send "&cUse /otp <player> to teleport to an offline player!"
        else:
            if arg-2 parsed as a player is set:
                teleport (arg-1 parsed as a player) to (arg-2 parsed as a player)'s location
                send "{@colour1}Teleported {@colour2}%arg-1% {@colour1}to {@colour3}%arg-2%" to player
                send "{@colour1}You have been teleported to {@colour2}%arg-2% {@colour1}by {@colour3}%player%" to arg-1 parsed as a player
            else if arg-3 is set:
                execute console command "/minecraft:teleport %player% %arg-1% %arg-2% %arg-3%"
                send "{@colour1}You have teleported to {@colour2}%arg-1%, {@colour2}%arg-2%, {@colour2}%arg-3%"
        send "{@colour3}%player%{@colour1} has done a command! {@colour2}/teleport %arg-1%{@colour2} %arg-2%{@colour2} %arg-3%" to all players where [input has permission "notify.teleport"] if {@notify} is true

command /teleport <text> [to] [<text>] [<text>]:
    description: Teleports you to a player.
    usage: /tp <target player>.
    permission: skript.tp
    trigger:
        arg-2 is not set:
            arg-1 parsed as a player is set:
                teleport player to (arg-1 parsed as a player)'s location
                message "{@colour1}Teleported to {@colour2}%arg-1%"
            else if arg-1 parsed as a offline player is set:
                send "&cUse /otp <player> to teleport to an offline player!"
        else:
            arg-2 parsed as a player is set:
                teleport (arg-1 parsed as a player) to (arg-2 parsed as a player)'s location
                send "{@colour1}Teleported {@colour2}%arg-1% {@colour1}to {@colour3}%arg-2%" to player
                send "{@colour1}You have been teleported to {@colour2}%arg-2% {@colour1}by {@colour3}%player%" to arg-1 parsed as a player
            else if arg-3 is set:
                execute console command "/minecraft:teleport %player% %arg-1% %arg-2% %arg-3%"
                send "{@colour1}You have teleported to {@colour2}%arg-1%, {@colour2}%arg-2%, {@colour2}%arg-3%"
        send "{@colour3}%player%{@colour1} has done a command! {@colour2}/teleport %arg-1%{@colour2} %arg-2%{@colour2} %arg-3%" to all players where [input has permission "notify.teleport"] if {@notify} is true
            
command /tphere <player>:
    description: Teleport a player to you
    usage: /tphere <target player>
    permission: skript.tphere
    trigger:
        message "{@colour1}Teleported {@colour2}%argument% {@colour1}to you"
        teleport argument to player's location
        send "{@colour3}%player%{@colour1} has done a command! {@colour2}/teleporthere %arg-1%" to all players where [input has permission "notify.teleport"] if {@notify} is true

command /teleporthere <player>:
    description: Teleport a player to you
    usage: /tphere <target player>
    permission: skript.tphere
    trigger:
        message "{@colour1}Teleported {@colour2}%argument% {@colour1}to you"
        teleport argument to player's location
        send "{@colour3}%player%{@colour1} has done a command! {@colour2}/teleporthere %arg-1%" to all players where [input has permission "notify.teleport"] if {@notify} is true

command /tpa <player>:
    permission: skript.tpa
    description: Teleport to an player
    trigger:    
        set {skript::tpa::%argument 1%} to "%player%|%now%"
        send "{@colour2}%player% {@colour1}wants teleport to you. &7Use /tpaccept to accept" to argument 1
        message "{@colour1}Teleport request sent."
        send "{@colour3}%player%{@colour1} has done a command! {@colour2}/tpa %arg-1%" to all players where [input has permission "notify.teleportrequest"] if {@notify} is true

command /tpahere <player>:
    permission: skript.tpahere
    description: Teleport an player to you
    trigger:
        set {skript::tpahere::%argument 1%} to "%player%|%now%"
        send "{@colour2}%player% {@colour1}wants you to teleport to them." to argument 1
        message "{@colour2}Teleport request sent."
        send "{@colour3}%player%{@colour1} has done a command! {@colour2}/tpahere %arg-1%" to all players where [input has permission "notify.teleportrequest"] if {@notify} is true

command /tpaccept:
    permission: skript.tpaccept
    trigger:
        if {skript::tpa::%player%} is set:
            set {_d::*} to split {skript::tpa::%player%} at "|"
            if {_d::2} was less than 30 seconds ago:
                teleport {skript::tpa::%player%} to location of player
                send "{@colour1}You were teleported to %player%!" to {skript::tpa::%player%} 
                send "{@colour1}%{skript::tpa::%player%}%{@colour1} was teleported to you!" to player
            else:
                send "{@colour1}Your last teleport request was sent more than 30 seconds ago."
        else if {skript::tpahere::%player%} is set:
            set {_d::*} to split {skript::tpahere::%player%} at "|"
            if {_d::2} was less than 30 seconds ago:
                teleport player to location of {skript::tpahere::%player%}
                send "{@colour1}You were teleported to %player%" to player
                send "{@colour1}%{skript.tpahere.%player%}% {@colour2}was teleported to you" to {skript::tpahere::%player%} 
            else:
                send "{@colour1}Your last teleport request was sent more than 30 seconds ago."
        else:
            message "&cThere aren't any teleport requests"

command /broadcast [<string>]:
    permission: bc.use
    permission message: {@server} &8| &7Insufficient Permissions!
    trigger:
        if arg-1 is not set:
            send "{@server} &8| &7Please write something!"
        if arg-1 is set:
            broadcast "{@server} &8| {@colour2}%coloured arg-1%"

command /bc [<string>]:
    permission: bc.use
    trigger:
        if arg-1 is not set:
            send "{@server} &8| &7Please write something!"
        if arg-1 is set:
            broadcast "{@server} &8| {@colour2}%coloured arg-1%"

command /gamemode <text>:
    permission: gamemode.sk
    trigger:
        make player execute "/gm%arg-1%"
            
command /gmc:
    permission: gmc.sk
    trigger:
        set player's gamemode to creative
        send "{@colour1}Your gamemode is now set to {@colour2}creative!"

command /gms:
    permission: gms.sk
    trigger:
        set player's gamemode to survival
        send "{@colour1}Your gamemode is now set to {@colour2}survival!"

command /gmsp:
    permission: gmsp.sk
    trigger:
        set player's gamemode to spectator
        send "{@colour1}Your gamemode is now set to {@colour2}spectator!"

command /gma:
    permission: gma.sk
    trigger:
        set player's gamemode to adventure
        send "{@colour1}Your gamemode is now set to {@colour2}adventure!"

command /day:
    permission: sk.day
    trigger:
        set time to day
        send "{@colour1}Time set to {@colour2}day."

command /night:
    permission: sk.night
    trigger:
        set time to night
        send "{@colour1}Time set to {@colour2}night."

command /rain:
    permission: sk.rain
    trigger:
        set weather to rain
        send "{@colour1}Weather set to {@colour2}rain."

command /wclear:
    permission: sk.sun
    trigger:
        set weather to clear
        send "{@colour1}Weather set to {@colour2}sun."
        
command /sun:
    permission: sk.sun
    trigger:
        set weather to clear
        send "{@colour1}Weather set to {@colour2}sun."

command /suicide:
    permission: sk.suicide
    trigger:
        kill player

#Kill All Items

command /deldrops:
    trigger:
        kill all dropped items

every {@announcetime} minutes:
     broadcast ""
     broadcast "&c&lEDIT THIS IN THE SKRIPT CONFIG!"
     broadcast ""

command /motd:
     trigger:
          message " "
          message "&a&lEDIT MOTD IN THE SKRIPT CONFIG!"
          message " "

command /skull:
     trigger:
          give player player's head

command /clearchat:
    permission: cc.use
    aliases: cc
    trigger:
        loop all players:
            loop 10 times:
                broadcast "%loop-player%- Your anti-clearchat will not work on this."
        loop 300 times:
            broadcast ""
        broadcast "{@server} &8| {@colour2}%player% {@colour1}has cleared the chat!"

command /ssudo <player> <text>:
    permission: s.sudo
    trigger:
        if arg-1 is set:
            if arg-2 is set:
                make arg-1 say arg-2

command /allsudo <text>:
    permission: s.sudo
    trigger:
        if arg-1 is set:
            loop all players:
                make loop-player say arg-1

#
#        Essentials Kits (made by Austin collaborating with Lupusor)
#

#            Known Bug
#    when using the /createkit there is a bug ever so often where it sends "An internal error occurred"
#    it's an issue with timespam mainly just add/remove the (s) in the cooldown part (this issue can also be seen for [1 minute and 5 seconds]
#        EX:    /createkit example 1 minute
#        EX:    /createkit example 1 minutes
#
#    PERMISSIONS:
#        easykits.createkit
#        easykits.deletekit
#        easykits.kit.(kit)
#        easykits.createkit
#        easykits.createsigns
#
#    COMMANDS:
#        /previewkit (kit) | preview a kit on the server | no permission needed
#        /kit (kit) | select a kit you own | no permission needed
#        /kits | list all kits you own with an unlimited page gui | no permission needed
#        /deletekit (kit) | delete a kit you don't want from the server | easykits.deletekit
#        /createkit (kit) (timespan) | create a kit you for the server | easykits.createkit
#            EX: /createkit example 1 second
#            EX: /createkit example 0 seconds
#            EX: /createkit example 5 minutes and 5 seconds
#
#    SIGNS:
#        on any sign put [PREVIEW KIT] or [SELECT KIT] on line 1
#        and on line 2 put the kit you'd like to preview/select
#        these usages are great for people who own a kit pvp server



#
#            Functions (Do not edit without knowing how)
#

options:
    drop_when_full: true # true or false | yes or no


function previewKit(p: player, kit: text):
    {EasyKits::*} contains {_kit}
    set metadata value "gui" of {_p} to "kitpreview"
    set {_inv} to chest inventory with 5 rows named "Previewing Kit | %{_kit}%"
    loop {EasyKits::%{_kit}%::items::*}:
        set {_id} to (((loop-index) parsed as integer)-1)
        {_id} < 36
        set {_slot} to {_id}+27 if {_id} < 9 else {_id}-9
        set slot {_slot} of {_inv} to loop-value
    set slot (integers from 36 to 44) of {_inv} to black stained glass pane
    set slot 40 of {_inv} to paper named "&3Inventory View Information" with lore "&7Line 1", "&7Line 2", "&7Line 3" and "&bHot-Bar"
    open {_inv} to {_p}

function listKits(p: player, page: number):
    set metadata value "gui" of {_p} to "kitlist"
    set metadata value "guidata" of {_p} to {_page}
    set {_kits::*} to {EasyKits::*} where [{_p} has permission "easykits.kit.%input%"]
    set {_inv} to chest inventory with 6 rows named "Kits | Total: %size of {_kits::*}% | Page: %({_page})+1%"
    set {_startPoint} to {_page}*36
    set {_slot} to 9
    loop {_kits::*}:
        ((loop-index) parsed as integer) > {_startPoint}
        set slot {_slot} of {_inv} to paper named "&e%loop-value%" with lore "&7Cooldown: &f%{EasyKits::%loop-value%::cooldown}%" and "&7Permission: &fEasyKits.kit.%loop-value%", "" and "&7&l| &fRight Click to Preview"
        add 1 to {_slot}
        {_slot} = 45
        exit loop
    if (size of {_kits::*}) > (({_startPoint})+36):
        set slot 53 of {_inv} to arrow named "&eNext Page"
    if {_page} > 0:
        set slot 45 of {_inv} to arrow named "&ePrevious Page"
    open {_inv} to {_p}

function selectKit(p: player, kit: text):
    {EasyKits::*} contains {_kit}
    {_p} has permission "easykits.kit.%{_kit}%"
    set {_uuid} to uuid of {_p}
    set {_now} to now
    set {_lastUsed} to {KitData::%{_uuid}%::%{_kit}%} otherwise now
    set {_cooldown} to {EasyKits::%{_kit}%::cooldown}
    send "&cYou still need to wait &4%difference between {_lastUsed} and {_now}%" to {_p} where [{_now} < {_lastUsed}]
    {_now} >= {_lastUsed}
    set {KitData::%{_uuid}%} to {_uuid}
    set {KitData::%{_uuid}%::%{_kit}%} to {_cooldown} from now
    loop {EasyKits::%{_kit}%::items::*}:
        loop-value is not air
        add loop-value to {_p}'s inventory where [{_p} can hold loop-value]
        {@drop_when_full} is true or yes
        drop loop-value above {_p}'s location where [{_p} can't hold loop-value]
    send "&aYou've used the kit &2%{_kit}%" to {_p}


#
#        Message Options
#

options:
    usage: &c/createkit (name) (cooldown)
    noItems: &cYou don't have any items if your inventory
    inUse: &cThis kit name already exist
    lengthLimit: &cThere is a minimum of 3 characters and a maximum of 8 characters! 


#
#        Command Options
#

options:
    permission: easykits.createkit
    permission_message: {@server} &8&l| &cYou don't have the required permission node
    cooldown: 0 seconds # when set to 0 this will allow it to be spammed
    cooldown_message: {@server} &8&l| &cThis command is currently still on a %remaining time% cooldown
    cooldown_bypass: skript.admin

command /createkit [<text>] [<timespan>]:
    permission: {@permission}
    permission message: {@permission_message}
    cooldown: {@cooldown}
    cooldown message: {@cooldown_message}
    cooldown bypass: {@cooldown_bypass}
    executable by: players
    trigger:
        if arg 1 or arg 2 is not set:
            send "{@usage}"
            cancel cooldown
        else if (amount of items in player's inventory) = 0:
            send "{@noItems}"
            cancel cooldown
        else if {EasyKits::*} contains arg-1:
            send "{@inUse}"
            cancel cooldown
        else if length of arg-1 > 10:
            send "{@lengthLimit}"
            cancel cooldown
        else if length of arg-1 < 3:
            send "{@lengthLimit}"
            cancel cooldown
        else:
            set {EasyKits::%arg-1%} to arg-1
            set {EasyKits::%arg-1%::cooldown} to arg-2
            loop 36 times:
                set {EasyKits::%arg-1%::items::%loop-value%} to slot ((loop-value)-1) of player's inventory
            send "&cYou've created the new kit &4%arg-1% &cwith a cooldown of &4%arg-2%"

command /previewkit [<text>]:
    executable by: players
    trigger:
        send "&cYou need to define a kit" to player where [arg-1 is not set]
        arg-1 is set
        send "&4%arg-1% &cdoesn't seem to be a kit" to player where [{EasyKits::*} doesn't contain arg-1]
        {EasyKits::*} contains arg-1
        previewKit(player, arg-1)

command /kit [<text>]:
    executable by: players
    trigger:
        send "&cYou need to define a kit" to player where [arg-1 is not set]
        arg-1 is set
        send "&4%arg-1% &cdoesn't seem to be a kit" to player where [{EasyKits::*} doesn't contain arg-1]
        {EasyKits::*} contains arg-1
        send "&cYou don't have the required permission node" to player where [player doesn't have permission "easykits.kit.%arg-1%"]
        player has permission "easykits.kit.%arg-1%"
        selectKit(player, arg-1)

command /kits [<text>]:
    executable by: players
    trigger:
        listKits(player, 0)

options:
    permission: easykits.deletekit
    permission_message: &8&l| &cYou don't have the required permission node
    cooldown: 0 seconds # when set to 0 this will allow it to be spammed
    cooldown_message: &8&l| &cThis command is currently still on a %remaining time% cooldown
    cooldown_bypass: skript.admin

command /deletekit [<text>]:
    permission: {@permission}
    permission message: {@permission_message}
    cooldown: {@cooldown}
    cooldown message: {@cooldown_message}
    cooldown bypass: {@cooldown_bypass}
    executable by: players
    trigger:
        if {EasyKits::*} doesn't contain arg-1:
            send "&cThere doesn't seem to be any kit by that name"
        else:
            delete {EasyKits::%arg-1%::items::*}
            delete {EasyKits::%arg-1%::*}
            delete {EasyKits::%arg-1%}
            send "&cYou've deleted the kit &4%arg-1%"

#
#        Inventory Management
#

on inventory close:
    if metadata value "gui" of player is set:
        clear metadata "gui" of player
    if metadata value "guidata" of player is set:
        clear metadata "guidata" of player

on quit:
    if metadata value "gui" of player is set:
        clear metadata "gui" of player
    if metadata value "guidata" of player is set:
        clear metadata "guidata" of player

on inventory click:
    if metadata value "gui" of player is "kitpreview":
        cancel event
    else if metadata value "gui" of player is "kitlist":
        cancel event
        set {_page} to "%metadata value ""guidata"" of player%" parsed as number
        if event-item is a paper:
            click type is right mouse button or right mouse button with shift
            close player's inventory
            previewKit(player, uncolored name of event-item)
        else if event-item is a arrow named "&eNext Page":
            close player's inventory
            listKits(player, {_page}+1)
        else if event-item is a arrow named "&ePrevious Page":
            close player's inventory
            listKits(player, {_page}-1)

#
#        Sign Stuff
#


on sign edit:
    player has permission "easykits.createsigns"
    if uncolored line 1 is "[PREVIEW KIT]":
        if line 2 is empty:
            set line 1 to "&c[PREVIEW KIT]"
            set line 2 to "&4(kit name)"
        else if {EasyKits::*} doesn't contain uncolored line 2:
            set line 1 to "&c[PREVIEW KIT]"
            set line 2 to "&4(kit name)"
        else:
            set line 1 to "&1[PREVIEW KIT]"
            set line 2 to uncolored line 2
    else if uncolored line 1 is "[SELECT KIT]":
        if line 2 is empty:
            set line 1 to "&c[SELECT KIT]"
            set line 2 to "&4(kit name)"
        else if {EasyKits::*} doesn't contain uncolored line 2:
            set line 1 to "&c[SELECT KIT]"
            set line 2 to "&4(kit name)"
        else:
            set line 1 to "&1[SELECT KIT]"
            set line 2 to uncolored line 2

on right click on any sign:
    if colored line 1 of event-block is "&1[PREVIEW KIT]":
        previewKit(player, uncolored line 2 of event-block)
    else if colored line 1 of event-block is "&1[SELECT KIT]":
        selectKit(player, uncolored line 2 of event-block)

command /give <item types> <integer = 1> [to] [<player>]:
    permission: skript.give
    trigger:
        send "{@colour1}Giving %arg-2% {@colour2}%argument 1% {@colour1}to {@colour3}%argument 3 ? player%" to player
        give arg-2 of arg-1 to player-argument if arg-3 is set
        give arg-2 of arg-1 to player if arg-3 is not set
        send "{@colour1}You have recieved some {@colour2}%arg-1% {@colour1}from {@colour3}%player%" to argument 3

```

```
# AUTHOR: 3meraldK, 3meraldK#3099
# VERSION: v1.0
# ADDONS: none

options:
	prefix: &e&l[&a&lFRIENDS&e&l]				# Prefix which shows in /friends and /friends info
	permission: friends.use					# Permission needed to use /friends command
	permsg: &cError: &7Insufficient permissions. 	# You got this message when you have no permission to use /friends    
	
variables:
	{friends::%player%::toggle} = true

command /friends [<text>] [<offlineplayer>]:
	aliases: f
	permission: {@permission}
	permission message: {@permsg}
	trigger:
		if arg 1 isn't set:
			send "&8&l|------- {@prefix} &8&l-------|" and ""
			send "&8> &e/friends &7- shows this list"
			send "&8> &e/friends add &a<nick> &7- adds a new friend"
			send "&8> &e/friends accept/deny &a<nick> &7- accepts/denies an invitation"
			send "&8> &e/friends remove &a<nick> &7- removes a friend"
			send "&8> &e/friends list &7- shows a list of your friends"
			send "&8> &e/friends toggle &7- toggles invitations"
			send "&8> &e/friends info &7- script information"
			send "" and "&8&l|------- {@prefix} &8&l-------|"
		if arg 1 is "add":
			if arg 2 is set:
				if arg 2 isn't "%player%":
					loop all players:
						if "%loop-player%" is arg 2:
							if {friends::%player%::toggle} is true:
								if {friends::%player%::invitation::%loop-player%} isn't set:
									set {friends::%player%::invitation::%loop-player%} to false
									if {friends::%player%::invitation::%loop-player%} is false:
										set {friends::%player%::invitation::%loop-player%} to true
										send "&aYour invitation has been sent!"
										send "&7You just got an invitation to become a friend of &a%player%" and "&7Enter &c/f accept/deny %player% &7to process!" to loop-player
										
										wait 5 minutes
										if {friends::%player%::invitation::%loop-player%} is set:
											send "&7You didn't reply in 5 minutes, so an invitation from %player% has been canceled." to loop-player
											send "&7Player &a%loop-player% &7you invited didn't reply in 5 minutes, so your invite has been canceled."
										delete {friends::%player%::invitation::%loop-player%}
									else:
										send "&cError: &7You already sent an invitation to that player."
							else:
								send "&cError: &7This player toggled off invitations!"
						else:
							send "&cError: &7That player doesn't exist."
				else:
					send "&cError: &7You can't add yourself to a friend list."
			else:
				send "&cError: &7Specify the name of a player."
		if arg 1 is "accept":
			if arg 2 is set:
				if {friends::%arg-2%::invitation::%player%} is true:
					add "%arg-2%" to {friends::%player%::friends::*}
					add "%player%" to {friends::%arg-2%::friends::*}
					send "&a%arg-2% &7has became your new friend."
					send "&a%player% &7has became your new friend." to arg-2
					delete {friends::%arg-2%::invitation::%player%}
				else:
					send "&cError: &7You didn't get an invitation from that player."
			else:
				send "&cError: &7Specify the name of a requester."
		if arg 1 is "deny":
			if arg 2 is set:
				if {friends::%arg-2%::invitation::%player%} is true:
					send "&cSuccessfully denied that invitation!"
					send "&7Player &a%player% &7you sent an invitation has denied your request." to arg-2
					delete {friends::%arg-2%::invitation::%player%}
				else:
					send "&cError: &7You didn't get an invitation from that player."
			else:
				send "&cError: &7Specify the name of a requester."
		if arg 1 is "remove":
			if arg 2 is set:
				if {friends::%player%::friends::*} contains "%arg-2%":
					remove "%arg-2%" from {friends::%player%::friends::*}
					remove "%player%" from {friends::%arg-2%::friends::*}
					send "&7Successfully deleted &a%arg-2% from your friends list."
					send "&7Player &a%player% has removed you from his friends list."
				else:
					send "&cError: &7Your friend called &a%arg-2% &7doesn't exist."
			else:
				send "&cError: &7Specify your friend's username."
		if arg 1 is "list":
			if {friends::%player%::friends::*} is set:
				set {_msg} to "%{friends::%player%::friends::*}%"
				set {_flist::*} to {_msg} split at ", " and " and "
				send "&8&l|------- {@prefix} &8&l-------|" and ""
				loop (size of {_flist::*}) times:
					if "%{_flist::%loop-value%}%" parsed as player is online:
						send "&e%{_flist::%loop-value%}% &a[ONLINE]"
					else:
						send "&e%{_flist::%loop-value%}% &c[OFFLINE]"
				send "" and "&8&l|------- {@prefix} &8&l-------|"
			else:
				send "&cError: &7You don't have any friends."
		if arg 1 is "toggle":
			if {friends::%player%::toggle} is true:
				set {friends::%player%::toggle} to false
				send "&7Successfully toggled this option to &cfalse"
			else:
				set {friends::%player%::toggle} to true
				send "&7Successfully toggled this option to &atrue"
		if arg 1 is "info":
			send "&8&l|------- {@prefix} &8&l-------|" and ""
			send "&8> &e&lAUTHOR: &e3meraldK, 3meraldK##3099"
			send "&8> &6&lVERSION: &6v1.0"
			send "" and "&8&l|------- {@prefix} &8&l-------|"
		else:
			send "&cError: &7Use &b/friends &7command to process"

```

```
#
# Gamemode - made by WolfyGameYT
#


options:
     prefix: &3&lGamemode &b&l»
     pm: &3&lGamemode &b&l» &4You can't do that!

command /gmc [<player>]:
	aliases: creative
	permission: gamemode.creative
	permission message: {@pm}
	trigger:
		if argument 1 is not set:
			set player's gamemode to creative
			message "{@prefix} &7Set gamemode to &8creative" to sender
		else:
			argument 1 is online
			if sender has permission "gamemode.creative.others":
				set argument 1's gamemode to creative
				message "{@prefix} &7Set &8%arg-1%'s &7gamemode to &8creative" to sender
			else:
				message "{@pm}" to sender

command /gms [<player>]:
	aliases: survival
	permission: gamemode.survival
	permission message: {@pm}
	trigger:
		if argument 1 is not set:
			set player's gamemode to survival
			message "{@prefix} &7Set gamemode to &8survival" to sender
		else:
			argument 1 is online
			if sender has permission "gamemode.survival.others":
				set argument 1's gamemode to survival
				message "{@prefix} &7Set &8%arg-1%'s &7gamemode to &8survival" to sender
			else:
				message "{@pm}" to sender

command /gma [<player>]:
	aliases: adventure
	permission: gamemode.adventure
	permission message: {@pm}
	trigger:
		if argument 1 is not set:
			set player's gamemode to adventure
			message "{@prefix} &7Set gamemode to &8adventure" to sender
		else:
			argument 1 is online
			if sender has permission "gamemode.adventure.others":
				set argument 1's gamemode to adventure
				message "{@prefix} &7Set &8%arg-1%'s &7gamemode to &8adventure" to sender
			else:
				message "{@pm}" to sender

command /gmsp [<player>]:
	aliases: spectator
	permission: gamemode.spectator
	permission message: {@pm}
	trigger:
		if argument 1 is not set:
			set player's gamemode to spectator
			message "{@prefix} &7Set gamemode to &8spectator" to sender
		else:
			argument 1 is online
			if sender has permission "gamemode.spectator.others":
				set argument 1's gamemode to spectator
				message "{@prefix} &7Set &8%arg-1%'s &7gamemode to &8spectator" to sender
			else:
				message "{@pm}" to sender
				
command /gamemode:
	permission: help.gamemode
	permission message: {@pm}
	trigger:
		send ""
		send "                  &1&l-------------------"
		send "                    &b&lGAMEMODE COMMANDS"
		send "&1&l-----------------------------------------"
		send "&3/gmc or /creative: &9Sets player's gamemode to creative"
		send "&3/gmc or /survival: &9Sets player's gamemode to survival"
		send "&3/gma or /adventure: &9Sets player's gamemode to adventure"
		send "&3/gmsp or /spectator: &9Sets player's gamemode to spectator"
		send ""
		send "&3&lINFO: &9&lAdd a player's name after the command to set someone else's gamemode"
		send "&1&l-----------------------------------------"
		send ""

```

```
#
#
# Report any issues to @Adxm#1343
#
#

on script load:
  console command "gamerule keepInventory true"

on death:
  victim is player
  send "&c&lDEATH &7| You can retreive your items at location &3%vicitm's location%&7!"
  set block at victim's location to chest
  loop all items in victim's inventory:
    add loop-item to inventory of block at victim's location
  clear victim's inventory

```

```
#Hearts skripted by: SH4D03


options:
	hearts: 10 #This is the number of hearts displayed
	color1: &4 #This is the color of the victim's current hearts
	color2: &7 #This is the color of the victim's used hearts
	color3: &c #This is the color used to display a half heart
	symbol: ❤ #This is the symbol used to display a heart























on damage:
	wait 5 ticks
	set {_health} to victim's health
	set {_max} to victim's max health
	set {_hearts} to ({_health} / {_max}) * {@hearts}
	set {_hearts-1} to "%{_hearts}%"
	set {_hearts-count} to  rounded down {_hearts}
	set {_hearts-display} to ""
	loop {_hearts-count} times:
		set {_hearts-display} to "%{_hearts-display}%{@color1}{@symbol}"
	if {_hearts-1} contains ".":
		set {_hearts-display} to "%{_hearts-display}%{@color3}{@symbol}"
		add 1 to {_hearts-count}
	set {_rest} to {@hearts} - {_hearts-count}
	loop {_rest} times:
		set {_hearts-display} to "%{_hearts-display}%{@color2}{@symbol}"
	send action bar "{@color1}%{_hearts-display}%" to attacker

```

```
options:
  P: &c&lITEMGUI&7
 
command /edit:
  trigger:
    if player's held item is not air:
      set {inv::%player's uuid%} to chest inventory with 3 rows named "{@P}&3 Item Editor"
      set slot 4 of {inv::%player's uuid%} to emerald named "&c&lINFO" with lore "&7TYPE:&3 %tool%" and "&7NAME: &3%name of player's tool%" and "&7LORE: &3%lore of player's tool%"
      set slot 11 of {inv::%player's uuid%} to glowstone dust named "&c&lRENAME" with lore "&7&oSelect this to rename your item."
      set slot 15 of {inv::%player's uuid%} to name tag named "&c&lEDIT LORE" with lore "&7&oSelect this to edit the lore your item."
      open {inv::%player's uuid%} to player
    else:
      send "{@P} Hold something to edit it!"
 
on inventory click:
  if player's current inventory = {inv::%player's uuid%}:
    close player's inventory
    cancel event
    if clicked slot is 11:
      set {itemgui::rename-event::%player's uuid%} to true
      send ""
      send "{@P}"
      send "&7> Please type in chat the &3&nnew name&7 for your item."
      send ""
    if clicked slot is 15:
      set {itemgui::editlore-event::%player's uuid%} to true
      send ""
      send "{@P}"
      send "&7> Please type in chat the &3&nlore number&7 for your item [1, 2, 3, 4 or 5]."
      send ""

on inventory close:
	delete {inv::%player's uuid%}

on chat:
  if {itemgui::rename-event::%player's uuid%} is set:
    cancel event
    delete {itemgui::rename-event::%player's uuid%}
    set name of player's held item to "&f%coloured message%"
    send "{@P} Your item's name has been set to &3""%coloured message%""&7!"
  else if {itemgui::editlore-event::%player's uuid%} is true:
    set {_m} to message parsed as number
    if {_m} is 1 or 2 or 3 or 4 or 5:
      cancel event
      set {itemgui::editlore-lore::%player's uuid%} to message parsed as integer
      set {itemgui::editlore2-event::%player's uuid%} to true
      send ""
      send "{@P}"
      send "&7> Please type in chat the &3&nlore text&7 for your item."
      send ""
      delete {itemgui::editlore-event::%player's uuid%}
    else:
      send "{@P} Invalid number."
      delete {itemgui::editlore-event::%player's uuid%}
  else if {itemgui::editlore2-event::%player's uuid%} is set:
    cancel event
    set line {itemgui::editlore-lore::%player's uuid%} of player's held item's lore to "&f%coloured message%"
    send "{@P} Your item's lore has been set to &3""%coloured message%""&7!"
    delete {itemgui::editlore2-event::%player's uuid%}
    delete {itemgui::editlore-lore::%player's uuid%}

```

```
#LiteVanish by block of grass.
command /vanish:
  permission: skript.vanish
  permission message: &7[&aLitevanish&7] &fYou do not have permission to do this!
  aliases: /v
  trigger:
    if {var} is false:
#change these groups to ones you have or remove groups u dont have
      hide player from all players where [input's group = "default"]
      hide player from all players where [input's group = "vip"]
      hide player from all players where [input's group = "vip+"]
      hide player from all players where [input's group = "Group_name"]
      hide player from all players where [input's group = "Group_name"]
      send "&7[&aLitevanish&7] &fYou are now vanished!" to player
      set {var} to true
    else if {var} is not set:
#change these groups to ones you have or remove groups u dont have
      hide player from all players where [input's group = "default"]
      hide player from all players where [input's group = "vip"]
      hide player from all players where [input's group = "vip+"]
      hide player from all players where [input's group = "Group_name"]
      hide player from all players where [input's group = "Group_name"]
      send "&7[&aLitevanish&7] &fYou are now vanished!" to player
      set {var} to true
    else if {var} is true:
      reveal player from all players
      execute console command "effect clear %player%"
      send "&7[&aLitevanish&7] &fYou are no longer vanished!" to player
      set {var} to false

on player join:
  if {var} is true:
#change these groups to ones you have or remove groups u dont have
    hide player from all players where [input's group = "default"]
    hide player from all players where [input's group = "vip"]
    hide player from all players where [input's group = "vip+"]
    hide player from all players where [input's group = "Group_name"]
    hide player from all players where [input's group = "Group_name"]

```

```
#Lootbox skripted by: SH4D03

#Donations: paypal.me/SH4D03

options:
	item: sea lantern #This is the item of the lootbox
	name: &b&lLoot Box #This is the name of the lootbox
	animation: true #Whether placing a lootbox should play an animation or not
	sound: true #Whether placing a lootbox should play a sound or not
	lore: &7Place for Rewards! #The lore of the lootbox

















on place of {@item}:
	if name of player's tool is "{@name}":
		if {@animation} is true:
			wait 2 ticks
			set block to red stained glass
			wait 2 ticks
			set block to orange stained glass
			wait 2 ticks
			set block to yellow stained glass
			wait 2 ticks
			set block to lime stained glass
			wait 2 ticks
			set block to blue stained glass
			wait 2 ticks
			set block to purple stained glass
			wait 2 ticks
			set block to black stained glass
			wait 2 ticks
			if {@sound} is true:
				play sound "entity.experience_orb.pickup" with volume 5 and pitch 16 at player 
		else if {@sound} is true:
			play sound "entity.experience_orb.pickup" with volume 5 and pitch 16 at player 
		set block to air
		set {_loot} to a random element out of {lootbox::*}
		give player {_loot}
		send action bar "&3&lYou Won:&b %{_loot}%" to player
			

command /lootbox [<text>] [<number=1>] [<player=%player%>]:
	permission: op
	trigger:
		if arg-1 is "give":
			give arg-2 of {@item} named "{@name}" with lore "{@lore}" to arg-3
		else if arg-1 is "add":
			if player's tool is not air:
				add player's tool to {lootbox::*}
				send "&3&lLootbox &6» &bItem successfully added!" to player
			else:
				send "&3&lLootbox &6» &bYou can't add air!" to player
		else if arg-1 is "remove":
			if {lootbox::*} contains player's tool:
				remove player's tool from {lootbox::*}
				send "&3&lLootbox &6» &bItem successfully added!" to player
			else:
				send "&3&lLootbox &6» &bYour item was not found in the lootbox!" to player
		else if arg-1 is "list":
			send "&3&lLootbox List:" to player
			loop {lootbox::*}:
				send "&9[%loop-index%] &b%loop-value%" to player
		else:
			send "&3&lUsage:" to player
			send " &b/lootbox give [<amount>] [<player>]" to player
			send " &b/lootbox add (Must be holding item)" to player
			send " &b/lootbox remove (Must be holding item)" to player
			send " &b/lootbox list" to player

```

```
options:
	prefix: &8[&eNUMBERS&8]

every 30 seconds:
	num()

function num(n: number = 0):
	set {_1} to random integer between 1 and 10 # Change these numbers to make the questions harder.
	set {_2} to random integer between 1 and 20 # Change "Integer" to "Number" if you want to allow decimals.
	set {_x} to random integer between 1 and 3
	set {pay} to random integer between 1 and 10 # Change these numbers to increase or decrease the amount you get for answering the question correctly.
	{_x} is 1:
		broadcast "{@prefix} &7Work out: &e%{_1}%x%{_2}% &7for &e%{pay}% Dollars!"
		set {num} to 1
		set {answer} to {_1}*{_2}
		wait 10 seconds
		delete {num}
	{_x} is 2:
		broadcast "{@prefix} &7Work out: &e%{_1}%+%{_2}% &7for &e%{pay}% Dollars!"
		set {num} to 1
		set {answer} to {_1}+{_2}
		wait 10 seconds
		delete {num}
	{_x} is 3:
		broadcast "{@prefix} &7Work out: &e%{_1}%÷%{_2}% &7for &e%{pay}% Dollars!"
		set {num} to 1
		set {answer} to {_1}/{_2}
		wait 10 seconds
		delete {num}

on chat:
	{num} is set:
		if message contains "%{answer}%":
			cancel event
			broadcast "{@prefix} &e%player's display name%&7 was correct! &8(&6%{answer}%&8)"
			delete {answer}
			add {pay} to player's balance

```

```
#
#
# Script developed by @Adxm#1343
# Released on SpigotMC.org
#
#

options:

  version: 2.1
  P: &8[&3Mines&8]&7

#
# MAIN COMMANDS
#


command /mines [<text>] [<text>]:
  aliases: m, mine
  permission: mines.use
  permission message: "{@P} No permission."
  trigger:
    if arg-1 is not set:
      send ""
      send "{@P} Help Commands"
      send "&c> &3/m info"
      send ""
      send "&c> &3/m list"
      send "&c> &3/m wand"
      send "&c> &3/m create [mine-name]"
      send "&c> &3/m edit [mine-name]"
      send "&c> &3/m reset [mine-name]"
      send "&c> &3/m clear [mine-name]"
      send "&c> &3/m lobby [mine-name]"
      send ""
    else if arg-1 is "info":
      send ""
      send "{@P} This script was created by skAdam (@Adxm##1343)."
      send ""
      send "&c> &7Version: &3{@version}"
      send ""
    else if arg-1 is "list":
      set {_G} to chest inventory with 5 rows named "{@P} &8List"
      set {_S} to 0
      loop {mine::list::*}:
        set slot {_S} of {_G} to name tag named "&3%loop-value%" with lore "&7Click to enter &3%loop-value%&7's properties gui." and "" and "&7Blocks: &3%{mine::%loop-value%::blocks::*}%" and "&7Reset Delay: &3%{mine::%loop-value%::resetdelay}%" and "&7Announce on Reset: &3%{mine::%loop-value%::broadcastOnReset}%"
        add 1 to {_S}
      open {_G} to player
      set metadata "mines-gui" of player to "list"
    else if arg-1 is "create":
      if arg-2 is set:
        if (amount of {mine::list::*}) < 40: # changing this will BREAK the code.
          if {mine::setup::location-1} and {mine::setup::location-2} is set: 
            if {mine::list::*} does not contain arg-2:
              add arg-2 to {mine::list::*}
              set {mine::%arg-2%::loc-1} to {mine::setup::location-1}
              set {mine::%arg-2%::loc-2} to {mine::setup::location-2}
              set {mine::%arg-2%::setblockdelay} to 0
              set {mine::%arg-2%::setblockdelay-display} to "None"
              set {mine::%arg-2%::resetdelay} to 1
              set {mine::%arg-2%::broadcastOnReset} to true
              set {mine::%arg-2%::blocks::*} to "stone"
              console command "mines reset %arg-2%"
              send ""
              send "{@P} Mine &3%arg-2%&7 created."
              send "&c> &7The default block has been set to &3stone&7, to edit this and other properties, use &3/mines edit %arg-2%&7."
              send ""
            else:
              send "{@P} This mine is already set."
          else:
            send "{@P} Mine location[s] are not set. Set them using the &3/mines wand&7."
        else:
          send "{@P} You have too many mines, please delete some. (This can be done easily with &3/mines list&7)"
      else:
        send "{@P} Enter a mine name."
    else if arg-1 is "edit":
      if arg-2 is set:
        if {mine::%arg-2%::loc-1} is set:
          if metadata "mines-inProcess" of player is not true:
            set {_G} to chest inventory with 5 rows named "{@P} &3%arg-2%&8's properties."
            set slot 4 of {_G} to barrier named "&c&lDelete Mine" with lore "&7&oDelete the mine."
            set slot 10 of {_G} to diamond ore named "&c&lBlock List" with lore "&7&oChange mine's blocks."
            set slot 12 of {_G} to oak sign named "&c&lAnnouncement" with lore "&7&oToggle announce on reset." and "&7Current Value: &3%{mine::%arg-2%::broadcastOnReset}%"
            set slot 14 of {_G} to ender pearl named "&c&lLobby" with lore "&7&oSet mine's lobby location."
            set slot 16 of {_G} to oak button named "&c&lReset" with lore "&7&oReset the mine."  
            set slot 28 of {_G} to painting named "&c&lHologram" with lore "&7&oSet the mine's hologram to your current location." 
            set slot 30 of {_G} to clock named "&c&lReset Delay" with lore "&7&oToggle how often the mine resets. [1, 5, 10 minutes]"   and "&7Current Value: &3%{mine::%arg-2%::resetdelay}%"
            set slot 32 of {_G} to clock named "&c&lBlock Set Delay" with lore "&7&oToggle the delay when setting blocks." and "&7&o[None = Instant, 1 = 1 tick per block]" and "&7Current Value: &3%{mine::%arg-2%::setblockdelay-display}%"
            set slot 34 of {_G} to ice named "&c&lClear" with lore "&7&oClear the mine." 
            open {_G} to player
            set metadata "mines-gui" of player to "properties"
            set metadata "mines-mine" of player to arg-2
          else:
            send "{@P} Unable to enter the edit gui, are you in the process of another setup?"
            send "&c> &7If this is a mistake, leave and rejoin."
        else:
          send "{@P} This mine is not set. 1 Create it by using &3/mines create %arg-2%&7."
      else:
        send "{@P} Enter a mine name."
    else if arg-1 is "lobby":
      if arg-2 is set:
        if {mine::%arg-2%::loc-1} is set:
          if {mine::%arg-2%::lobby} is set:
            if player has permission "mines.lobby.%arg-2%":
              teleport player to {mine::%arg-2%::lobby}
              send "{@P} Going to &3%arg-2%&7's lobby."
            else:
              send "{@P} Invalid permissions!"
          else:
            send "{@P} The mine &3%arg-2%&7 does not have a lobby set. One can be set using &3/mines edit %arg-2%&7."
        else:
          send "{@P} This mine is not set. Create it by using &3/mines create %arg-2%&7."
      else:
        send "{@P} Enter a mine name."
    else if arg-1 is "reset":
      if arg-2 is set:
        if {mine::%arg-2%::loc-1} is set:
          if {mine::%arg-2%::broadcastOnReset} is true:
            broadcast ""  
            broadcast "{@P} Mine &3%arg-2%&7 has been reset!"
            broadcast ""
            set {_D} to {mine::%arg-2%::setblockdelay}
          if {mine::%arg-2%::lobby} is set:
            loop all players:
              if minesPlayerbetween(loop-player, {mine::%arg-2%::loc-1}, {mine::%arg-2%::loc-2}) is true:
                player command "mines lobby %arg-2%"
          loop all blocks within {mine::%arg-2%::loc-1} and {mine::%arg-2%::loc-2}:
            if {_D} = 1:
              wait 1 tick
            set {_block} to random element out of {mine::%arg-2%::blocks::*}
            set loop-block to {_block} parsed as material
        else:
          send "{@P} This mine is not set. Create it by using &3/mines create %arg-2%&7."
      else:
        send "{@P} Enter a mine name."
    else if arg-1 is "clear":
      if arg-2 is set:
        if {mine::%arg-2%::loc-1} is set:
          if {mine::%arg-2%::broadcastOnReset} is true:
            broadcast ""  
            broadcast "{@P} Mine &3%arg-2%&7 has been cleared!"
            broadcast ""
            set {_D} to {mine::%arg-2%::setblockdelay}
          if {mine::%arg-2%::lobby} is set:
            loop all players:
              if minesPlayerbetween(loop-player, {mine::%arg-2%::loc-1}, {mine::%arg-2%::loc-2}) is true:
                player command "mines lobby %arg-2%"
          loop all blocks within {mine::%arg-2%::loc-1} and {mine::%arg-2%::loc-2}:
            if {_D} = 1:
              wait 1 tick
            set loop-block to air
        else:
          send "{@P} This mine is not set. Create it by using &3/mines create %arg-2%&7."
      else:
        send "{@P} Enter a mine name."
    else if arg-1 is "wand":
      give player stone axe named "{@P} &7Setup Wand"
      send ""
      send "{@P} You have been given your setup wand."
      send "&c> &3Gamemode creative is required!"
      send "&c> &7Right click to set location 1, and left click to set location 2."
      send ""


on inventory click:
  if metadata "mines-gui" of player is "properties":
    clear metadata "mines-gui" of player
    cancel event
    if clicked slot is 4:
      set {_M} to metadata "mines-mine" of player
      delete {mine::%{_M}%::*}
      remove {_M} from {mine::list::*}
      close player's inventory
      send ""
      send "{@P} Mine &3%{_M}%&7 has been deleted."
      send ""
      clear metadata "mines-gui" of player
      clear metadata "mines-mine" of player
    if clicked slot is 10:
      set {_M} to metadata "mines-mine" of player
      set {_G} to chest inventory with 5 rows named "{@P} &3%{_M}%&8's blocks."
      set slot 4 of {_G} to redstone block named "&c&lADD BLOCKS" with lore "&7&oThis will clear all the blocks and all blocks + the new ones will need to be added."
      set {_S} to 9
      loop {mine::%{_M}%::blocks::*}:
        set slot {_S} of {_G} to loop-value parsed as material named "&3%loop-value%"
        add 1 to {_S}
      open {_G} to player
      set metadata "mines-gui" of player to "blocks"
    if clicked slot is 12:
      set {_M} to metadata "mines-mine" of player
      if {mine::%{_M}%::broadcastOnReset} is true:
        delete {mine::%{_M}%::broadcastOnReset}
        send "{@P} Mine &3%{_M}%&7 will no longer announce on reset."
      else:
        set {mine::%{_M}%::broadcastOnReset} to true
        send "{@P} Mine &3%{_M}%&7 will now announce on reset."
      player command "mines edit %{_M}%"
    if clicked slot is 14:
      set {_M} to metadata "mines-mine" of player
      set {mine::%{_M}%::lobby} to player's location
      send "{@P} Lobby location of mine &3%{_M}%&7 has been set."
      send "&c> &7Players need the permission &3mines.lobby.%{_M}%&7 to warp to it."
    if clicked slot is 16:
      set {_M} to metadata "mines-mine" of player
      console command "mines reset %{_M}%"
    if clicked slot is 28:
      set {_M} to metadata "mines-mine" of player
      set {_L} to player's location
      add 2 to y-loc of {_L}
      send "{@P} Mine &3%{_M}%&7's hologram has been set to your location!"
      if {mine::%{_M}%::holo} is set:
        delete hologram {mine::%{_M}%::holo}
      create a new hologram with lines "{@P} &3Information" and "&7Mine: &3&l%{_M}%", "&7Reset Delay: &3every &l%{mine::%{_M}%::resetdelay}%&3 minutes" and "&7Blocks: &3&l%{mine::%{_M}%::blocks::*}%" at {_L} and store in {mine::%{_M}%::holo}
    if clicked slot is 30:
      set {_M} to metadata "mines-mine" of player
      if {mine::%{_M}%::resetdelay} is 1:
        set {mine::%{_M}%::resetdelay} to 5
        send "{@P} Reset delay for mine &3%{_M}%&7 has been set to 5 minutes."
      else if {mine::%{_M}%::resetdelay} is 5:
        set {mine::%{_M}%::resetdelay} to 10
        send "{@P} Reset delay for mine &3%{_M}%&7 has been set to 10 minutes."
      else if {mine::%{_M}%::resetdelay} is 10:
        set {mine::%{_M}%::resetdelay} to 1
        send "{@P} Reset delay for mine &3%{_M}%&7 has been set to 1 minutes."
      player command "mines edit %{_M}%"
    if clicked slot is 32:
      set {_M} to metadata "mines-mine" of player
      if {mine::%{_M}%::setblockdelay} is 0:
        set {mine::%{_M}%::setblockdelay} to 1
        set {mine::%{_M}%::setblockdelay-display} to 1
        send "{@P} Mine &3%{_M}%&7's set block on reset delay is now 1 tick."
      else if {mine::%{_M}%::setblockdelay} is 1:
        set {mine::%{_M}%::setblockdelay} to 0
        set {mine::%{_M}%::setblockdelay-display} to "None"
        send "{@P} Mine &3%{_M}%&7's set block on reset delay is now 0 ticks (none)."
      player command "mines edit %{_M}%"
    if clicked slot is 34:
      set {_M} to metadata "mines-mine" of player
      console command "mine clear %{_M}%"
  if metadata "mines-gui" of player is "blocks":
    cancel event
    if clicked slot is 4:
      close player's inventory
      set {_M} to metadata "mines-mine" of player
      set metadata "mines-inProcess" of player to true
      set metadata "mines-blockSetup" of player to true
      send ""
      send "{@P} Enter in chat what block types you want in mine &3%{_M}%&7."
      send "&c> &7Don't use spaces to seperate them, use "";"" (eg ""stone;grass block"")"
      send ""
  if metadata "mines-gui" of player is "list":
    cancel event
    set {_N} to clicked slot's name
    if {_N} is set:
      replace all "&3" with "" in {_N}
      player command "/mines edit %{_N}%"
    clear metadata "mines-gui" of player
    clear metadata "mines-properties" of player

every 1 minute:
  loop {mine::list::*}:
    if {mine::%loop-value%::resetdelay} is 1:
      console command "mines reset %loop-value%"
every 5 minutes:
  loop {mine::list::*}:
    if {mine::%loop-value%::resetdelay} is 5:
      console command "mines reset %loop-value%"
every 10 minutes:
  loop {mine::list::*}:
    if {mine::%loop-value%::resetdelay} is 10:
      console command "mines reset %loop-value%"
      
on chat:
  if metadata "mines-blockSetup" of player is true:
    cancel event
    set {_blocks} to message
    set {_S::*} to split {_blocks} at ";"
    if amount of {_S::*} < 35:
      clear metadata "mines-blockSetup" of player
      clear metadata "mines-inProcess" of player
      set {_M} to metadata "mines-mine" of player
      set {_blocks} to message
      set {mine::%{_M}%::blocks::*} to split {_blocks} at ";"
      console command "mines reset %{_M}%"
      send ""
      send "{@P} Mine &3%{_M}%&7's blocks have been set to &3%{mine::%{_M}%::blocks::*}%&7, and the mine has been reset."
      send ""
      clear metadata "mines-mine" of player
    else:
      send ""
      send "{@P} Error, there is a maximum of 35 blocks allowed in each mine."
      send ""

on join:
  clear metadata "mines-inProcess" of player
  clear metadata "mines-mine" of player
  clear metadata "mines-blockSetup" of player
  clear metadata "mines-gui" of player
#
# SETUPWAND: RIGHT CLICK
#

on right click with stone axe:
  if name of player's held item is "{@P} &7Setup Wand":
    if player has permission "mines.wand":
      cancel event
      set {mine::setup::location-1} to location of event-block
    send "{@P} Location 1 set to &3%{mine::setup::location-1}%"

#
# SETUPWAND: LEFT CLICK
#

on break:
  if held item is stone axe:
    if name of player's held item is "{@P} &7Setup Wand":
      if player has permission "mines.wand":
        cancel event
        set {mine::setup::location-2} to location of event-block
        send "{@P} Location 2 set to &3%{mine::setup::location-2}%"


#
#
#

function minesPlayerbetweenCheck(a: number, b: number, c: number) :: boolean:
    if {_a} is between {_b} and {_c}:
        return true
    else if {_a} is between {_c} and {_b}:
        return true

function minesPlayerbetween(p: player, l1: location, l2: location) :: boolean:
    if minesPlayerbetweenCheck(x coord of location of {_p}, x coord of {_l1}, x coord of {_l2}) = true:
        if minesPlayerbetweenCheck(y coord of location of {_p}, y coord of {_l1}, y coord of {_l2}) = true:
            if minesPlayerbetweenCheck(z coord of location of {_p}, z coord of {_l1}, z coord of {_l2}) = true:
                return true

```

```
options:
    p: skript.admin                                 # Permission required for the command
    pm: &cYou don't have access to that command.    # Message sent if player's permission is insufficient
    failed: &cPlayer is offline.                    # Message sent if arg-1 is offline


command /openinv [<offlineplayer>]:
    permission: {@p}
    permission message: {@pm}
    trigger:
        set {_p} to arg 1 ? player
        if {_p} is offline:
            send "{@failed}"
        else:
            open {_p}'s inventory for player

command /openender [<offlineplayer>]:
    permission: {@p}
    permission message: {@pm}
    trigger:
        set {_p} to arg 1 ? player
        if {_p} is offline:
            send "{@failed}"
        else:
            open ender chest of {_p} to player

```

```
on load:
  set {server::playerslots} to 250

command /playerslot <number>:
  permission: op
  aliases: slot, ps
  trigger:
    set {server::playerslots} to arg-1
    play sound "entity.player.levelup" to player
    message "&f "
    message "&3Set the current player slots to &b%{server::playerslots}%&3!"
    message "&f "

on join:
  if number of online players is more than {server::playerslots}:
    console command "/kick %player% This server is full!"

```

```
#PlayerTracker skripted by: SH4D03


options:
	name: &c&lPlayer Tracker 
	range: 50 
	color1: &3&l
	color2: &b

command /playertracker:
	permission: playertracker.give
	trigger:
		give player compass named "{@name}"

on join:
	wait 5 seconds
	while player is online:
		if player's tool is compass named "{@name}":
			loop players in radius {@range} around player:
				player is not loop-player
				if {_target} is not set:
					set {_target} to loop-player's location
					set {_target} to loop-player
				if distance between player and loop-player < distance between player and {_target}:
					set {_target} to loop-player
					set {_target} to distance between player and loop-player
			if {_target} isn't set:
				send action bar "{@color1}Nearest Player: {@color2}None" to player
				delete {current::%player's uuid%}
			else:
				set {current::%player's uuid%} to {_target}
				set {_dist} to (distance between player and {_target}) rounded to 1 decimal place
				set {_height} to (y-coord of {_target}) - (y-coord of player) rounded to 1 decimal place
				set player's compass target to location of block at {_target}
				if "%{_dist}%" doesn't contain ".":
					set {_dist} to "%{_dist}%.0"
				if "%{_height}%" doesn't contain ".":
					set {_height} to "%{_height}%.0"
				send action bar "{@color1}Nearest Player: {@color2}%{_target}%{@color1}Distance: {@color2}%{_dist}% {@color1}Height: {@color2}%{_height}%" to player
			delete {_target}
			delete {_dist}
			delete {_height}
		wait 15 ticks

```

```
# Private Vaults by MrScopes
# Version 1.0

# max pv amount is 100
# add pvs by giving them the permission `pv.<number>`
# make sure the users only have 1 permission node for pv.<number>
# give your staff the infinite pv's permission so they can access all pvs of other users

options:

	no pvs: &cYou have no vaults.
	not enough pvs: &cYou only have %pvAmount(player)% &cvaults.

	open others: pv.others
	infinite pvs: pv.infinite

#
#
#

function pvAmount(p: player) :: integer:
	return 100 if {_p} has permission "{@infinite pvs}"
	loop {_p}'s permissions:
		if loop-value starts with "pv.":
			set {_pvAmount::*} to split loop-value at "."
			({_pvAmount::2} parsed as integer) is set
			set {_pvs} to {_pvAmount::2}

	set {_pvs} to 100 if {_pvs} >= 100
	return ({_pvs} parsed as integer)

command /pv [<integer=1>] [<offline player=%player%>]:
	trigger:
		if pvAmount(player) isn't set:
			send "{@no pvs}"
		else:

			set {_player} to arg 2
			set {_player} to player if player doesn't have permission "{@open others}"

			set {_vault number} to arg 1

			if arg 1 > pvAmount(player):
				set {_vault number} to pvAmount(player)
				send "{@not enough pvs}"

			open chest inventory with 5 rows named "&8%{_player}% ##%{_vault number}%" to player
			set {opened::%player%} to {_player}
			wait 1 tick
			set {_num} to 0
			loop {vaultItems::%{_player}%::%{_vault number}%::*}:
				set slot {_num} of player's current inventory to loop-value
				add 1 to {_num}
		   
on inventory open:
	{opened::%player%} is set
	cancel event
	delete {opened::%player%}
					   
on inventory close:
	{opened::%player%} is set
	set {_inv::*} to split uncolored inventory name of player's current inventory at " "
	set {_p} to ({_inv::1} parsed as offline player)
	set {_n} to {_inv::2}
	replace all "##" with "" in {_n}
	set {_n} to {_n} parsed as integer
	loop 54 times:
		set {vaultItems::%{_p}%::%{_n}%::%loop-number - 1%} to slot "%loop-number - 1%" parsed as an integer of current inventory of player
	delete {opened::%player%}

```

```
function getTop() :: objects:
  if {-top::sort} ? 1 second ago < now:
    loop all offline players:
      set {_sort::%time played of loop-value%.%loop-value%} to loop-value
  set {-top::sorted::*} to reversed {_sort::*}
  set {-top::sort} to 10 minutes later
  set metadata tag "TopPlaytime" of ("d" parsed as a player) to chest inventory with 1 row named "&2&lPlaytime Top"
  loop 9 times:
    exit loop if {_top::%loop-number%}
    set {_entry} to {-top::sorted::%loop-number%}
    set slot (loop-number)-1 of metadata tag "TopPlaytime" of ("d" parsed as a player) to clock named "&a&l%{_entry}%" with lore "" and " &a* &lPlaytime: &f%time played of {_entry}%" and "" and " &a* &lPlace: &f##%loop-number%" and ""
  return {-top::sorted::*}


command /playtime [<text>]:
    trigger:
        if arg parsed as a offline player is set:
            send formatted "&c%arg-1%&f has a playtime of &6<tooltip:time played of %arg-1%>%time played of (arg parsed as a player)%"
        else:
            set {_top::*} to getTop()
            open metadata tag "TopPlaytime" of ("d" parsed as a player) to player

```

```
#Made by xlr100#6932, message me for any bug
options:
    #Change the following according to your preference
    item: nether star #The backpack item
    name: &eBackpack #The backpack name
    command: backpack #The command
    permission: * #The permission
    #Do not touch!
    storage: backpacks

function Backpack_Create(rows: integer) :: item:
    add 1 to {{@storage}::backpacks}
    set {_id} to {{@storage}::backpacks}
    set {_item} to {@item} named "{@name} &7(##%{_id}%)"
    set {{@storage}::id::%{_id}%::rows} to {_rows}
    loop integers from 0 to {_rows} * 9:
        set {{@storage}::id::%{_id}%::items::%loop-value%} to air
    return {_item}

command /{@command} [<text>] <integer> <player>:
    permission: {@permission}
    trigger:
        if arg-1 is "give":
            if arg-2 > 0:
                if arg-2 < 7:
                    give Backpack_Create(arg-2) to arg-3
                else:
                    send "&cMin rows 1, max rows 6"
            else:
                send "&cMin rows 1, max rows 6"
        else:
            send "&cCorrect Usage: &7/{@command} give <rows> <player>"

on rightclick with {@item}:
    name of player's tool contains "{@name}"
    set {_name} to name of player's tool
    replace all "{@name} &7(##" and ")" in {_name} with ""
    set {_id} to uncolored {_name}
    set metadata value "backpack" of player to {_id}
    set {_menu} to chest inventory with {{@storage}::id::%{_id}%::rows} rows named "Backpack ##%{_id}%"
    set {_num} to -1
    loop {{@storage}::id::%{_id}%::items::*}:
        add 1 to {_num}
        set slot {_num} of {_menu} to loop-value
    open {_menu} to player

on inventory close:
    metadata value "backpack" of player is set
    set {_id} to metadata value "backpack" of player
    loop integers from 0 to ({{@storage}::id::%{_id}%::rows} * 9):
        set {{@storage}::id::%{_id}%::items::%loop-value%} to slot loop-value of player's current inventory
    delete metadata "backpack" of player

```

```
#Made by xlr100#6932 (For any bugs)
#version: 1
#--------------------------------------------------------
#Configuration
variables:
    prefix = "&c&lPunish »" #Change the prefix in chat
options:
    error.offline: "%{prefix}% &cThe player is not online"
    usage.kick: "%{prefix}% &cCorrect Usage: &7/kick <player> <reason>"
    usage.warn: "%{prefix}% &cCorrect Usage: &7/warn <player> <reason>"
    usage.mute: "%{prefix}% &cCorrect Usage: &7/mute <player> <time> <reason>"
    usage.unmute: "%{prefix}% &cCorrect Usage: &7/unmute <player> <reason>"
    usage.ban: "%{prefix}% &cCorrect Usage: &7/ban <player> <time> <reason>"
    usage.unban: "%{prefix}% &cCorrect Usage: &7/unban <player> <reason>"
    format.time: "&cThe time needs to be in the following format: <amount><sec/min/hour/day> (For example 10min)"
    usage.logs: "%{prefix}% &cCorrect Usage: &7/logs <player> &cor &7&7/logs server"
    command.cooldown: 5 seconds #Change the cooldown for the command

#--------------------------------------------------------

on load:
    wait 1 tick
    Time_Register()
    PunishTime_Register()
    PunishColor_Register()
    PunishShow_Register()


function Time_Register():
    clear {time.types::*}
    set {time.types::second} to "sec"
    set {time.types::minute} to "min"
    set {time.types::hour} to "hour"
    set {time.types::day} to "day"
    clear {letters::*}
    set {_str} to "a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,/,!,@,##,$,%%,^,*,(,),{,},[,],"",|,;,',`,?"
    set {letters::*} to {_str} split at ","

function PunishTime_Register():
    #Mutes
    set {punish.time::mute::1} to "5 Minutes" 
    set {punish.time::mute::2} to "30 Minutes" 
    set {punish.time::mute::3} to "1 Hour" 
    set {punish.time::mute::4} to "1 Day"
    #Bans
    set {punish.time::ban::1} to "1 Hour" 
    set {punish.time::ban::2} to "12 Hours" 
    set {punish.time::ban::3} to "1 Day" 
    set {punish.time::ban::4} to "30 Days"

function PunishColor_Register():
    clear {punish.color::*}
    set {punish.color::warns} to "&e"
    set {punish.color::kicks} to "&f"
    set {punish.color::mutes} to "&8"
    set {punish.color::bans} to "&c"

function PunishShow_Register():
    clear {punish.show::*}
    set {punish.show::warns} to "Warn"
    set {punish.show::kicks} to "Kick"
    set {punish.show::mutes} to "Mute"
    set {punish.show::bans} to "Ban"

function Time_Check(time: string, c: boolean = true) :: boolean:
    loop {letters::*}:
        {_num} contains loop-value-2:
            set {_c} to false
            exit loop
    return {_c}

                
on inventory close:
    delete {inventory::%player's uuid%}

command /logs [<offline player>] [<text>] [<number>]:
    permission: skript.logs
    trigger:
        if arg-1 is set:
            if "%arg-1%" is "clear":
                player is op
                clear {%arg-2%::*}
                send "%{prefix}% &aCleared all %arg-2%"
            else if arg-2 isn't set:
                set {_menu} to chest inventory with 5 rows named "Logs %arg-1%"
                set slot (integers from 0 to 8) of {_menu} to black glass pane named " "
                set slot (integers from 37 to 45) of {_menu} to black glass pane named " "
                set slot 36 of {_menu} to barrier named "&cClose"
                set slot 19 of {_menu} to yellow concrete named "&e&lWarns"
                set slot 21 of {_menu} to white concrete named "&f&lKicks"
                set slot 23 of {_menu} to gray concrete named "&8&lMutes"
                set slot 25 of {_menu} to red concrete named "&c&lBans"
                open {_menu} to player
                set {inventory::%player's uuid%} to "logs.main/%arg-1%"
            else if arg-2 is "warns" or "kicks" or "mutes" or "bans":
                set {_menu} to chest inventory with 6 rows named "Logs %arg-1% - %{punish.show::%arg-2%}%"
                set slot (integers from 0 to 8) of {_menu} to black glass pane named " "
                set slot (integers from 46 to 53) of {_menu} to black glass pane named " "
                set slot 45 of {_menu} to barrier named "&cBack"
                set {_color} to {punish.color::%arg-2%}
                set {_slot} to 9
                if arg-1 isn't "server":
                    loop {punish::%arg-1's uuid%::%arg-2%::*}:
                        set {_id} to loop-value
                        if {%arg-2%::%{_id}%::staff} is set:
                            if arg-2 is "warns" or "kicks":
                                set slot {_slot} of {_menu} to paper named "%{_color}%%{punish.show::%arg-2%}% ##%{_id}%" with lore "&7Staff: %{_color}%%{%arg-2%::%{_id}%::staff}%", "&7Reason: %{_color}%%{%arg-2%::%{_id}%::reason}%" and "&7Date: %{_color}%%{%arg-2%::%{_id}%::when}%"               
                            else:
                                if {%arg-2%::%{_id}%::time} isn't "perm":
                                    set {_time} to {%arg-2%::%{_id}%::time} parsed as timespan
                                else:
                                    set {_time} to {%arg-2%::%{_id}%::time}
                                if {%arg-2%::%{_id}%::undo.staff} is set:
                                    set slot {_slot} of {_menu} to paper named "%{_color}%%{punish.show::%arg-2%}% ##%{_id}%" with lore "&7Staff: %{_color}%%{%arg-2%::%{_id}%::staff}%", "&7Reason: %{_color}%%{%arg-2%::%{_id}%::reason}%", "&7Date: %{_color}%%{%arg-2%::%{_id}%::when}%", "&7Length: %{_color}%%{_time}%", "&7Canceled By: %{_color}%%{%arg-2%::%{_id}%::undo.staff}%" and "&7Reason For Cancel: %{_color}%%{%arg-2%::%{_id}%::undo.reason}%"
                                else:
                                    set slot {_slot} of {_menu} to paper named "%{_color}%%{punish.show::%arg-2%}% ##%{_id}%" with lore "&7Staff: %{_color}%%{%arg-2%::%{_id}%::staff}%", "&7Reason: %{_color}%%{%arg-2%::%{_id}%::reason}%", "&7Date: %{_color}%%{%arg-2%::%{_id}%::when}%" and "&7Length: %{_color}%%{_time}%" 
                            add 1 to {_slot}
                            if {_slot} >= 45:
                                set slot 54 of {_menu} to arrow named "&eNext Page"
                                exit loop
                        else:
                            remove {_id} from {punish::%arg-1's uuid%::%arg-2%::*}
                else:
                    if arg-3 isn't set:
                        set {_c} to true
                    else:
                        set slot 45 of {_menu} to arrow named "&ePrevious Page"
                    set {_need} to arg-3
                    loop all indices of {%arg-2%::*}:
                        if {_c} isn't true:
                            add 1 to {_num}
                            if {_num} >= {_need} - 1:
                                set {_c} to true
                        else:
                            set {_id} to loop-value
                            if arg-2 is "warns" or "kicks":
                                set slot {_slot} of {_menu} to paper named "%{_color}%%{punish.show::%arg-2%}% ##%{_id}%" with lore "&7Player: %{_color}%%{%arg-2%::%{_id}%::player}%", "&7Staff: %{_color}%%{%arg-2%::%{_id}%::staff}%", "&7Reason: %{_color}%%{%arg-2%::%{_id}%::reason}%" and "&7Date: %{_color}%%{%arg-2%::%{_id}%::when}%"               
                            else:
                                if {%arg-2%::%{_id}%::time} isn't "perm":
                                    set {_time} to {%arg-2%::%{_id}%::time} parsed as timespan
                                else:
                                    set {_time} to {%arg-2%::%{_id}%::time}
                                if {%arg-2%::%{_id}%::undo.staff} is set:
                                    set slot {_slot} of {_menu} to paper named "%{_color}%%{punish.show::%arg-2%}% ##%{_id}%" with lore "&7Player: %{_color}%%{%arg-2%::%{_id}%::player}%", "&7Staff: %{_color}%%{%arg-2%::%{_id}%::staff}%", "&7Reason: %{_color}%%{%arg-2%::%{_id}%::reason}%", "&7Date: %{_color}%%{%arg-2%::%{_id}%::when}%", "&7Length: %{_color}%%{_time}%", "&7Canceled By: %{_color}%%{%arg-2%::%{_id}%::undo.staff}%" and "&7Reason For Cancel: %{_color}%%{%arg-2%::%{_id}%::undo.reason}%"
                                else:
                                    set slot {_slot} of {_menu} to paper named "%{_color}%%{punish.show::%arg-2%}% ##%{_id}%" with lore "&7Player: %{_color}%%{%arg-2%::%{_id}%::player}%", "&7Staff: %{_color}%%{%arg-2%::%{_id}%::staff}%", "&7Reason: %{_color}%%{%arg-2%::%{_id}%::reason}%", "&7Date: %{_color}%%{%arg-2%::%{_id}%::when}%" and "&7Length: %{_color}%%{_time}%" 
                            add 1 to {_slot}
                            if {_slot} >= 45:
                                set slot 53 of {_menu} to arrow named "&eNext Page"
                                set {_last} to (loop-value parsed as integer) + 1
                                exit loop
                open {_menu} to player
                if {_last} is set:
                    set {inventory::%player's uuid%} to "logs.%arg-2%/%arg-1%/%{_last}%"
                else:
                    set {inventory::%player's uuid%} to "logs.%arg-2%/%arg-1%"
        else:
            send {@usage.logs}

                
on inventory click:
    if {inventory::%player's uuid%} contains "logs":
        cancel event
        if {inventory::%player's uuid%} contains "main":
            if event-slot is concrete:
                set {_temp::*} to {inventory::%player's uuid%} split at "/"
                make player execute command "/logs %{_temp::2}% %uncolored name of event-slot in lower case%"
            else if event-slot is barrier:
                close player's inventory
        else:
            if event-slot is barrier:
                set {_temp::*} to {inventory::%player's uuid%} split at "/"
                make player execute command "/logs %{_temp::2}%"
            else if event-slot is arrow:
                set {_temp::*} to {inventory::%player's uuid%} split at "/"
                set {_type} to {_temp::1}
                replace all "logs." in {_type} with ""
                if uncolored name of event-slot contains "Next":
                    set {_num} to {_temp::3}
                else:
                    set {_num} to ("%{_temp::3}%" parsed as integer) - 36
                    if {_num} <= 1:
                        make player execute command "/logs %{_temp::2}% %{_type}%"
                        stop
                make player execute command "/logs %{_temp::2}% %{_type}% %{_num}%"

command /warn [<player>] [<text>]:
    permission: skript.warn
    trigger:
        if arg-1 is set:
            if arg-1 is online:
                if arg-2 is set:
                    add 1 to {warn.count}
                    set {warns::%{warn.count}%::player} to arg-1
                    set {warns::%{warn.count}%::staff} to player
                    set {warns::%{warn.count}%::reason} to arg-2
                    set {warns::%{warn.count}%::when} to now
                    add {warn.count} to {punish::%arg-1's uuid%::warns::*}
                    broadcast "&e&lWarns » &e%arg-1% &7has been warned by &e%player% &7for &c%arg-2% &7(ID: %{warn.count}%)"
                else:
                    send {@usage.warn}
            else:
                send {@error.offline}
        else:
            send {@usage.warn}

command /kick [<player>] [<text>]:
    permission: skript.kick
    trigger:
        if arg-1 is set:
            if arg-1 is online:
                if arg-2 is set:
                    add 1 to {kick.count}
                    set {kicks::%{kick.count}%::player} to arg-1
                    set {kicks::%{kick.count}%::staff} to player
                    set {kicks::%{kick.count}%::reason} to arg-2
                    set {kicks::%{kick.count}%::when} to now
                    add {kick.count} to {punish::%arg-1's uuid%::kicks::*}
                    kick arg-1 due to "&fYou were kicked by %player% for %arg-2% (ID: %{kick.count}%)"
                else:
                    send {@usage.kick}
            else:
                send {@error.offline}
        else:
            send {@usage.kick}


command /mute [<offline player>] [<text>] [<text>]:
    permission: skript.mute
    trigger:
        if arg-1 is set:
            if arg-2 is set:
                if arg-3 is set:
                    set {_time} to arg-2 in lower case
                    if {_time} isn't "perm":
                        loop {time.types::*}:
                            if {_time} contains loop-value:
                                set {_num} to {_time} 
                                replace all loop-value in {_num} with ""
                                if Time_Check({_num}) is true:
                                    set {_length} to "%{_num}% %loop-index%"
                                exit loop
                    else:
                        set {_length} to {_time}
                    if {_length} is set:
                        add 1 to {mute.count}
                        set {mutes::%{mute.count}%::player} to arg-1
                        set {mutes::%{mute.count}%::staff} to player
                        set {mutes::%{mute.count}%::reason} to arg-3
                        set {mutes::%{mute.count}%::time} to {_length}
                        set {mutes::%{mute.count}%::when} to now
                        add {mute.count} to {punish::%arg-1's uuid%::mutes::*}
                        set {mute::%arg-1's uuid%} to {mute.count}
                        broadcast "%{prefix}% &e%arg-1% &7has been muted by &e%player% &7for &c%arg-3% &7(ID: %{mute.count}%)"
                    else:
                        send "&cThe time needs to be in the following format: <amount><sec/min/hour/day> (For example 10min)"
                else:
                    send {@usage.mute}
            else:
                send {@usage.mute}
        else:
            send {@usage.mute}

command /unmute [<offline player>] [<text>]:
    permission: skript.mute
    trigger:
        if arg-1 and arg-2 is set:
            if {mute::%arg-1's uuid%} is set:
                set {_id} to {mute::%arg-1's uuid%}
                if {mutes::%{_id}%::time} isn't "perm":
                    set {_wait} to difference between {mutes::%{_id}%::when} and now
                    if {_wait} < {mutes::%{_id}%::time} parsed as timespan:
                        set {_c} to true
                    else:
                        delete {mute::%arg-1's uuid%}
                else:
                    set {_c} to true
                if {_c} is true:
                    set {_id} to {mute::%arg-1's uuid%}
                    set {mutes::%{_id}%::undo.staff} to player
                    set {mutes::%{_id}%::undo.reason} to arg-2
                    set {mutes::%{_id}%::undo.when} to now
                    delete {mute::%arg-1's uuid%}
                    broadcast "%{prefix}% &e%arg-1% &7has been unmuted by &e%player% &7for &c%arg-2%"
                else:
                    send "%{prefix}% &cThis player isn't muted"
            else:
                send "%{prefix}% &cThis player isn't muted"
        else:
            send {@usage.unmute}

on chat:
    if {mute::%player's uuid%} is set:
        set {_id} to {mute::%player's uuid%}
        if {mutes::%{_id}%::time} isn't "perm":
            set {_wait} to difference between {mutes::%{_id}%::when} and now
            set {_need} to {mutes::%{_id}%::time} parsed as timespan
            if {_wait} >= {_need}:
                delete {mute::%player's uuid%}
            else:
                cancel event
                send colored "%{prefix}% &cYou can't talk while being muted (time remaining %difference between {_wait} and {_need}%)"
        else:
            cancel event
            send colored "%{prefix}% &cYou can't talk while being muted (Perm muted)"


command /ban [<offline player>] [<text>] [<text>]:
    permission: skript.ban
    trigger:
        if arg-1 is set:
            if arg-2 is set:
                if arg-3 is set:
                    set {_time} to arg-2 in lower case
                    if {_time} isn't "perm":
                        loop {time.types::*}:
                            if {_time} contains loop-value:
                                set {_num} to {_time} 
                                replace all loop-value in {_num} with ""
                                if Time_Check({_num}) is true:
                                    set {_length} to "%{_num}% %loop-index%"
                                exit loop
                    else:
                        set {_length} to {_time}
                    if {_length} is set:
                        add 1 to {ban.count}
                        set {bans::%{ban.count}%::player} to arg-1
                        set {bans::%{ban.count}%::staff} to player
                        set {bans::%{ban.count}%::reason} to arg-3
                        set {bans::%{ban.count}%::time} to {_length}
                        set {bans::%{ban.count}%::when} to now
                        add {ban.count} to {punish::%arg-1's uuid%::bans::*}
                        set {ban::%arg-1's uuid%} to {ban.count}
                        if {_length} isn't "perm":
                            kick arg-1 due to "&cYou are banned! You can rejoin in %{_length} parsed as timespan% &7Staff: &b%{bans::%{ban.count}%::staff}% &7Reason: &b%{bans::%{ban.count}%::reason}%"
                        else:
                            kick arg-1 due to "&cYou are perm banned! &7Staff: &b%{bans::%{ban.count}%::staff}% &7Reason: &b%{bans::%{ban.count}%::reason}%"
                        broadcast "%{prefix}% &e%arg-1% &7has been banned by &e%player% &7for &c%arg-3% &7(ID: %{ban.count}%)"
                    else:
                        send {@format.time}
                else:
                    send {@usage.ban}
            else:
                send {@usage.ban}
        else:
            send {@usage.ban}

command /unban [<offline player>] [<text>]:
    permission: skript.ban
    trigger:
        if arg-1 is set:
            if arg-2 is set:
                if {ban::%arg-1's uuid%} is set:
                    set {_id} to {ban::%arg-1's uuid%}
                    if {bans::%{_id}%::time} isn't "perm":
                        set {_wait} to difference between {bans::%{_id}%::when} and now
                        if {_wait} < {bans::%{_id}%::time} parsed as timespan:
                            set {_c} to true
                        else:
                            delete {ban::%arg-1's uuid%}
                    else:
                        set {_c} to true
                    if {_c} is true:
                        set {_id} to {ban::%arg-1's uuid%}
                        set {bans::%{_id}%::undo.staff} to player
                        set {bans::%{_id}%::undo.reason} to arg-2
                        set {bans::%{_id}%::undo.when} to now
                        delete {ban::%arg-1's uuid%}
                        broadcast "%{prefix}% &e%arg-1% &7has been unbanned by &e%player% &7for &c%arg-2%"
                    else:
                        send "%{prefix}% &cThis player isn't banned"
                else:
                    send "%{prefix}% &cThis player isn't banned"
            else:
                send {@usage.unban}
        else:
            send {@usage.unban}

on connect:
    if {ban::%player's uuid%} is set:
        set {_id} to {ban::%player's uuid%}
        if {bans::%{_id}%::time} isn't "perm":
            set {_wait} to difference between {bans::%{_id}%::when} and now
            set {_need} to {bans::%{_id}%::time} parsed as timespan
            if {_wait} >= {_need}:
                delete {ban::%player's uuid%}
            else:
                kick player due to "&cYou are banned! You can rejoin in %difference between {_wait} and {_need}% &7Since: &b%{bans::%{_id}%::when}% &7Staff: &b%{bans::%{_id}%::staff}% &7Reason: &b%{bans::%{_id}%::reason}%"
        else:
            kick player due to "&cYou are perm banned! &7Since: &b%{bans::%{_id}%::when}% &7Staff: &b%{bans::%{_id}%::staff}% &7Reason: &b%{bans::%{_id}%::reason}%"

```

```
options:
	Minimum-x: -500 #Minimum x of randomtp
	Maximum-x: 500 #Maximum x of randomtp
	Minimum-z: -500 #Minimum z of randomtp
	Maximum-z: 500 #Maximum  x of randomtp
	
	cooldown: 5 seconds #formated as (Amount of time) (Seconds, Minutes, days ect...)
	avoid: water or lava #Avoid spawning formated as (Block) or (Block) ect...

	worlds: "world" #worlds formated as "(World name)" or "(World name)" or "(World name)" ect...

	Permission: randomtp.use #Permission
	PermissionMessage: &cYou do not have permission to use this command! #No permission message
	CommandIsNotExecuteableInWorld: &cYou can’t use this command in this world! #Can not execute command in this world message
	CooldownMessage: &CYou have to wait another %{_cooldown}% &cbefore you can execute this command again! #Cooldown message %{_cooldown}% is the time until the command is executeable again)
	
Command RandomTP:
	aliases: rtp, wild
	permission: {@Permission}
	Permission Message: {@PermissionMessage}
	trigger:	
		if world is not {@worlds}:
			send "{@CommandIsNotExecuteableInWorld}"
		else:
			if difference between {randomtp::%player%} and now is less than {@cooldown}:
				set {_cooldown} to {@cooldown}
				remove difference between {randomtp::%player%} and now from {_cooldown}
				send "{@CooldownMessage}"
			else:
				set {_Randomtp.avoid} to 0
				while {_Randomtp.avoid} is equal to 0:
					wait 1 tick
					set {_loc} to location at random number between {@Minimum-x} and {@Maximum-x}, 255, random number between {@Maximum-z} and {@Minimum-z}
					while block at {_loc} is air:
						remove 1 from y-coordinate of {_loc}
					loop all blocks in radius 1 of {_loc}:
						if loop-block is not {@avoid}:
							add 1 to y-coordinate of {_loc}
							set {_Randomtp.avoid} to 1
							teleport player to {_loc}
							set {randomtp::%player%} to now 
							stop

```

```
options:
  prefix: &3[&7Rank Vouchers&3]
  addvoucher: rank.add
  voucheraddinventory: &6Rank Add
  vouchergive: rank.give
  vouchergiveinventory: &aRank Giver
  command: pex user %player% group set %{rank::cmd::%{_t}%}% # Please Use %player% instead of player and %{_t}% instead of group 
  fullaccess: voucher.all
  voucherremove: voucher.remove


#
#
#		NOTE
#
#
#
#	For This Skript To Work You Must Write All The Names Of The groups in Lower Case Example "vip" NOT "VIP"
#
#
#
#
#


command voucheradd [<string>] [<string>]:
  permission: {@addvoucher}
  trigger:
    if arg-1 is set:
      if arg-2 is set:
        if {ranks::*} contains arg-1:
          send "{@prefix} &7This Rank Already has a rank voucher" to player
          send "&7Use /removerank %arg-1% to remove the rank voucher" to player
        else:
          open virtual chest inventory with size 3 named "{@voucheraddinventory}" to player
          format gui slot 13 of player with player's tool
          format gui slot 11 of player with red wool named "&c&lCancel" to close:
            send "{@prefix} &cCanceled" to player
          format gui slot 15 of player with green wool named "&a&lAdd" to close:
            set {_t} to switchCaseFor(arg-1, false)
            add {_t} to {ranks::*}
            set {rank::voucher::%arg-1%} to player's tool
            send "{@prefix} &aAdded Voucher" to player
            add player's tool to {rank::voucher::*}
            set {rank::cmd::%{_t}%} to arg-2
      else:
        send "{@prefix} &7Usage: /addrank (rankname) (Group Name of rank)" to player
    else:
      send "{@prefix} &7Usage: /addrank (rankname) (Group Name of rank)" to player

command vouchergive [<player>]:
  permission: {@vouchergive}
  trigger:
    if arg-1 is set:
      rankgive(player, "%arg-1%")
    else:
      rankgive(player, "non")

function rankgive(p: player, s: string):
  if {_s} is "non":
    open virtual chest inventory with size 6 named "{@vouchergiveinventory}" to {_p}
    set {_num} to 0
    loop {ranks::*}:
      format gui slot {_num} of {_p} with {rank::voucher::%loop-value%} to close:
        give {_p} {rank::voucher::%loop-value%}
        send "{@prefix} &aVoucher Recieved" to {_e}
    add 1 to {_num}
  else:
    set {_e} to {_s} parsed as a player
    open virtual chest inventory with size 6 named "{@vouchergiveinventory}" to {_p}
    set {_num} to 0
    loop {ranks::*}:
      format gui slot {_num} of {_p} with {rank::voucher::%loop-value%} to close:
        give {_e} {rank::voucher::%loop-value%}
        send "{@prefix} &aVoucher Recieved" to {_p}
        send "{@prefix} &aYou have been given a rank voucher" to {_e}
      add 1 to {_num}

on right click:
  if {rank::voucher::*} contains player's tool:
    set {_e::*} to name of player's tool split at " "
    loop {_e::*}:
      set {_e} to loop-value
      set {_t} to switchCaseFor({_e}, false)
      if {ranks::*} contains {_t}:
        stop loop
    command "{@command}"
    send "{@prefix} &aYou Have redeemed Your Rank You Might Have to relog for changes to occur!" to player

command voucher [<string>]:
  aliases: vouchers
  permission: {@fullaccess}
  trigger:
    open virtual chest inventory with size 3 named "&6Vouchers" to player
    format gui slot 11 of player with green wool named "&a&lAdd Voucher" with lore "" and "&7Click Me to add a new rank voucher!" to close:
      make player execute command "voucheradd %arg-1%"
    format gui slot 13 of player with glowing paper named "&a&lGive Voucher" with lore "" and "&7Click Me to give a rank voucher!" to close:
      make player execute command "vouchergive %arg-1%"
    format gui slot 15 of player with barrier named "&c&lRemove Voucher" with lore "" and "&7Click Me to remove a rank voucher!" to close:
      make player execute command "voucherremove"

command voucherremove:
  permission: {@voucherremove}
  trigger:
    open virtual chest inventory with size 6 named "{@vouchergiveinventory}" to player
    set {_num} to 0
    loop {ranks::*}:
      format gui slot {_num} of player with {rank::voucher::%loop-value%} to close:
        remove loop-value from {ranks::*}
        delete {rank::voucher::%loop-value%}
        send "&aVoucher Deleted" to player
    add 1 to {_num}

on script load:
  set {_letters} to "Aa Bb Cc Dd Ee Ff Gg Hh Ii Jj Kk Ll Mm Nn Oo Pp Qq Rr Ss Tt Uu Vv Ww Xx Yy Zz"
  set {_letter-pairs::*} to {_letters} split at " "
  loop {_letter-pairs::*}:
    set {_pair::*} to loop-value split at ""
    set {_uppercase} to {_pair::1}
    set {_lowercase} to {_pair::2}
    set {letters::uppercase::%{_lowercase}%} to {_uppercase}
    set {letters::lowercase::%{_uppercase}%} to {_lowercase}
 
on script unload:
  delete {letters::*}

function switchCaseFor(text: text, to-uppercase: boolean) :: text:
  set {_characters::*} to {_text} split at ""
  set {_new} to ""
  loop {_characters::*}:
    set {_char} to loop-value
    if {_to-uppercase} is true:
      set {_char} to {letters::uppercase::%loop-value%}
    else:
      set {_char} to {letters::lowercase::%loop-value%}
    set {_new} to "%{_new}%%{_char}%"
  return {_new}

```

```
#
#
# 
# By Adxm#1343
#
#
#

options:
	P: &3&l[REPORT]&7
	S: &a&lSUCCESS&7
	E: &c&lERROR&7
on script load:
	broadcast "{@P} Successfully &3reloaded&7."
	if {reports::total} is not set:
		set {reports::total} to 0
	if {reports::bug::total} is not set:
		set {reports::bug::total} to 0
	if {reports::player::total} is not set:
		set {reports::player::total} to 0
	if {reports::other::total} is not set:
		set {reports::other::total} to 0
	if {latest::reload} is not set:
		set {latest::reload} to 0
	if {latest::reload::player} is not set:
		set {latest::reload::player} to "N/A"
command /report [<text>] [<text>]:
	aliases: reports
	trigger:
		if arg-1 is "bug":
			if arg-2 is set:
				log "[BUG] %player% has reported the bug: ""%arg-2%""" to "reportsbug.log"
				send "{@S} Successfully reported."
				alertReport(player, arg-1, arg-2)
				setLatest(player, arg-1, arg-2)
			else:
				send "{@E} Enter &3argument-2"
		else if arg-1 is "player":
			if arg-2 is set:
				log "[PLAYER] %player% has reported the player: ""%arg-2%""" to "reportsplayer.log" 
				send "{@S} Successfully reported."
				alertReport(player, arg-1, arg-2)
				setLatest(player, arg-1, arg-2)
			else:
				send "{@E} Enter &3argument-2"
		else if arg-1 is "other":
			if arg-2 is set:
				log "[BUG] %player% has reported other: ""%arg-2%""" to "reportsother.log" 
				send "{@S} Successfully reported."
				alertReport(player, arg-1, arg-2)
				setLatest(player, arg-1, arg-2)
			else:
				send "{@E} Enter &3argument-2."
		else if arg-1 is "reload":
			if player has permission "report.reload":
				player command "sk reload %script%"
				set {latest::reload} to now
				set {latest::reload::player} to player
			else:
				send "{@E} No permission."
		else if arg-1 is "manager":
			if player has permission "report.manager":
				set {_inv} to chest inventory with 1 row named "{@P} Manager"
				open {_inv} to player
				set slot 0 of player's current inventory to torch named "&6Total Reports" with lore "&3Total: &7%{reports::total}%" and "&3Bugs: &7%{reports::bug::total}%" and "&3Players: &7%{reports::player::total}%" and "&3Other: &7%{reports::other::total}%"
				set slot 4 of player's current inventory to redstone torch named "&6Latest Report" with lore "&3User: &7%{latest::player}%" and "&3Type: &7%{latest::type}%" and "&3Report: &7%{latest::report}%"
				set slot 8 of player's current inventory to nether quartz ore named "&6Latest reload &7&o(using /report reload)" with lore "&3Player: &7%{latest::reload::player}%" and "&3Time: &7%{latest::reload}%"
			else:
				send "{@E} No permission."
		else:
			send "{@E} Enter either &3bug &7| &3player &7| &3other &7| &3reload &7| &3manager&7."

function alertReport(p: player, type: text, report: text):
	add 1 to {reports::%{_type}%::total}
	loop all players:
		if loop-player has permission "reports.alert":
			send "{@P} &3%{_p}% &7has reported a &3%{_type}%&7: ""&3%{_report}%&7""" to loop-player
			send "{@P} This has been logged to &3reports%{_type}%&7 in the directory &3/plugins/Skript/logs/reports%{_type}%&7." to loop-player

function setLatest(p: player, type: text, report: text):
	add 1 to {reports::total}
	set {latest::player} to {_p}
	set {latest::type} to {_type}
	set {latest::report} to {_report}

```

```
#ScoreBoard skripted by: SH4D03
#ScoreBoard allows you to customise an individual scoreboard for each world
#For a full list of commands, do /scoreboard in game
#Options below are configurable

options:
	prefix: &3&lScoreBoard &8|            #This is the prefix used in scoreboard related messages
	colour1: &3                                       #This is the primary colour used in scoreboard related messages
	colour2: &b                                       #This is the secondary colour used in scoreboard related messages
	perm: scoreboard.admin               #This is the permission required to do scoreboard admin commands
	refresh: 10                                        #This is how often in ticks the scoreboard refreshes (Recommended: 10)
	filename: test                                   #Please enter the name of your script file here




#HARD CODE
#Don't edit if you do not know what you are doing

function scoreboard(player: player, world: text):
	clear {_player}'s scoreboard
	set title of {_player}'s scoreboard to ""
	if {Scoreboard::%{_world}%::*} is not set:
		stop
	set {_line} to 1
	loop 15 times:
		if {Scoreboard::%{_world}%::%{_line}%} is set:
			set line {_line} of {_player}'s scoreboard to "%{Scoreboard::%{_world}%::%{_line}%}%"
		add 1 to {_line}
	if {Scoreboard::%{_world}%::title} is set:
		set title of {_player}'s scoreboard to "%{Scoreboard::%{_world}%::title}%"
command /scoreboard [<text>] [<integer>] [<text>] :
	trigger:
		if arg-1 is "set" or "Set":
			if player does not have permission "{@perm}":
				send "{@prefix} {@colour1}You do not have permission to run this command!" to player
				stop
			if arg-2 and arg-3 is set:
				set {_world} to world of player
				set {Scoreboard::%{_world}%::%arg-2%} to colored arg-3
				send "{@prefix} {@colour1}Successfully set line {@colour2}%arg-2%{@colour1} of scoreboard in world {@colour2}%world of player% {@colour1}to: &f%{Scoreboard::%{_world}%::%arg-2%}%" to player
			else:
				send "{@prefix} {@colour1}Correct Usage: {@colour2}/scoreboard set <line> <text>" to player
		else if arg-1 is "delete" or "Delete":
			if player does not have permission "{@perm}":
				send "{@prefix} {@colour1}You do not have permission to run this command!" to player
				stop
			if arg-2 is set:
				set {_world} to world of player
				delete {Scoreboard::%{_world}%::%arg-2%}
				send "{@prefix} {@colour1}Successfully deleted line {@colour2}%arg-2%{@colour1} of scoreboard in world {@colour2}%world of player%{@colour1}!" to player
			else:
				send "{@prefix} {@colour1}Correct Usage: {@colour2}/scoreboard delete <line>" to player
		else if arg-1 is "title" or "Title":
			if player does not have permission "{@perm}":
				send "{@prefix} {@colour1}You do not have permission to run this command!" to player
				stop
			if arg-3 is set:
				set {_world} to world of player
				set {Scoreboard::%{_world}%::title} to colored arg-3
				send "{@prefix} {@colour1}Successfully set title of scoreboard in world {@colour2}%world of player% {@colour1}to: &f%{Scoreboard::%{_world}%::title}%" to player
			else:
				send "{@prefix} {@colour1}Correct Usage: {@colour2}/scoreboard title 1 <text>" to player
		else if arg-1 is "clear" or "Clear":
			if player does not have permission "{@perm}":
				send "{@prefix} {@colour1}You do not have permission to run this command!" to player
				stop
			set {_world} to world of player
			delete {Scoreboard::%{_world}%::*}
			send "{@prefix} {@colour1}Successfully deleted scoreboard in world {@colour2}%world of player%{@colour1}!" to player
		else if arg-1 is "toggle":
			if {Scoreboard::%player's uuid%} is set:
				delete {Scoreboard::%player's uuid%}
				send "{@prefix} {@colour1}Successfully toggled scoreboard visibility to: {@colour2}OFF" to player
			else:
				set {Scoreboard::%player's uuid%} to true
				send "{@prefix} {@colour1}Successfully toggled scoreboard visibility to: {@colour2}ON" to player
		else if arg-1 is "refresh" or "Refresh":
			if player does not have permission "{@perm}":
				send "{@prefix} {@colour1}You do not have permission to run this command!" to player
				stop
			loop all players:
				scoreboard(loop-player, "%world of loop-player%")
			send "{@prefix} {@colour1}Successfully refreshed the scoreboard for all online players" to player
		else if arg-1 is "view" or "View":
			if player does not have permission "{@perm}":
				send "{@prefix} {@colour1}You do not have permission to run this command!" to player
				stop
			send "{@prefix} {@colour1}&lCurrent Scoreboard:" to player
			set {_world} to "%world of player%"
			if {Scoreboard::%{_world}%::title} is set:
				send "%{Scoreboard::%{_world}%::title}%" to player
			loop 15 times:
				if {Scoreboard::%{_world}%::%{_line}%} is set:
					send "%{Scoreboard::%{_world}%::%{_line}%}%" to player
				add 1 to {_line}
		else if arg-1 is "reload" or "Reload":
			if player does not have permission "{@perm}":
				send "{@prefix} {@colour1}You do not have permission to run this command!" to player
				stop
			make player execute command "skript reload {@filename}"
		else:
			if player does not have permission "{@perm}":
				send "{@prefix} {@colour1}Usage: {@colour2}/scoreboard toggle" to player
				stop
			else:
				send "{@prefix} {@colour1}&lUsage:" to player
				send "{@colour2}/scoreboard set <line> <text> {@colour1}(You can do this in each world)" to player
				send "{@colour2}/scoreboard clear {@colour1}(You can do this in each world)" to player
				send "{@colour2}/scoreboard title 1 <text> {@colour1}(You can do this in each world)" to player
				send "{@colour2}/scoreboard toggle {@colour1}(Toggles scoreboard visibility)" to player
				send "{@colour2}/scoreboard delete <line> {@colour1}(You can do this in each world)" to player
				send "{@colour2}/scoreboard refresh {@colour1}(This refreshes everyone's scoreboards)" to player
				send "{@colour2}/scoreboard view {@colour1}(This shows you a text version of your worlds current scoreboard)" to player
				send "{@colour2}/scoreboard reload {@colour1}(Reloads the script and config)" to player
on world change:
	scoreboard(player, "%world of player%")		
on join:
	while player is online:	
		scoreboard(player, "%world of player%")
		wait {@refresh} ticks
on command "skript reload {@filename}":
	if executor is not console:
		cancel event
		send "{@prefix} {@colour1}Reloading..." to player
		execute console command "script reload {@filename}"
		send "{@prefix} {@colour1}Successfully reloaded Version 1.0" to player

```

```
#   Sell Wands Empowered
#   Made By Shy#7014 (dm if there are any bugs/issues. Thank you!)

#Config (Mote you can add more just follow the format.)
options:
    cactus: 10
    sugar cane: 10
    pumpkin: 15


command /sellwand [<text>] [<player>] [<text>]:
    permission: sellwand.admin
    trigger:
        if arg 1 is "help":
            send "&aUsage: /sellwand [give] [player] [multiplier]"
        else if arg 1 is "give":
            if arg 2 is a player:
                if arg 3 is set:
                    give player blaze rod named "&6&lSellwand" with lore "&aMultiplier: %arg-3%"
                    send "&aGiven a %arg-3%x sellwand to %arg-2%!"
                else:
                    send "&aUsage: /sellwand [give/help] [player] [multiplier]"
            else:
                send "&aUsage: /sellwand [give/help] [player] [multiplier]"
        else:
            send "&aUsage: /sellwand [give/help] [player] [multiplier]"

command /bal:
    trigger:
        send "&aBal: %{balance::%player's uuid%}%"


function sell(p: player, c: block):
    set {_u} to {_p}'s uuid
    set {_cactus} to number of cactus in {_c}'s inventory
    set {_cactus} to {_cactus} * {@cactus}
    set {_cane} to number of sugar cane in {_c}'s inventory
    set {_cane} to {_cane} * {@sugar cane}
    set {_pumpkin} to number of pumpkin in {_c}'s inventory
    set {_pumpkin} to {_pumpkin} * {@pumpkin}
    remove all cactus, pumpkin and sugar cane from {_c}'s inventory
    add {_cactus} + {_pumpkin} + {_cane} to {_total}
    set {_multi} to uncolored line 1 of lore of {_p}'s held item
    replace all "Multiplier: " in {_multi} with ""
    set {_multi} to {_multi} parsed as integer
    set {_total} to {_total} * {_multi}
    set {balance::%{_u}%} to {_total} + {balance::%{_u}%}
    send "&aYou have earned $%{_total}% &afrom selling!" to {_p}


on right click with a blaze rod:
    if name of player's held item is "&6&lSellwand":
        if event-block is a chest:
            sell(player, clicked block)
            cancel event

```

```
command /kit [<text>]:
    trigger:
        if arg 1 is not set:
            open virtual chest inventory with size 3 named "Kits" to player 
            loop (3*9) times:
                format gui slot (loop-number - 1) of player with black stained glass pane named "&r"
            format gui slot 10 of player with iron sword named "&ePvP" to run:
                player command "kit pvp"
            format gui slot 12 of player with bow named "&eArcher" to run:
                player command "kit archer"
            format gui slot 14 of player with leather helmet named "&eNinja" to run:
                player command "kit ninja"
            format gui slot 16 of player with diamond chestplate named "&eTank" to run:
                player command "kit tank"
        else:
            close player's inventory
            if arg-1 is "pvp":
                remove speed from player                                                                                                                                                                                        
                remove slowness from player                                                                                                                                                                                            
                clear player's inventory                                                                                                                                                                                                                            
                give iron sword to player
                give iron helmet to player
                give iron chestplate to player
                give iron leggings to player
                give iron boots to player
                give 64 steak to player                                                                                                                                                                                                                                     
                give 4 golden apple to player
                send "&6&lBRIGHTER > &7You have been given kit &ePvP &8(&eMade by &6CalvishDad&8)" to player
            else if arg-1 is "archer":                                                                                                                                                                                                                                                                                                                                           
                remove speed from player                                                                                                                                                                                        
                remove slowness from player                                                                                                                                                                                            
                clear player's inventory                                                                                                                                                                                                                                 
                give stone sword to player                                                                                                                                                                                                                                 
                give leather helmet to player
                give leather chestplate to player
                give leather leggings to player
                give boots to player
                give 64 steak to player
                give bow to player
                give 64 arrow to player
                message "&6&lBRIGHTER > &7You have been given kit &eArcher &8(&eMade by &6CalvishDad&8)" to player
            else if arg-1 is "ninja":
                remove speed from player                                                                                                                                                                                        
                remove slowness from player
                apply potion of speed of tier 1 to player for 9999 seconds
                clear player's inventory
                give iron sword to player
                give leather cap to player
                give leather tunic to player
                give leather pants to player
                give leather boots to player
                give 64 steak to player
                give 2 golden apple to player
                message "&6&lBRIGHTER > &7You have been given kit &eNinja &8(&eMade by &6CalvishDad&8)" to player                                                                                             
            else if arg-1 is "tank":
                remove speed from player
                remove slowness from player
                apply potion of slowness of tier 1 to player for 9999 seconds
                clear player's inventory
                give stone sword to player
                give diamond helmet to player
                give diamond chestplate to player
                give diamond leggings to player
                give diamond boots to player
                give 64 steak to player
                message "&6&lBRIGHTER > &7You have been given kit &eTank &8(&eMade by &6CalvishDad&8)" to player
            else:
                message "&cInvalid kit."

```

```
options:
    debug: false
    codes: 0|1|2|3|4|5|6|7|8|9|a|b|c|d|e|f|k|l|m|n|o|r
  
function removeColor(msg: text) :: text:
    set {_m::*} to {_msg} split at ""
    
    set {_color-codes} to "{@codes}"
    set {_colors::*} to {_color-codes} split at "|"
    
    set {_new} to ""
    
    loop {_m::*}:
        set {_char} to loop-value
        set {_prev} to the last character of {_new}
        
        if {_prev} is "&":
        
            loop {_colors::*}:
            
                if loop-value-2 is {_char}:
                    set {_skip} to true
                
        if {_skip} is set:
            delete {_skip}
            
        else:
            set {_new} to "%{_new}%%{_char}%"
                
    return {_new}

function jsonColorize(msg: text, default-color: text = "&r") :: text:
    set {_m::*} to {_msg} split at ""
    
    set {_color-codes} to "{@codes}"
    set {_colors::*} to {_color-codes} split at "|"
     
    set {_color} to colored {_default-color}
    set {_code} to the first character of {_color}
    
    set {_new} to ""
    set {_skip} to 0
    
    loop amount of {_m::*} times:
    
        if {_skip} is more than or equal to 1:
            subtract 1 from {_skip}
            
        else:
            set {_char} to {_m::%loop-number%}
            set {_next} to {_m::%loop-number + 1%}
            
            if {_char} is "&" or {_code}:
            
                loop {_colors::*}:
                
                    if loop-value-2 is {_next}:
                        set {_color} to "%{_color}%%{_code}%%{_next}%"
                        
                        if {_next} is "r":
                            set {_color} to {_default-color}
                            
                        set {_new} to "%{_new}%%{_color}%"
                        set {_skip} to 1
                        
                if {_skip} is less than or equal to 0:
                    set {_new} to "%{_new}%%{_char}%"
                
            else if {_char} is " ":
                set {_new} to "%{_new}% %{_color}%"
            
            else:
                set {_new} to "%{_new}%%{_char}%"
                
    return {_new}

function jsonSanitize(msg: text) :: text:
        
    set {_m::*} to {_msg} split at ""
    
    loop {_m::*}:
    
        if loop-value is """":
            set {_m::%loop-index%} to "\""" # """
            
        else if loop-value is "\":
            set {_m::%loop-index%} to "\\"
            
    set {_new} to join {_m::*} with ""
    return {_new}

function jsonFormat(msg: text, color: boolean = true) :: text:
    set {_m::*} to {_msg} split at "||"
    
    set {_current} to 1
    
    loop {_m::*}:
        if {_clusters::%{_current}%} is not set:
            set {_clusters::%{_current}%} to ""
        
        if {_clusters::%{_current}%::text} is not set:
            set {_clusters::%{_current}%::text} to jsonSanitize(loop-value)
            
        else:
            set {_tag} to the first 4 characters of loop-value
            set {_value} to subtext of loop-value from characters 5 to the length of loop-value
            
            if {_tag} is "ttp:":
                set {_clusters::%{_current}%::tooltip} to jsonSanitize({_value})
                
            else if {_tag} is "cmd:":
                set {_clusters::%{_current}%::command} to jsonSanitize({_value})
                
            else if {_tag} is "sgt:":
                set {_clusters::%{_current}%::suggest} to jsonSanitize({_value})
                
            else if {_tag} is "url:":
            
                if {_value} doesn't contain "http://" or "https://":
                    set {_value} to "http://%{_value}%"
                    
                set {_clusters::%{_current}%::url} to jsonSanitize({_value})
                
            else if {_tag} is "ins:":
                set {_clusters::%{_current}%::insertion} to jsonSanitize({_value})
                
            else:
                add 1 to {_current}
                set {_clusters::%{_current}%::text} to jsonSanitize(loop-value)
                set {_clusters::%{_current}%} to ""
     
    loop {_clusters::*}:

        set {_i} to loop-index
        
        set {_text} to {_clusters::%{_i}%::text}
        
        if {_color} is true:
            set {_text} to jsonColorize({_text})
            
        if {_json} is not set:
            set {_json} to "{""text"":""%{_text}%"""
        else:
            set {_json} to "%{_json}%,{""text"":""%{_text}%"""
        
        if {_clusters::%{_i}%::tooltip} is set:
        
            if {_color} is true:
                set {_tooltip} to jsonColorize({_clusters::%{_i}%::tooltip})
                
            else:
                set {_tooltip} to {_clusters::%{_i}%::tooltip}
                
            set {_json} to "%{_json}%,""hoverEvent"":{""action"": ""show_text"",""value"": ""%{_tooltip}%""}"
        
        if {_clusters::%{_i}%::insertion} is set:
            set {_json} to "%{_json}%,""insertion"":""%{_clusters::%{_i}%::insertion}%"",""obfuscated"":false"
        
        if {_clusters::%{_i}%::command} is set:
            set {_clickable} to "%{_json}%,""clickEvent"":{""action"":""run_command"",""value"":""%{_clusters::%{_i}%::command}%""}"
            
        if {_clusters::%{_i}%::suggest} is set:
            set {_clickable} to "%{_json}%,""clickEvent"":{""action"": ""suggest_command"",""value"": ""%{_clusters::%{_i}%::suggest}%""}"
            
        if {_clusters::%{_i}%::url} is set:
            set {_clickable} to "%{_json}%,""clickEvent"":{""action"": ""open_url"",""value"": ""%{_clusters::%{_i}%::url}%""}"
            
        if {_clickable} is set:
            set {_json} to "%{_clickable}%}"
            delete {_clickable}
            
        else:
            set {_json} to "%{_json}%}"
    
    return "{""text"":"""", ""extra"":[%{_json}%]}"

function json(to: text, msg: text, color: boolean = true):
    set {_msg} to jsonFormat({_msg}, {_color})
    execute console command "/tellraw %{_to}% %{_msg}%"

# Name: SkNotepad
# Author: TrueFusion
# Version: 1.0
# Dependancies: Skript, Json.sk
# Use: A Chat Notepad For Servers.

command /notepad [<text>]:
  description: Toggles on and off the Notepad.
  permission: notepad.use
  permission message: &a&lNotepad &7| &fYou do not have the correct permissions!
  trigger:
    if arg-1 is "on":
      set {notepad.toggle.%player's uuid%} to true
      send "&a&lNotepad &7| &fThe Notepad is now on!"
      if {notepad.%player's uuid%::*} is not set:
        set {_uuid} to player's uuid
        delete {notepad.%{_uuid}%::*}
        set {_x} to 101
        loop 94 times:
          remove 1 from {_x}
          if {notepad.%{_uuid}%::%{_x}%} is not set:
            set {notepad.%{_uuid}%::%{_x}%} to ""
        set {notepad.%{_uuid}%::6} to "&8&l------------------------------"
        set {notepad.%{_uuid}%::5} to "&8&l|"
        set {notepad.%{_uuid}%::4} to "&8&l|"
        set {notepad.%{_uuid}%::3} to "&8&l|"
        set {notepad.%{_uuid}%::2} to "&8&l|"
        set {notepad.%{_uuid}%::1} to "&8&l------------------------------"
    else if arg-1 is "off":
      if {notepad.toggle.%player's uuid%} is true:
        loop 100 times:
          send "" to player
        set {notepad.toggle.%player's uuid%} to false
        send "&a&lNotepad &7| &fThe Notepad is now off!"
      else:
        set {notepad.toggle.%player's uuid%} to false
        send "&a&lNotepad &7| &fThe Notepad is now off!"
    else:
      send "&a&lNotepad &7| &f/notepad (on/off)" to player

on chat:
  if {notepad.toggle.%sender's uuid%} is true:
    cancel event
    notepadCycle(sender)
    set {notepad.%sender's uuid%::7} to message
    set {_c} to 101
    loop 100 times:
      send "" to sender
    loop 100 times:
      remove 1 from {_c}
      if {notepad.%sender's uuid%::%{_c}%} is not "":
        if {_c} is not less than 7:
          send "&7&l%({_c} - 6)% &r&f%{notepad.%sender's uuid%::%{_c}%}%" to sender
        else:
          if {_c} is 6:
            json("%sender%", "&8&l------------------------------")
          if {_c} is 5:
            json("%sender%", "&8&l|&r||&f ||&c&lExit||ttp:&7Save and exit notepad||cmd:/notepad off")
          if {_c} is 4:
            json("%sender%", "&8&l|&r||&f ||&4&lReset||ttp:&7Reset your notepad||cmd:/notepad:reset")
          if {_c} is 3:
            json("%sender%", "&8&l|&r||&f ||&a&lVersion||ttp:&a&lNotepad &7| &fV1.0")
          if {_c} is 2:
            json("%sender%", "&8&l|&r||&f ||&b&l%sender%||ttp:&7Its you!")
          if {_c} is 1:
            json("%sender%", "&8&l------------------------------")

every 5 ticks:
  loop all players:
    if {notepad.toggle.%loop-player's uuid%} is true:
      set {_c} to 101
      loop 100 times:
        send "" to loop-player
      loop 100 times:
        remove 1 from {_c}
        if {notepad.%loop-player's uuid%::%{_c}%} is not "":
          if {_c} is not less than 7:
            send "&7&l%({_c} - 6)% &r&f%{notepad.%loop-player's uuid%::%{_c}%}%" to loop-player
          else:
            if {_c} is 6:
              json("%loop-player%", "&8&l------------------------------")
            if {_c} is 5:
              json("%loop-player%", "&8&l|&r||&f ||&c&lExit||ttp:&7Save and exit notepad||cmd:/notepad off")
            if {_c} is 4:
              json("%loop-player%", "&8&l|&r||&f ||&4&lReset||ttp:&7Reset your notepad||cmd:/notepad:reset")
            if {_c} is 3:
              json("%loop-player%", "&8&l|&r||&f ||&a&lVersion||ttp:&a&lNotepad &7| &fV1.0")
            if {_c} is 2:
              json("%loop-player%", "&8&l|&r||&f ||&b&l%loop-player%||ttp:&7Its you!")
            if {_c} is 1:
              json("%loop-player%", "&8&l------------------------------")
        else if {notepad.%loop-player's uuid%::%{_c}%} is not set:
          set {notepad.%loop-player's uuid%::%{_c}%} to ""

command /notepad:reset:
  description: Resets the notepad!
  permission: notepad.use
  permission message: &a&lNotepad &7| &fYou do not have the correct permissions!
  trigger:
    set {_uuid} to player's uuid
    delete {notepad.%{_uuid}%::*}
    set {_x} to 101
    loop 94 times:
      remove 1 from {_x}
      if {notepad.%{_uuid}%::%{_x}%} is not set:
        set {notepad.%{_uuid}%::%{_x}%} to ""
    set {notepad.%{_uuid}%::6} to "&8&l------------------------------"
    set {notepad.%{_uuid}%::5} to "&8&l|"
    set {notepad.%{_uuid}%::4} to "&8&l|"
    set {notepad.%{_uuid}%::3} to "&8&l|"
    set {notepad.%{_uuid}%::2} to "&8&l|"
    set {notepad.%{_uuid}%::1} to "&8&l------------------------------"

function notepadCycle(p: player):
  set {_uuid} to {_p}'s uuid
  set {_c} to 101
  set {_x} to 100
  loop 93 times:
    remove 1 from {_c}
    remove 1 from {_x}
    if {notepad.%{_uuid}%::%{_x}%} is not set:
      set {notepad.%{_uuid}%::%{_x}%} to ""
    set {notepad.%{_uuid}%::%{_c}%} to {notepad.%{_uuid}%::%{_x}%}

```

```
options:
	permission: report.Admin   # Permission
	Prefix: &6Server &7        # Prefix
	NoPermMessage: &cYou don't have the permissions to use this Command!

	cooldown: 15 seconds       # Cooldown, so people cant spam it
	CooldownMessage: &7Please wait &7[&c%remaining time%&7]   
	CooldownBypass: report.bypass

command /report [<offline player>] [<text>]:
	cooldown: {@cooldown}
	cooldown message: {@CooldownMessage}
	cooldown bypass: {@CooldownBypass}
	trigger:
		if arg-1 is not set:
			send "&cUsage: /report <player> <reason>"
		else:
			if arg-2 is not set:
				send "&cUsage: /report <player> <reason>"
			else: 
				set {_hasPlayed} to 1 if arg-1 has played before
				set {_hasPlayed} to 1 if arg-1 is online
				if {_hasPlayed} is set:
					add arg-1 to {reports::list::*} if {reports::list::*} does not contain arg-1
					add arg-2 to {reports::%arg-1%::reason::*}
					add player to {reports::%arg-1%::reporter::*}
					add now to {reports::%arg-1%::time::*}
					set {reports::%arg-1%::last} to now
					set {_p} to player
					
					#Report Message:
					send "{@Prefix} &7You have reported [%arg-1%&7]" 
					send "{@Prefix} [%player%&7] &7has reported [&c%arg-1%&7] &7[<command:/reports>&aClick me<reset>&7]" to all players where [input has permission "{@permission}"]
				else:
					send "{@Prefix} This Player has never played here before"


command /reports [<offline player>]:
	trigger:
		if player has permission "{@permission}":
			if arg-1 is offline player:
				reports(player,arg-1,1)
			else:
				menu(player,1)
		else:
			send "{@NoPermMessage}"
			send "&7[&cReport&7] &cMade by Sorbon"

			
function open(p:player,n:string):
	open virtual chest inventory with size 6 named "%{_n}%" to {_p}
	format gui slot (all numbers between 0 and 54) of {_p} with light gray stained glass pane named "" to do nothing
	format gui slot 0,1,2,3,4,5,6,7,8,36,37,38,39,40,41,42,43 and 44 of {_p} with gray stained glass pane named "" to do nothing

function fix(o:objects) :: objects:
	loop {_o::*}:
		add loop-value to {_n::*}
	return reversed {_n::*}
	
	
# This is super weird, I have to fix that in another update (sorry)
#
#
#   If you have a better version of this, pls contact me :D
function removePlayer(p:player):
	remove {_p} from {reports::list::*}
	set {_list::*} to {reports::list::*}
	clear {reports::list::*}
	loop {_list::*}:
		add loop-value to {reports::list::*}
		
		
function delete(p:player,r:player,i:integer):
	if size of {reports::%{_r}%::reason::*} = 1:
		removePlayer({_r})
		clear {reports::%{_r}%::*}
		menu({_p},1)
		stop
	set {_reason::*} to reversed {reports::%{_r}%::reason::*}
	set {_reporter::*} to reversed {reports::%{_r}%::reporter::*}
	set {_time::*} to reversed {reports::%{_r}%::time::*}
	remove {_reason::%{_i}%} from {_reason::*}
	remove {_reporter::%{_i}%} from {_reporter::*}
	remove {_time::%{_i}%} from {_time::*}
	set {reports::%{_r}%::reason::*} to fix({_reason::*})
	set {reports::%{_r}%::reporter::*} to fix({_reporter::*})
	set {reports::%{_r}%::time::*} to fix({_time::*})
	reports({_p},{_r},1)
	

function reverse(o:objects) :: objects:
	return reversed {_o::*}
function reports(p:player,r:player,page:number):
	open({_p},"Reports")
	format gui slot 4 of {_p} with skull of {_r} named "&c%{_r}%" to do nothing
	format gui slot 51 of {_p} with ender pearl named "&cTeleport" to run:
		if {_r} is online:
			teleport {_p} to {_r}
		else:
			send "{@Prefix}&cUser is not online"
	format gui slot 49 of {_p} with book named "&cBack to Reports" to run function menu({_p},1)
	format gui slot 47 of {_p} with barrier named "&cDelete all Reports" to run:
		verify({_p},{_r},-1)
		
	if {_page} > 1:
		format gui slot 45 of {_p} with arrow to run:
			set {_y} to {_page} - 1
			reports({_p},{_r},{_y})
			
	set {_reason::*} to reversed {reports::%{_r}%::reason::*}
	set {_reporter::*} to reversed {reports::%{_r}%::reporter::*}
	set {_time::*} to reversed {reports::%{_r}%::time::*}
	loop {_reason::*}:
		set {_b} to (loop-index parsed as number) - (27*({_page}-1))+8
		if ({_b}) is between 9 and 35:
			set {_loop} to loop-index parsed as integer
			format gui slot {_b} of {_p} with paper named "&6Report ##%loop-index%" with lore "","&7Reason: ", split({_reason::%loop-index%}),"", "&7Reported by: %{_reporter::%loop-index%}%" and "&7Date: %{_time::%loop-index%}%" to run:
				verify({_p},{_r},{_loop})
		if {_b} > 35:
			format gui slot 53 of {_p} with arrow to run:
				set {_x} to ({_page} + 1)
				reports({_p},{_r},{_x})
			exit loop
function verify(p:player,p2:player,i:integer):
	open virtual chest inventory with size 3 named "Do you want to delete the report/s?" to {_p}
	format gui slot (all numbers between 0 and 26) of {_p} with light gray glass pane named ""
	format gui slot 10 and 11 of {_p} with lime glass pane named "&aYES" to run:
		delete({_p},{_p2},{_i}) if {_i} > -1
		if {_i} < 0:
			clear {reports::%{_p2}%::*}
			removePlayer({_p2})
		menu({_p},1)
		
	format gui slot 15 and 16 of {_p} with red glass pane named "&cNO" to run:
		menu({_p},1)
		
	format gui slot 13 of {_p} with paper named "&cAre you sure?"  with lore "&7Are you sure you want" and "&7to delete the report?" to do nothing
		
# i know its weird, but it works xD
function split(list:string) :: strings:
	set {_list::*} to {_list} split at " "
	set {_n} to "&7"
	loop {_list::*}:
		set {_m} to loop-value
		while length of {_m} > 30:
			set {_n} to  "%{_n}% %first (30 - length of {_n}) characters of {_m}%"
			add {_n} to {_n::*}
			set {_n} to "&7"
			replace all first 30 characters of  {_m} with "" in {_m}
		set {_n} to "%{_n}% %{_m}%"
		if length of {_n} > 30:
			add {_n} to {_n::*}
			set {_n} to "&7"	
	add {_n} to {_n::*} if {_n} is not ""
	return {_n::*}

		
function menu(p:player,page:number):
	open({_p},"Reports Page %{_page}%")
	format gui slot 49 of {_p} with barrier named "&cClose" to run:
		close {_p}'s inventory
	if {_page} > 1:
		format gui slot 45 of {_p} with arrow to run:
			set {_y} to {_page} - 1
			reports({_p},{_r},{_y})
	loop {reports::list::*}:
		set {_b} to (loop-index parsed as number) - (27*({_page}-1))+8
		if ({_b}) is between 9 and 35:
			format gui slot {_b} of {_p} with skull of loop-value named "&6%loop-value%" with lore "&7Reports: %size of {reports::%loop-value%::reason::*}%","","&7Last Report: %{reports::%loop-value%::last}%" and "&7From: %{reports::%loop-value%::reporter::%loop-index%}%"  to run function reports({_p},loop-value,1)
		if {_b} > 35:
			format gui slot 53 of {_p} with arrow to run:
				add 1 to {_page}
				menu({_p},{_page})
			exit loop

```

```
#SkriptMinesLite skripted by: SH4D03

# Please note that this is Version 1.0 so there may be some inefficiencies or bugs
# Please report all bugs to SH4D03#7511 on discord

#Do /sml or /skriptmineslite in game for a full list of available commands


options:
	prefix: &3&lSkriptMinesLite &8|&f
	skriptname: SkriptMinesLite         #Please Enter the name of the skript file here
	color1: &f
	color2: &3































#HARD CODE
#DO NOT edit if you don't know what you are doing

on right click with stone axe:
	if player's tool is stone axe named "&3&lRegion Selection Tool" with lore "", "&fLeft Click: Select position 1", "&fRight Click: Select position 2", "" and "&3&lSkriptMinesLite":
		cancel event
		set {SkriptMinesLite::%player's uuid%::pos2} to location of clicked block
		send "&3&lSkriptMinesLite &8|&f Position 2 set to: &3%location of clicked block%" to player
on left click with stone axe:
	if player's tool is stone axe named "&3&lRegion Selection Tool" with lore "", "&fLeft Click: Select position 1", "&fRight Click: Select position 2", "" and "&3&lSkriptMinesLite":
		cancel event
		set {SkriptMinesLite::%player's uuid%::pos1} to location of clicked block
		send "&3&lSkriptMinesLite &8|&f Position 1 set to: &3%location of clicked block%" to player
command /skriptmineslite [<text>] [<text>] [<text>] [<text>]:
	permission: op	
	aliases: /sml
	trigger:
		if arg-1 is "tool":
			give player stone axe named "&3&lRegion Selection Tool" with lore "", "&fLeft Click: Select position 1", "&fRight Click: Select position 2", "" and "&3&lSkriptMinesLite"
			send "&3&lSkriptMinesLite &8|&f Left Click: &3Select position 1" to player
			send "&3&lSkriptMinesLite &8|&f Right Click: &3Select position 2" to player
		else if arg-1 is "create":
			if arg-2 is set:
				if {SkriptMinesLite::%arg-2%} is set:
					send "&3&lSkriptMinesLite &8|&f This mine already exists!" to player
					stop
				else:
					if {SkriptMinesLite::%player's uuid%::pos1} or {SkriptMinesLite::%player's uuid%::pos2} is not set:
						send "&3&lSkriptMinesLite &8|&f You must first make a region selection" to player
						send "&3&lSkriptMinesLite &8|&f Do &3/sml tool&f to get the region selection tool" to player
					else:
						set {SkriptMinesLite::%arg-2%} to arg-2
						set {SkriptMinesLite::%arg-2%::pos1} to {SkriptMinesLite::%player's uuid%::pos1}
						set {SkriptMinesLite::%arg-2%::pos2} to {SkriptMinesLite::%player's uuid%::pos2}
						set {SkriptMinesLite::%arg-2%::silentreset} to false
						set {SkriptMinesLite::%arg-2%::timer} to "None"
						set {SkriptMinesLite::%arg-2%::capacity} to 100
						set {SkriptMinesLite::%arg-2%::teleport} to {SkriptMinesLite::%arg-2%::pos1}
						send "&3&lSkriptMinesLite &8|&f Mine &3%arg-2%&f was saved!" to player
			else:
				send "&3&lSkriptMinesLite &8|&f Usage: &3/sml create <mine name>" to player
		else if arg-1 is "delete":
			if arg-2 is set:
				if {SkriptMinesLite::%arg-2%} is not set:
					send "&3&lSkriptMinesLite &8|&f This mine doesn't exists!" to player
					stop
				else:
					delete {SkriptMinesLite::%arg-2%::*}
					delete {SkriptMinesLite::%arg-2%}
					send "&3&lSkriptMinesLite &8|&f Mine &3%arg-2%&f was deleted!" to player
			else:
				send "&3&lSkriptMinesLite &8|&f Usage: &3/sml create <mine name>" to player
		else if arg-1 is "redefine":
			if arg-2 is set:
				if {SkriptMinesLite::%arg-2%} is not set:
					send "&3&lSkriptMinesLite &8|&f This mine doesn't exists!" to player
					stop
				else:
					if {SkriptMinesLite::%player's uuid%::pos1} or {SkriptMinesLite::%player's uuid%::pos2} is not set:
						send "&3&lSkriptMinesLite &8|&f You must first make a region selection" to player
						send "&3&lSkriptMinesLite &8|&f Do &3/sml tool&f to get the region selection tool" to player
					else:
						set {SkriptMinesLite::%arg-2%::pos1} to {SkriptMinesLite::%player's uuid%::pos1}
						set {SkriptMinesLite::%arg-2%::pos2} to {SkriptMinesLite::%player's uuid%::pos2}
						send "&3&lSkriptMinesLite &8|&f Mine &3%arg-2%&f was redefined!" to player
			else:
				send "&3&lSkriptMinesLite &8|&f Usage: &3/sml redefine <mine name>" to player
		else if arg-1 is "set":
			if arg-2 is set:
				if {SkriptMinesLite::%arg-2%} is not set:
					send "&3&lSkriptMinesLite &8|&f This mine doesn't exists!" to player
					stop
				else:
					set {_item} to arg-3
					replace all "_" in {_item} with " "
					set {_item} to {_item} parsed as item
					if {_item} is not block:
						send "&3&lSkriptMinesLite &8|&f Usage: &3/sml set <mine name> <blocktype> <percentage>" to player
						stop
					set {_percentage} to arg-4
					replace all "%%" in {_percentage} with ""
					set {_percentage} to {_percentage} parsed as integer
					if {_percentage} is not integer:
						send "&3&lSkriptMinesLite &8|&f Usage: &3/sml set <mine name> <blocktype> <percentage>" to player
						stop
					else if {SkriptMinesLite::%arg-2%::capacity} < {_percentage}:
						send "&3&lSkriptMinesLite &8|&f This mine doesn't have enough space. &3%{SkriptMinesLite::%arg-2%::capacity}%&3%% &fremaining" to player
						stop
					remove {_percentage} from {SkriptMinesLite::%arg-2%::capacity}
					set {_item} to "%{_item}%"
					set {SkriptMinesLite::%arg-2%::blocks::%{_item}%} to "%{_percentage}%"
					send "&3&lSkriptMinesLite &8|&f This mine is now &3%{_percentage}%&3%% %{_item}%. &3%{SkriptMinesLite::%arg-2%::capacity}%&3%% &fremaining" to player
			else:
				send "&3&lSkriptMinesLite &8|&f Usage: &3/sml set <mine name> <blocktype> <percentage>" to player
		else if arg-1 is "unset":
			if arg-2 is set:
				if {SkriptMinesLite::%arg-2%} is not set:
					send "&3&lSkriptMinesLite &8|&f This mine doesn't exists!" to player
					stop
				else:
					set {_item} to arg-3
					replace all "_" in {_item} with " "
					set {_item} to {_item} parsed as item
					if {_item} is not block:
						send "&3&lSkriptMinesLite &8|&f Usage: &3/sml unset <mine name> <blocktype> " to player
						stop
					set {_item} to "%{_item}%"
					if {SkriptMinesLite::%arg-2%::blocks::%{_item}%} is not set:
						send "&3&lSkriptMinesLite &8|&f This block does not exist in this mine" to player
						stop
					set {_percentage} to {SkriptMinesLite::%arg-2%::blocks::%{_item}%} parsed as integer
					add {_percentage} to {SkriptMinesLite::%arg-2%::capacity}
					delete {SkriptMinesLite::%arg-2%::blocks::%{_item}%}
					send "&3&lSkriptMinesLite &8|&f You unset &3%{_item}%&f. &3%{SkriptMinesLite::%arg-2%::capacity}%&3%% &fremaining" to player
			else:
				send "&3&lSkriptMinesLite &8|&f Usage: &3/sml unset <mine name> <blocktype>" to player
		else if arg-1 is "reset":
			if arg-2 is set:
				if {SkriptMinesLite::%arg-2%} is not set:
					send "&3&lSkriptMinesLite &8|&f This mine doesn't exists!" to player
					stop
				else:
					loop {SkriptMinesLite::%arg-2%::blocks::*}:
						set {_block} to loop-index parsed as item
						set {_percentage} to loop-value parsed as integer
						loop {_percentage} times:
							add {_block} to {_MineBlocks::*}
					loop blocks within block at {SkriptMinesLite::%arg-2%::pos1} and block at {SkriptMinesLite::%arg-2%::pos2}:
						set {_block} to a random element out of {_MineBlocks::*}
						set loop-block to {_block}
					if {SkriptMinesLite::%arg-2%::silentreset} is false:
						broadcast "{@prefix} {@color2}%arg-2% {@color1}was reset!"
			else:
				send "&3&lSkriptMinesLite &8|&f Usage: &3/sml reset <mine name>" to player
		else if arg-1 is "setsilent":
			if arg-2 is set:
				if {SkriptMinesLite::%arg-2%} is not set:
					send "&3&lSkriptMinesLite &8|&f This mine doesn't exists!" to player
					stop
				else:
					if {SkriptMinesLite::%arg-2%::silentreset} is false:
						set {SkriptMinesLite::%arg-2%::silentreset}  to true
						send "&3&lSkriptMinesLite &8|&3 %arg-2%&f will now reset silently." to player
					else:
						set {SkriptMinesLite::%arg-2%::silentreset} to false
						send "&3&lSkriptMinesLite &8|&3 %arg-2%&f will no longer reset silently." to player
			else:
				send "&3&lSkriptMinesLite &8|&f Usage: &3/sml setsilent <mine name>" to player
		else if arg-1 is "list":
			if {SkriptMinesLite::*} is not set:
				send "&3&lSkriptMinesLite &8|&f There are currently no mines!" to player
				stop
			else:
				send "&3&lMines:" to player
				loop {SkriptMinesLite::*}:
					send "&f -%loop-value%" to player
		else if arg-1 is "time":
			if arg-2 is set:
				if {SkriptMinesLite::%arg-2%} is not set:
					send "&3&lSkriptMinesLite &8|&f This mine doesn't exists!" to player
					stop
				else:
					set {_time} to arg-3 parsed as integer
					if {_time} is not integer:
						if arg-3 is "reset":
							set {SkriptMinesLite::%arg-2%::timer} to "None"
							delete {SkriptMinesLite::%arg-2%::lastreset}
							send "&3&lSkriptMinesLite &8|&f &3%arg-2%&f will no longer reset automatically" to player
							stop
						send "&3&lSkriptMinesLite &8|&f Usage: &3/sml time <mine name> <minutes/reset>" to player
						stop
					set {SkriptMinesLite::%arg-2%::timer} to "%{_time}% minutes" parsed as timespan
					set {SkriptMinesLite::%arg-2%::lastreset} to now
					send "&3&lSkriptMinesLite &8|&f &3%arg-2%&f will now reset every &3%{_time}% &3minutes" to player
			else:
				send "&3&lSkriptMinesLite &8|&f Usage: &3/sml time <mine name> <minutes/reset>" to player
		else if arg-1 is "teleport" or "tp":
			if arg-2 is set:
				if {SkriptMinesLite::%arg-2%} is not set:
					send "&3&lSkriptMinesLite &8|&f This mine doesn't exists!" to player
					stop
				else:
					if arg-3 is set:
						set {_player} to arg-3 parsed as offline player
					else:
						set {_player} to player
					if {_player} is not online:
						send "{@prefix} This player is not online!" to player
					else:
						send "{@prefix} Teleporting..." to {_player}
						send "{@prefix} Teleporting..." to player if {_player} != player
						teleport {_player} to {SkriptMinesLite::%arg-2%::teleport}
			else:
				send "&3&lSkriptMinesLite &8|&f Usage: &3/sml tp <mine name> [<player>]" to player
		else if arg-1 is "setteleport" or "settp":
			if arg-2 is set:
				if {SkriptMinesLite::%arg-2%} is not set:
					send "&3&lSkriptMinesLite &8|&f This mine doesn't exists!" to player
					stop
				else:
					set {SkriptMinesLite::%arg-2%::teleport} to location of player
					send "&3&lSkriptMinesLite &8|&f Mine tp was changed to: &3%location of player%" to player
			else:
				send "&3&lSkriptMinesLite &8|&f Usage: &3/sml settp <mine name>" to player
		else if arg-1 is "info" or "information":
			if arg-2 is set:
				if {SkriptMinesLite::%arg-2%} is not set:
					send "&3&lSkriptMinesLite &8|&f This mine doesn't exists!" to player
					stop
				else:
					send "" to player
					send "&f-----< &3&lSkriptMinesLite &f>-----" to player
					send "&3&lMine Name: &f%{SkriptMinesLite::%arg-2%}%" to player
					send "&3&lPosition 1: &f%{SkriptMinesLite::%arg-2%::pos1}%" to player
					send "&3&lPosition 2: &f%{SkriptMinesLite::%arg-2%::pos2}% %newline% " to player
					send "&3&lTimer: &f%{SkriptMinesLite::%arg-2%::timer}%" to player	
					send "&3&lTeleport: &f%{SkriptMinesLite::%arg-2%::teleport}%" to player
					send "&3&lSilentReset: &f%{SkriptMinesLite::%arg-2%::silentreset}%" to player
					send "&3&lCapacity: &f%{SkriptMinesLite::%arg-2%::capacity}%%% &3/&f 100%%" to player
					send "&f-----< &3&lSkriptMinesLite &f>-----" to player
					send "" to player
			else:
				send "&3&lSkriptMinesLite &8|&f Usage: &3/sml info <mine name>" to player
		else if arg-1 is "reload":
			send "&3&lSkriptMinesLite &8|&f Reloading..." to player
			execute console command "skript reload {@skriptname}"
			send "&3&lSkriptMinesLite &8|&f Successfully reloaded Version 1.0" to player
		else:
			send "" to player
			send "&f-----< &3&lSkriptMinesLite &f>-----" to player
			send " &f/sml create <mine name>" to player
			send " &f/sml delete <mine name>" to player
			send " &f/sml set <mine name> <blocktype> <percentage>" to player
			send " &f/sml redefine <mine name>" to player
			send " &f/sml unset <mine name> <blocktype>" to player
			send " &f/sml reset <mine name>" to player
			send " &f/sml setsilent <mine name>" to player
			send " &f/sml list " to player
			send " &f/sml tool" to player
			send " &f/sml time <mine name> <minutes/reset>" to player
			send " &f/sml tp <mine name> [<player>]" to player
			send " &f/sml settp <mine name>" to player
			send " &f/sml info <mine name>" to player
			send " &f/sml reload" to player
			send "&f-----< &3&lSkriptMinesLite &f>-----" to player
			send "" to player
on command "skript reload {@skriptname}":
	if executor is not console:
		cancel event
		send "&3&lSkriptMinesLite &8|&f Reloading..." to player
		execute console command "skript reload {@skriptname}"
		send "&3&lSkriptMinesLite &8|&f Successfully reloaded Version 1.0" to player
every minute:
	loop {SkriptMinesLite::*}:
		set {_time} to {SkriptMinesLite::%loop-index%::lastreset}
		if difference between {_time} and now >= {SkriptMinesLite::%loop-index%::timer}:
			execute console command "sml reset %loop-value%"
			set {SkriptMinesLite::%loop-index%::lastreset} to now
on disconnect:
	delete {SkriptMinesLite::%player's uuid%::pos1}
	delete {SkriptMinesLite::%player's uuid%::pos2}
on join:
	delete {SkriptMinesLite::%player's uuid%::pos1}
	delete {SkriptMinesLite::%player's uuid%::pos2}

```

```
# AUTHOR: 3meraldK
# VERSION: 1.1

options: #Remember that messages have to be placed between double quotes.
	delay: 3  #Spawn delay, in seconds
	cooldown: 15 #Cooldown to process /spawn command, in seconds
	safety: true #Safety mode - script finds the highest block and teleports there if it's set to true.
	move: true #If it's true teleportation will be canceled if player moves.
	spawnjoin: false #If it's set to true player will be teleported to spawn each every join.
	spawndeath: true #If it's set to true player will be teleported to spawn each every death.
	firstspawn: true #New player will be teleported to spawn if it's set (/setspawn) and if this option is set to true
	
	perm: essentials.setspawn #Permission to use /setspawn
	spawnperm: essentials.spawn #Permission to use /spawn
	
	permsg: &cError: &7Insufficient permissions. #Message if you don't have permission to use /setspawn
	spawnsetmsg: "&7Spawn has been set to &c%player's location%" #Message if an admin set a spawn
	tpmsg: "&7Successfully teleported you to spawn!" #Message if player teleports to spawn
	movemsg: "&cError: &7Teleportation canceled due to a move!" #Message if player moves, if 'move' is set to true
	nospawnmsg: "&cError: &7Spawn has been not set yet!" #Message if no spawn is set
	delspawnmsg: "&7Spawn has been &cdeleted!" #Message if /delspawn command was executed
	
	welcoming: true #Server will broadcast a welcome message for new players if it's set to true
	welcomemsg: "&7Welcome, &a%player% &7to the server!" #Message on first join to everyone
	
on first join:
	if {@welcoming} is true:
		set join message to {@welcomemsg}
	if {@firstspawn} is true:
		spawn(player)
		
on join:
	if {@spawnjoin} is true:
		spawn(player)
		
on respawn:
	wait 1 tick
	if {@spawndeath} is true:
		spawn(player)
	
function spawn(p: player):
	if {spawn.location} is set:
		if {@safety} is true:
			set {_y} to highest block at {spawn.location}
			teleport {_p} to block above {_y}
		else:
			teleport {_p} to {spawn.location}
		set {spawn.%{_p}%.lastused} to now
		send {@tpmsg} to {_p}
		
command /delspawn:
	permission: {@perm}
	permission message: {@permsg}
	trigger:
		if {spawn.location} is set:
			delete {spawn.location}
			send {@delspawnmsg}
		else:
			send {@nospawnmsg}
	
	
command /setspawn:
	permission: {@perm}
	permission message: {@permsg}
	trigger:
		set {spawn.location} to player's location
		send {@spawnsetmsg}
		
command /spawn:
	permission: {@spawnperm}
	permission message: {@permsg}
	trigger:
		if {spawn.location} isn't set:
			send {@nospawnmsg}
			stop
		set {_waited} to difference between {spawn.%player%.lastused} and now
		if {_waited} is less than {@cooldown} seconds:
			send "&cError: &7You have to wait %difference between {@cooldown} seconds and {_waited}% &7to teleport to spawn."
			stop
			
		if {@delay} > 0:
			if {@move} is true:
				send "&7Wait &a{@delay} &aseconds &7to teleport and &cdon't move!" # You can edit message there
			else:
				send "&7Wait &a{@delay} &aseconds &7to teleport!" # You can edit message there
		set {_pX} to round(player's x-coords)
		set {_pY} to round(player's y-coords)
		set {_pZ} to round(player's z-coords)
		wait {@delay} seconds
		if {@move} is true:
			if round(player's x-coords) is {_pX}: # Rounding it allows to move a little only, like in EssentialsSpawn
				if round(player's y-coords) is {_pY}:
					if round(player's z-coords) is {_pZ}:
						spawn(player)
					else:	
						send {@movemsg}
						stop
				else:
					send {@movemsg}
					stop
			else:
				send {@movemsg}
				stop
		else:
			spawn(player)

```

```
# Author: Ofus-Will#4688

# config

options:

    # the item used for selecting positions
    skwe-wand: golden axe named "&6WorldEdit Wand"

    # the permission used for all skwe related commands
    permission: skwe.use
    permission-message: &cPermission denied!

# code

function fillArea(p: player, loc1: location, loc2: location, blocks: text):
    set {_x} to -1 if x coord of {_loc1} > x coord of {_loc2} else 1
    set {_y} to -1 if y coord of {_loc1} > y coord of {_loc2} else 1
    set {_z} to -1 if z coord of {_loc1} > z coord of {_loc2} else 1
    set {_base} to {_loc1}
    set {_u} to uuid of {_p}
    set {_prior} to now

    # multiblocks with percentages
    if {_blocks} contains "%%":
        set {_percentages} to true
        loop {_blocks} split by ",":
            set {_args::*} to loop-value split by "%%"
            set {_block} to {_args::2} parsed as item
            if {_block} is set:
                set {_chance} to {_args::1} parsed as int
                if {_chance} is set:
                    add {_block} to {_elements::*}
                    set {_chance::%{_block}%} to {_chance}
                    add {_chance} to {_total}
                else:
                    send "&cInvalid percentage format" to {_p}
            else:
                send "&cOne or more of your block types were invalid" to {_p}
                stop
        if {_total} != 100:
            send "&cYour chances must add up to 100%%" to {_p}
            stop

    # multiblocks
    else if {_blocks} contains ",":
        set {_list} to true
        loop {_blocks} split by ",":
            set {_block} to loop-value parsed as item
            if {_block} is set:
                add loop-value parsed as item to {_elements::*}
            else:
                send "&cOne or more of your block types were invalid" to {_p}

    # single block
    else:
        set {_block} to {_blocks} parsed as item
        if {_block} is not set:
            send "&cBlock type invalid" to {_p}
            stop

    loop abs(x coord of {_loc1} - x coord of {_loc2}) + 1 times:
        loop abs(z coord of {_loc1} - z coord of {_loc2}) + 1 times:
            loop abs(y coord of {_loc1} - y coord of {_loc2}) + 1 times:
                add 1 to {_placed}

                set {undo::%{_u}%::%{_loc1}%} to "%block at {_loc1}%"

                # multiblocks with percentages
                if {_percentages} is set:
                    delete {_total}
                    set {_n} to random integer between 1 and 100
                    loop {_elements::*}:
                        if {_n} is between ({_total} + 1) and ({_total} + {_chance::%loop-value-4%}):
                            set block at {_loc1} to loop-value-4
                            exit 1 loop
                        add {_chance::%loop-value-4%} to {_total}

                # multiblocks
                else if {_list} is set:
                    set {_block} to random element out of {_elements::*}
                    set block at {_loc1} to {_block}

                # single block
                else:
                    set block at {_loc1} to {_block}

                add {_y} to y coord of {_loc1}
            add {_z} to z coord of {_loc1}
            set y coord of {_loc1} to y coord of {_base}
        add {_x} to x coord of {_loc1}
        set z coord of {_loc1} to z coord of {_base}

    send formatted "&d%{_placed}% blocks set in %difference between now and {_prior}%" to {_p}
        
command //undo:
    permission: {@permission}
    permission message: {@permission-message}
    trigger:
        if {undo::%player's uuid%::*} is set:
            loop {undo::%player's uuid%::*}:
                set {_args::*} to loop-index split by ":"
                set {_world} to {_args::1}
                set {_coords::*} to {_args::2} split by ","
                set {_loc} to location at ({_coords::1} parsed as num), ({_coords::2} parsed as num), ({_coords::3} parsed as num) in {_world}
                set block at {_loc} to loop-value parsed as item
            send "&dYou have undone your last edit"
            delete {undo::%player's uuid%::*}
        else:
            send "&cYou do not have any edits to undo!"

command //set [<text>]:
    permission: {@permission}
    permission message: {@permission-message}
    trigger:
        # reusability
        set {_one} to metadata "skwe-pos-one" of player
        set {_two} to metadata "skwe-pos-two" of player

        if {_one} is set:
            if {_two} is set:
                fillArea(player, {_one}, {_two}, arg-1)
            else:
                send formatted "&cYour second skwe position is not set!"
        else:
            send formatted "&cYour first skwe position is not set!"

command //wand:
    permission: {@permission}
    permission message: {@permission-message}
    trigger:
        give player {@skwe-wand}

command //cut:
    trigger:
        execute player command "//set air"

on right click:
    event-block is set
    if player's tool = {@skwe-wand}:
        if player has permission "{@permission}":
            cancel event
            set metadata "skwe-pos-one" of player to location of event-block
            send formatted "&dPosition one set to %location of event-block%"
        else:
            send "{@permission-message}"

on left click:
    event-block is set
    if player's tool = {@skwe-wand}:
        if player has permission "{@permission}":
            cancel event
            set metadata "skwe-pos-two" of player to location of event-block
            send formatted "&dPosition two set to %location of event-block%"
        else:
            send "{@permission-message}"

```

```
#SpyMaster skripted by: SH4D03




command /spy:
	permission: skript.spy
	trigger:
		if {spy::%uuid of player%} is not set:
			set {spy::%uuid of player%} to true
			send ""
			send "&9&lSpy &6» &aSpy enabled!"
			send ""
		else:
			delete {spy::%uuid of player%}
			send ""
			send "&9&lSpy &6» &cSpy disabled!"
			send ""

on command:
	if executor is console:
		loop all players where [input has permission "skript.spy"]:
			{spy::%uuid of loop-player%} is set
			send "&9&lSpy &6» &6Console used &b/%full command%" to loop-player
			stop
	executor doesn't have permission "skript.spy"
	loop all players where [input has permission "skript.spy"]:
		{spy::%uuid of loop-player%} is set
		send "&5&lSpy &6» &6%executor% &6used &b/%full command%" to loop-player

```

```
# CONFIG

options:
	# VVV This is the format for staff chat, here are what the placeholders do:
	# [PREFIX]: The prefix of the player
	# [PLAYER]: The player's name
	# [SUFFIX]: The suffix of the player
	# [MESSAGE]: The player's message
	staffchatformat: &cStaff Chat &6» &c[PREFIX] [PLAYER] [SUFFIX]&6: &f[MESSAGE]
	prefix: &7[&3SC&7]
	permission: staff.sc
	noperm: &cYou do not have permission to use this!
	# The option "scs" is what you can put at the start of your message to send it in staff chat.
	# Let's say the scs was set to "$", if you had the permission to use staffchat and typed "$ hi", it would send "hi" in staffchat!
	scs: $
	scdisable: You have disabled staff chat!
	scenable: You have enabled staff chat!
	usage: &c/sc [text]
	command: /sc
	alias: /staffchat

# END OF CONFIG, DO NOT TOUCH ANYTHING AFTER THIS UNLESS YOU KNOW WHAT YOU ARE DOING!

function stfChat(p: player, m: text):
	set {_t} to "{@staffchatformat}"
	replace all "[PREFIX]" in {_t} with {_p}'s prefix
	replace all "[PLAYER]" in {_t} with "%{_p}%"
	replace all "[SUFFIX]" in {_t} with suffix of {_p}
	replace all "[MESSAGE]" in {_t} with {_m}
	send {_t} to all players where [input has permission "{@permission}"]

chat:
	if {staffchat::*} contains player:
		cancel event
		stfChat(player, message)
	else:
		if message starts with "{@scs} ":
			if player has permission "{@permission}":
				cancel event
				stfChat(player, last (length of message - 2) characters of message)

command {@command} [<text>]:
	permission: {@permission}
	permission message: {@noperm}
	usage: {@usage}
	aliases: {@alias}
	trigger:
		stfChat(player, arg-text) if arg-text is set
		if arg-text isn't set:
			if {staffchat::*} contains player:
				remove player from {staffchat::*}
				send "{@prefix} {@scdisable}"
			else:
				add player to {staffchat::*}
				send "{@prefix} {@scenable}"

```

```
options:
		#Please Type The Name of The file you put this code into with out .sk
		# Example: StaffChat
		#The File name written on here is StaffChat Change it here  \/ \/ 
#
#
  filename: StaffChat  
#
#
  scsend: staffchat.send  
  sctoggle: staffchat.toggle  
  screcieve: staffchat.recieve
  acsend: adminchat.send  
  acrecieve: adminchat.recieve
  mcsend: modchat.send  
  mcrecieve: modchat.recieve
  hcsend: helperchat.send  
  hcrecieve: helperchat.recieve
  help: staffchat.help  
  allcmd: staffchat.*  
  reload: staffchat.reload  
  noPerms: &4No Perms  
  
  
  # Any Option that starts with SC is Normal Staff Chat
  # AC is Admin Chat
  # MC is Moderator Chat
  # HC is Helper Chat
  
command staffchat [<text>]:
  aliases: sc
  trigger:
    if arg-1 is set:
      if player has permission "{@scsend}" or "{@allcmd}":
        loop {sc::*}:
          send "&b[&6StaffChat&b] &c%player%&7: %coloured arg-1%" to loop-value
      else:
        send "{@noPerms}"
    else:
      if player has permission "{@sctoggle}" or "{@allcmd}":
        if {sctoggle::%player's uuid%} is true:
          set {sctoggle::%player's uuid%} to false
          send "&b[&6StaffChat&b] &7Staff Chat toggled &fOFF!&7"
        else if {sctoggle::%player's uuid%} is false:
          set {sctoggle::%player's uuid%} to true
          send "&b[&6StaffChat&b] &7Staff Chat toggled &aON&7!"

command helperchat [<text>]:
  aliases: hc
  trigger:
    if arg-1 is set:
      if player has permission "{@hcsend}" or "{@allcmd}":
        loop {hc::*}:
          send "&b[&dHelperChat&b] &c%player%&7: %coloured arg-1%" to loop-value
      else:
        send "{@noPerms}"

command modchat [<text>]:
  aliases: sc
  trigger:
    if arg-1 is set:
      if player has permission "{@mcsend}" or "{@allcmd}":
        loop {mc::*}:
          send "&b[&9ModChat&b] &c%player%&7: %coloured arg-1%" to loop-value
      else:
        send "{@noPerms}"

command adminchat [<text>]:
  aliases: sc
  trigger:
    if arg-1 is set:
      if player has permission "{@acsend}" or "{@allcmd}":
        loop {ac::*}:
          send "&b[&fAdminChat&b] &c%player%&7: %coloured arg-1%" to loop-value
      else:
        send "{@noPerms}"

command staffchatreload:
  permission: {@reload}
  aliases: screload
  trigger:
    send "&aStaff Chat is Reloading"
    command "sk reload {@filename}"

command staffchathelp:
  permission: {@help}
  aliases: scHelp
  trigger:
    send "&b[&6StaffChat&b] &aHelp!"
    send "&6- &7/staffchat (toggle staffChat)"
    send "&6- &7/staffchat (message) (send message to staffchat)"
    send "&6- &7/helperchat (message) (send message to HelperChat)"
    send "&6- &7/modchat (message) (send message to ModeratorChat)"
    send "&6- &7/adminchat (message) (send message to AdminChat)"
    send "&6- &7/screload (reloads StaffChat File)"
    send "&6- &7/schelp (sends this help message)"

on load:
  broadcast "&aStaffChat Reloaded!"

on join:
  if player has permission "{@allcmd}":
    add player to {ac::*}
    add player to {mc::*}
    add player to {hc::*}
    add player to {sc::*}
  else:
    if player has permission "{@hcrecieve}":
      add player to {hc::*}
    if player has permission "{@screcieve}":
      add player to {sc::*}
    if player has permission "{@mcrecieve}":
      add player to {mc::*}
    if player has permission "{@acrecieve}":
      add player to {ac::*}

on quit:
  if player has permission "{@allcmd}":
    remove player from {ac::*}
    remove player from {mc::*}
    remove player from {hc::*}
    remove player from {sc::*}
  else:
    if player has permission "{@hcrecieve}":
      remove player from {hc::*}
    if player has permission "{@screcieve}":
      remove player from {sc::*}
    if player has permission "{@mcrecieve}":
      remove player from {mc::*}
    if player has permission "{@acrecieve}":
      remove player from {ac::*}

on chat:
  if {sctoggle::%player's uuid%} is true:
    cancel event
    make player execute command "sc %message%"
  else if first character of message is "?":
    if player has permission "{@scsend}":
      cancel event
      make player execute command "sc %subtext of message from characters 2 to (length of message)%"

```

```
#SuperChat skripted by: SH4D03
#DM SH4D03#7511 on discord if you find any bugs
#All options below are configurable
#Available commands: /prefix /suffix /nickname /chat /bannedwords /chatcolor


options:

#Msges:
	prefix: &6&lSuperChat &8|&7
	player-muted-msg: &cYou are currently muted! 
	server-muted-msg: &cChat is currently muted!
	banned-word-msg: &cYour message contained a banned word!
	nick-not-allowed: &cThis nick is not allowed!
	prefix-not-allowed: &cThis prefix is not allowed!
	suffix-not-allowed: &cThis suffix is not allowed!
	nick-changed: &aSuccessfully changed nickname to: [nick] #Use [nick] to display the nickname
	prefix-changed: &aSuccessfully changed prefix to: [prefix] #Use [prefix] to display the nickname
	suffix-changed: &aSuccessfully changed suffix to: [suffix] #Use [suffix] to display the nickname
	duped-msg: &cYou are not allowed to repeat the same msg twice!

#Perms:
	chatcolor-perm: chatcolor.change
	nick-perm: nick.change
	color-nick-perm: colornick.change
	prefix-perm: prefix.change
	color-prefix-perm: colorprefix.change
	suffix-perm: suffix.change
	color-suffix-perm: colorsuffix.change
	emojis-perm: emojis.use
	banned-words-add: banned.add
	moderatorperm: chat.moderate

#Options:
	ping: &a[player]  #Use [player] to display the player who has been pinged
	default-chatcolor: &7
	chatformat: [prefix]&e[player][suffix] &6» [message]  #Use [prefix], [suffix], [player] and [message] 
	join-msg: &7(&a+&7) [player] #Use [player] to display the player
	leave-msg: &7(&c-&7) [player] #Use [player] to display the player
	duped-chat: false #Allows a player to say the same message twice in a row




































#CODE
#DO NOT edit if you do not know what you are doing


on chat:
	if {muted::%player's uuid%} is set:
		cancel event
		send "{@player-muted-msg}" to player
		stop
	else if {server-mute} is set:
		cancel event
		send "{@server-muted-msg}" to player
		stop
	else if {@duped-chat} is false:
		if {last-msg::%player's uuid%} = message:
			cancel event
			send "{@duped-msg}" to player
			stop
	
	set {last-msg::%player's uuid%} to message
	set {_words::*} to message split at " "
	loop {_words::*}:
		set {_word} to loop-value
		replace all " " in {_word} with " "
		if {banned-words::*} contains {_word}:
			cancel event
			send "{@prefix} {@banned-word-msg}" to player
			stop
	if {prefix::%player's uuid%} is set:
		set {_prefix} to "%{prefix::%player's uuid%}% "
	else:
		set {_prefix} to ""
	if {nickname::%player's uuid%} is set:
		set {_name} to {nickname::%player's uuid%}
	else:
		set {_name} to "&r%player%"
	if {suffix::%player's uuid%} is set:
		set {_suffix} to " &r%{suffix::%player's uuid%}%"
	else:
		set {_suffix} to ""
	if player has permission "{@emojis-perm}":
		replace all "<3" in message with "&r&d❤%{chat-color::%player's uuid%}%"
		replace all ":)" or "(:" in message with "&r&a☺%{chat-color::%player's uuid%}%"
		replace all ":(" or "):" in message with "&r&c☹%{chat-color::%player's uuid%}%"
		replace all ";)" in message with "&r&a-‿◕&7%{chat-color::%player's uuid%}%"
	loop all players where [message contains "%input%"]:
		set {_ping} to "{@ping}"
		replace all "[player]" in {_ping} with "%loop-player%"
		set {_ping} to "%{_ping}%%{chat-color::%player's uuid%}%"
		replace all "%loop-player%" with {_ping} in message
		play sound "entity.experience_orb.pickup" with volume 2 and pitch 16 to loop-player
	set {_chat} to "{@chatformat}"
	replace all "[prefix]" in {_chat} with {_prefix}
	replace all "[player]" in {_chat} with {_name}
	replace all "[suffix]" in {_chat} with {_suffix}
	replace all "[message]" in {_chat} with "%{chat-color::%player's uuid%}%%message%"
	set the chat format to {_chat}
				
		

on join:
	set {_join} to "{@join-msg}"
	replace all "[player]" in {_join} with "%player%"
	set the join message to {_join}
	if {chat-color::%player's uuid%} is not set:
		set {chat-color::%player's uuid%} to "{@default-chatcolor}"

on disconnect:
	set {_leave} to "{@leave-msg}"
	replace all "[player]" in {_leave} with "%player%"
	set the leave message to {_leave}


command /nickname [<text>] [<player>]:
	permission: {@nick-perm}
	aliases: /nick
	trigger:
		if arg-1 is set:
			set {_player} to player's uuid
			if arg-2 is set:
				if player is op:
					set {_player} to arg-2's uuid
			if arg-1 is "reset":
				delete {nickname::%{_player}%}
				send "{@prefix} Nickname reset!" to player
				stop
			else if {banned-words::*} contains uncolored arg-1:
				send "{@nick-not-allowed}" to player
				stop
			else if player has permission "{@color-nick-perm}":
				set {nickname::%{_player}%} to colored arg-1
				set {_nick} to "{@nick-changed}"
				replace all "[nick]" in {_nick} with {nickname::%{_player}%}
				send {_nick} to player
			else:
				set {nickname::%{_player}%} to uncolored arg-1
				set {_nick} to "{@nick-changed}"
				replace all "[nick]" in {_nick} with {nickname::%{_player}%}
				send {_nick} to player

command /prefix [<text>] [<player>]:
	permission: {@prefix-perm}
	trigger:
		if arg-1 is set:
			set {_player} to player's uuid
			if arg-2 is set:
				if player is op:
					set {_player} to arg-2's uuid
			if arg-1 is "reset":
				delete {prefix::%{_player}%}
				send "{@prefix} Prefix reset!" to player
				stop
			else if {banned-words::*} contains uncolored arg-1:
				send "{@prefix-not-allowed}" to player
				stop
			else if player has permission "{@color-prefix-perm}":
				set {prefix::%{_player}%} to colored arg-1
				set {_msg} to "{@prefix-changed}"
				replace all "[prefix]" in {_msg} with {prefix::%{_player}%}
				send {_msg} to player
			else:
				set {prefix::%{_player}%} to uncolored arg-1
				set {_msg} to "{@prefix-changed}"
				replace all "[prefix]" in {_msg} with {prefix::%{_player}%}
				send {_msg} to player

command /suffix [<text>] [<player>]:
	permission: {@suffix-perm}
	trigger:
		if arg-1 is set:
			set {_player} to player's uuid
			if arg-2 is set:
				if player is op:
					set {_player} to arg-2's uuid
			if arg-1 is "reset":
				delete {suffix::%{_player}%}
				send "{@prefix} Suffix reset!" to player
				stop
			else if {banned-words::*} contains uncolored arg-1:
				send "{@suffix-not-allowed}" to player
				stop
			else if player has permission "{@color-suffix-perm}":
				set {suffix::%{_player}%} to colored arg-1
				set {_msg} to "{@suffix-changed}"
				replace all "[suffix]" in {_msg} with {suffix::%{_player}%}
				send {_msg} to player
			else:
				set {suffix::%{_player}%} to uncolored arg-1
				set {_msg} to "{@suffix-changed}"
				replace all "[suffix]" in {_msg} with {suffix::%{_player}%}
				send {_msg} to player

command /bannedwords [<text>] [<text>]:
	permission: {@banned-words-add}
	trigger:
		if arg-1 is "add":
			if arg-2 is set:
				if {banned-words::*} contains arg-2:
					send "{@prefix} This word is already banned!" to player
				else:
					add arg-2 to {banned-words::*}
					send "{@prefix} This word has been successfully banned!" to player
			else:
				send "{@prefix} Usage: /bannedwords add <word>" to player
		else if arg-1 is "remove":
			if arg-2 is set:
				if {banned-words::*} does not contain arg-2:
					send "{@prefix} This word is not banned!" to player
				else:
					remove arg-2 from {banned-words::*}
					send "{@prefix} This word has been successfully unbanned!" to player
			else:
				send "{@prefix} Usage: /bannedwords remove <word>" to player
		else if arg-1 is "list":
			send "&3&lBanned Words:" to player
			loop {banned-words::*}:
				send "&9[&b%loop-index%&9] &3%loop-value%" to player
		else:
			send "{@prefix} Usage: %newline% &7/bannedwords add <word> %newline% &7/bannedwords remove <word> %newline% &7/bannedwords list" to player

command /chat [<text>] [<text>]:
	permission: {@moderatorperm}
	trigger:
		if arg-1 is "clear":
			loop 100 times:
				broadcast " "
			broadcast "{@prefix} Chat was cleared by: &5&l%player%"
		else if arg-1 is "mute":
			if arg-2 is not set:
				if {server-mute} is set:
					delete {server-mute}
					broadcast "{@prefix} Chat was unmuted by: &5&l%player%"
				else:
					set {server-mute} to true
					broadcast "{@prefix} Chat was muted by: &5&l%player%"
			else:
				set {_player} to arg-2 parsed as offline player
				set {_uuid} to {_player}'s uuid
				if {muted::%{_uuid}%} is set:
					delete {muted::%{_uuid}%}
					broadcast "{@prefix} %{_player}% was unmuted by: &5&l%player%"
				else:
					set {muted::%{_uuid}%} to true
					broadcast "{@prefix} %{_player}% was muted by: &5&l%player%"
		else:
			send "{@prefix} Usage: %newline% &7/chat clear %newline% &7/chat mute %newline% &7/chat mute [<player>]" to player
			


command /chatcolor:
	permission: {@chatcolor-perm}
	trigger:
		set {_inventory} to chest inventory with 2 rows named "&3&lChatColor"
		set slot 0 of {_inventory} to paper named "&0&lBlack" with lore "" and "&7Example: &0Hello!"
		set slot 1 of {_inventory} to paper named "&1&lDark Blue" with lore "" and "&7Example: &1Hello!"
		set slot 2 of {_inventory} to paper named "&2&lDark Green" with lore "" and "&7Example: &2Hello!"
		set slot 3 of {_inventory} to paper named "&3&lDark Aqua" with lore "" and "&7Example: &3Hello!"
		set slot 4 of {_inventory} to paper named "&4&lDark Red" with lore "" and "&7Example: &4Hello!" 
		set slot 5 of {_inventory} to paper named "&5&lDark Purple" with lore "" and "&7Example: &5Hello!"
		set slot 6 of {_inventory} to paper named "&6&lGold" with lore "" and "&7Example: &6Hello!"
		set slot 7 of {_inventory} to paper named "&7&lGray" with lore "" and "&7Example: &7Hello!"
		set slot 8 of {_inventory} to paper named "&8&lDark Gray" with lore "" and "&7Example: &8Hello!"
		set slot 9 of {_inventory} to paper named "&9&lBlue" with lore "" and "&7Example: &9Hello!" 
		set slot 10 of {_inventory} to paper named "&a&lGreen" with lore "" and "&7Example: &aHello!"
		set slot 11 of {_inventory} to paper named "&b&lAqua" with lore "" and "&7Example: &bHello!"
		set slot 12 of {_inventory} to paper named "&c&lRed" with lore "" and "&7Example: &cHello!"
		set slot 13 of {_inventory} to paper named "&d&lPink" with lore "" and "&7Example: &dHello!" 
		set slot 14 of {_inventory} to paper named "&e&lYellow" with lore "" and "&7Example: &eHello!" 
		set slot 15 of {_inventory} to paper named "&f&lWhite" with lore "" and "&7Example: &fHello!"
		set slot 17 of {_inventory} to barrier named "&c&lCancel" with lore "" and "&7Click to cancel!" 
		open {_inventory} to player

on inventory click:
	if event-inventory is not player's inventory:
		if event-slot is paper named "&0&lBlack" with lore "" and "&7Example: &0Hello!":
			cancel event
			set {chat-color::%player's uuid%} to "&0"
			send "{@prefix} You changed your chat color to: &0&lBlack" to player
		else if event-slot is paper named "&1&lDark Blue" with lore "" and "&7Example: &1Hello!":
			cancel event
			set {chat-color::%player's uuid%} to "&1"
			send "{@prefix} You changed your chat color to: &1&lDark Blue" to player
		else if event-slot is paper named "&2&lDark Green" with lore "" and "&7Example: &2Hello!":
			cancel event
			set {chat-color::%player's uuid%} to "&2"
			send "{@prefix} You changed your chat color to: &2&lDark Green" to player
		else if event-slot is paper named "&3&lDark Aqua" with lore "" and "&7Example: &3Hello!":
			cancel event
			set {chat-color::%player's uuid%} to "&3"
			send "{@prefix} You changed your chat color to: &3&lDark Aqua" to player
		else if event-slot is paper named "&4&lDark Red" with lore "" and "&7Example: &4Hello!":
			cancel event
			set {chat-color::%player's uuid%} to "&4"
			send "{@prefix} You changed your chat color to: &4&lDark Red" to player
		else if event-slot is paper named "&5&lDark Purple" with lore "" and "&7Example: &5Hello!":
			cancel event
			set {chat-color::%player's uuid%} to "&5"
			send "{@prefix} You changed your chat color to: &5&lDark Purple" to player
		else if event-slot is paper named "&6&lGold" with lore "" and "&7Example: &6Hello!":
			cancel event
			set {chat-color::%player's uuid%} to "&6"
			send "{@prefix} You changed your chat color to: &6&lGold" to player
		else if event-slot is paper named "&7&lGray" with lore "" and "&7Example: &7Hello!":
			cancel event
			set {chat-color::%player's uuid%} to "&7"
			send "{@prefix} You changed your chat color to: &7&lGray" to player
		else if event-slot is paper named "&8&lDark Gray" with lore "" and "&7Example: &8Hello!":
			cancel event
			set {chat-color::%player's uuid%} to "&8"
			send "{@prefix} You changed your chat color to: &8&lDark Gray" to player
		else if event-slot is paper named "&9&lBlue" with lore "" and "&7Example: &9Hello!":
			cancel event
			set {chat-color::%player's uuid%} to "&9"
			send "{@prefix} You changed your chat color to: &9&lBlue" to player
		else if event-slot is paper named "&a&lGreen" with lore "" and "&7Example: &aHello!":
			cancel event
			set {chat-color::%player's uuid%} to "&a"
			send "{@prefix} You changed your chat color to: &a&lGreen" to player
		else if event-slot is paper named "&b&lAqua" with lore "" and "&7Example: &bHello!":
			cancel event
			set {chat-color::%player's uuid%} to "&b"
			send "{@prefix} You changed your chat color to: &b&lAqua" to player
		else if event-slot is paper named "&c&lRed" with lore "" and "&7Example: &cHello!":
			cancel event
			set {chat-color::%player's uuid%} to "&c"
			send "{@prefix} You changed your chat color to: &c&lRed" to player
		else if event-slot is paper named "&d&lPink" with lore "" and "&7Example: &dHello!":
			cancel event
			set {chat-color::%player's uuid%} to "&d"
			send "{@prefix} You changed your chat color to: &d&lPink" to player
		else if event-slot is paper named "&e&lYellow" with lore "" and "&7Example: &eHello!":
			cancel event
			set {chat-color::%player's uuid%} to "&e"
			send "{@prefix} You changed your chat color to: &e&lYellow" to player
		else if event-slot is paper named "&f&lWhite" with lore "" and "&7Example: &fHello!":
			cancel event
			set {chat-color::%player's uuid%} to "&f"
			send "{@prefix} You changed your chat color to: &f&lWhite" to player
		else if event-slot is barrier named "&c&lCancel" with lore "" and "&7Click to cancel!":
			cancel event
			close inventory of player

```

```
options:	
	cooldown: 10 minutes #formated as (Amount of time) (Seconds, Minutes, days ect...)
	avoid: water or lava #Avoid spawning formated as (Block) or (Block) ect...

	worlds: "world" #worlds formated as "(World name)" or "(World name)" or "(World name)" ect...

	Permission: Surface.use #Permission
	PermissionMessage: &cYou do not have permission to use this command! #No permission message
	CommandIsNotExecuteableInWorld: &cYou can’t use this command in this world! #Can not execute command in this world message
	CooldownMessage: &CYou have to wait another %{_cooldown}% &cbefore you can execute this command again! #Cooldown message %{_cooldown}% is the time until the command is executeable again)
	BlockAvoidMessage: &cYou can't surface right now! #Called when the surface is a block to avoid message
	
Command Surface:
	permission: {@Permission}
	Permission Message: {@PermissionMessage}
	trigger:	
		if world is not {@worlds}:
			send "{@CommandIsNotExecuteableInWorld}"
		else:
			if difference between {Surface::%player%} and now is less than {@cooldown}:
				set {_cooldown} to {@cooldown}
				remove difference between {Surface::%player%} and now from {_cooldown}
				send "{@CooldownMessage}"
			else:
				wait 1 tick
				set {_loc} to location at player
				set y-coordinate of {_loc} to 255
				while block at {_loc} is air:
					remove 1 from y-coordinate of {_loc}
				loop all blocks in radius 1 of {_loc}:
					if loop-block is not {@avoid}:
						add 1 to y-coordinate of {_loc}
						teleport player to {_loc}
						set {Surface::%player%} to now 
						stop
					else:
						send "{@BlockAvoidMessage}"
						stop

```

```
# Ultra Polls

Options:
	ver: 1.0.0
	np: {@1}&lx {@2}You aren't allowed to use this command!
# DO NOT EDIT THE SETTINGS ABOVE

# CONFIG

	1: &d
	# Primary color. Default is &d (Pink)

	2: &7
	# Secondary color. Default is &7 (Gray)

# CONFIG

# CODE #

# Functions

# Events

# Commands

command /poll [<text>] [<text>]:
	aliases: /ultrapolls:/poll, /polls, /ultrapolls:polls
	usage: {@1}&lx {@2}/poll <start/end> <query>
	description: Ultra Polls main command.
	permission: ultrapolls.admin
	permission message: {@np}
	trigger:
		arg-1 = "start":
			{poll} is set:
				send "{@1}&lx {@2}There is already an active poll! Cancel it with {@1}/poll end"
			else:
				arg-2 is set:
					set {poll} to arg-2
					loop "", "{@1}&lPOLL STARTED!", "{@1}&lx {@2}%arg-2%", and "":
						send "%loop-value%" to all players
				else:
					send "{@1}&lx {@2}/poll <start/end> <query>"
		else if arg-1 = "end":
			{poll} is set:
				loop "", "{@1}&lPOLL ENDED!", "{@1}&lx {@2}%{poll}%", "{@1}&lx {@2}Results: &a%size of {poll-yes::*}%&a✔ &c%size of {poll-no::*}%&c✘", and "":
					send "%loop-value%" to all players
				delete {poll}, {poll-yes::*}, and {poll-no::*}
			else:
				send "{@1}&lx {@2}There is no active poll."
		else:
			send "{@1}&lx {@2}/poll <start/end> <query>"

command /vote [<text>]:
	aliases: /ultrapolls:vote
	usage: {@1}&lx {@2}/vote <yes/no>
	description: Ultra Polls vote command.
	permission: ultrapolls.vote
	permission message: {@np}
	trigger:
		{poll} is set:
			arg-1 is "yes" or "no":
				{poll-yes::*} contains player:
					set {_err} to true
				else if {poll-no::*} contains player:
					set {_err} to true
				{_err}:
					send "{@1}&lx {@2}You already voted!"
				else:
					add player to {poll-%uncolored arg-1%::*}
					send "{@1}&lx {@2}You voted {@1}&l%arg-1 in uppercase%{@2}."
			else:
				send "{@1}&lx {@2}/vote <yes/no>"
		else:
			send "{@1}&lx {@2}There is no active poll."

```

```
options:

  spawn-with-selector: true   # Give player's the world selector on join.

  selector-item: nether star   # Item to act as the world selector (above must be 'true')

  gui-rows: 1 # How many rows the /world GUI uses.

  logs: true # Decide whether to log player's movements using the WorldGUI.




  P: &7[&cWorld&lGUI&7] # PREFIX - DO NOT EDIT


on script load:
  if {wgui::worlds::*} is not set:
    add "" to {wgui::worlds::*}

on join:
  if {@spawn-with-selector} is true:
    give player 1 {@selector-item} named "{@P} World Selector"

on click holding {@selector-item}:
  player command "world"

command /world:
  permission: worldgui.use
  trigger:
    remove "" from {wgui::worlds::*}
    open chest with {@gui-rows} rows named "Select a world to join." to player
    set {_slot} to 0
    loop {wgui::worlds::*}:
      set slot {_slot} of player's current inventory to {wgui::icon::world::%loop-value%} named "%loop-value%" with lore "&7MOTD: &e%{wgui::motd::world::%loop-value%}%" and "&7Click to join world &3%loop-value%&7."
      add 1 to {_slot}
    add "" to {wgui::worlds::*}

on inventory click:
  if inventory name of player's current inventory is "Select a world to join.":
    if name of clicked item is set:
      console command "mvtp %player% %name of clicked item%"
      send "{@P} Sending you to world &3%name of clicked item%&7."
      if {@logs} is true:
        log "%player% has teleported to world %name of clicked item% (%time%)" to "worldgui.log"

command /worldgui:
  aliases: wgui
  permission: worldgui.admin
  trigger:
    open chest with 1 rows named "Please select an option." to player
    set slot 2 of player's current inventory to green stained glass pane named "&a&nAdd&a a world" with lore "&7Add a world to the World GUI!"
    set slot 6 of player's current inventory to red stained glass pane named "&c&nRemove&c a world" with lore "&7Remove a world from the World GUI!"

on inventory click:
  if inventory name of player's current inventory is "Please select an option.":
    cancel event
    if clicked slot is 2:
      open chest with 5 rows named "Please select a world to &a&nadd&7." to player
      set {_slot} to 0
      loop all worlds:
        if {wgui::worlds::*} does not contain loop-value:
          set slot {_slot} of player's current inventory to grass block named "%loop-value%" with lore "&7Click to &a&nadd&7 world &3%loop-value%&7 to the World GUI."
          add 1 to {_slot}
    else if clicked slot is 6:
      open chest with 5 rows named "Please select a world to &c&nremove&7." to player
      set {_slot} to 0
      remove "" from {wgui::worlds::*}
      loop {wgui::worlds::*}:
        set slot {_slot} of player's current inventory to {wgui::icon::world::%loop-value%} named "%loop-value%" with lore "&7Click to &c&nremove&7 world &3%loop-value%&7 to the World GUI."
        add 1 to {_slot}
      add "" to {wgui::worlds::*}
  if inventory name of player's current inventory is "Please select a world to &a&nadd&7.":
    cancel event
    if name of clicked item is set:
      add name of clicked item to {wgui::worlds::*}
      send "{@P} &3%name of clicked item%&7 has been added to the World GUI!"
      send ""
      send "{@P} INFORMATION NEEDED"
      send ""
      send "&7> &7Please enter in chat the &3&licon&7 for world &3%name of clicked item%&7."
      set {wgui::icon::%player's uuid%} to name of clicked item
      close player's inventory
  if inventory name of player's current inventory is "Please select a world to &c&nremove&7.":
    cancel event
    if name of clicked item is set:
      remove name of clicked item from {wgui::worlds::*}
      send "{@P} &3%name of clicked item%&7 has been removed from the World GUI!"
      player command "/wgui"

on chat:
  if {wgui::icon::%player's uuid%} is set:
    cancel event
    set {wgui::icon::world::%{wgui::icon::%player's uuid%}%} to message parsed as material
    send "%{wgui::icon::world::%{wgui::icon::%player's uuid%}%}%"
    send "{@P} Complete! &3%{wgui::icon::%player's uuid%}%&7's icon has been set to &3%message%&7! &7&o(Please not if you entered something incorrectly, you will need to remove the world from the GUI, then re-do these steps!)"
    set {wgui::motd::%player's uuid%} to {wgui::icon::%player's uuid%}
    send "{@P} Now enter the &3&lMOTD&7 for &3%{wgui::icon::%player's uuid%}%&7."
    delete {wgui::icon::%player's uuid%}
  else if {wgui::motd::%player's uuid%} is set:
    cancel event
    set {wgui::motd::world::%{wgui::motd::%player's uuid%}%} to message
    send "{@P} Setup complete! &3%{wgui::motd::%player's uuid%}%&7's MOTD has been set to &3%message%&7!"
    delete {wgui::motd::%player's uuid%}

```

```
on skript load:
	login to "xxx" with the name "beans"

function eval(t: text, u: text, c: channel):
	if {_u} is "548774680514002964" or "496477678103298052" or "235475763464372224" or "535986058991501323":
		replace all "\`\`\" with "" in {_t}
		evaluate logging errors in {_errors::*}: {_t}
		if {_errors::*} is set:
			send "Ran into a error! `%{_errors::*}%`" to {_c} with "beans"
			delete {_errors::*}

on guild message received:

	if id of event-channel is "548774680514002964":
	
		send "&3[Discord] &7%event-member%&8: &f%event-message%" to all players

	else if id of event-channel is "551546585285394443":

		sc("*%event-member%", "%event-message%")

on chat:
	wait 5 ticks
	if event isn't canceled:

		set {_p} to "%player%"
		replace all "_" with "\_" in {_p}

		send "**%{_p}%:** %message%" to channel with id "548774680514002964" with "beans"

options:
	prefix: ?, "%mention tag of event-bot% "

discord command list:
	prefixes: {@prefix}
	trigger:
		loop all players:
			set {_n} to name of loop-player
			add {_n} to {_players::*}
		send "Online players (%number of all players%/%{maxplayers}%):%nl%```%nl%%{_players::*}%%nl%```" to event-channel with event-bot

discord command staff:
	prefixes: {@prefix}
	trigger:
		loop all players:
			if loop-player has permission "rank.mod":
				set {_n} to name of loop-player
				add {_n} to {_players::*}
		send "Online Staff (%size of {_players::*}%/%number of all players%):%nl%```%nl%%{_players::*} ? ""None""%%nl%```" to event-channel with event-bot

discord command eval <text>:
	prefixes: {@prefix}
	trigger:
		eval(arg 1, id of event-user, event-channel)

discord command stats [<offlineplayer>]:
	prefixes: {@prefix}
	trigger:
		if arg 1 is not set:
			reply with "Incorrect usage... `?stats <ign>`"
		else:
			set {_uuid} to arg 1's uuid
			if {balance::%{_uuid}%} is not set:
				reply with "That player has not joined..."
			else:
				reply with "%nl%**\*** Stats **(%arg 1%)**%nl%%nl% **Rank:** %{rank::%{_uuid}%}%%nl% **Kills:** %{kills::%{_uuid}%}%%nl% **Deaths:** %{deaths::%{_uuid}%}%%nl% **K/D:** %(rounded down ({kills::%{_uuid}%}*100)/{deaths::%{_uuid}%})/100%%nl% **Money:** $%{balance::%{_uuid}%}%"

# end bot

on quit:
	set quit message to "&7%player% has disconnected."

on join:
	if {joined::%uuid of player%} is set:
		set join message to "&7%player% has connected."
		loop 700 times:
			send "&7"
		send "&7&m*---------------------------------*"
		send "&7"
		send "&f&l* &7Welcome back &6%player%&7!"
		send "&7"
		send "&7&m*---------------------------------*"
	else:
		set join message to "&7%player% has connected. &6[NEW]"
		set {joined::%uuid of player%} to true
		add 1 to {unique}
		clear player's inventory
		give player 1 elytra
		give player 1 iron pickaxe
		set {balance::%uuid of player%} to 0
		wait 5 ticks
		send "&7"
		send "&7&m*---------------------------------*"
		send "&7"
		send "&f&l* &eWelcome to beans! &6(Season 8)"
		send "&f&l* &eDo &6/shop &eto purchase items!"
		send "&f&l* &eSell items in your inventory using &6/sell&e!"
		send "&7"
		send "&f* &7&oBrought to you by the Facto network! &f*"
		send "&7"
		send "&7&m*---------------------------------*"
		set {kills::%uuid of player%} to 0
		set {deaths::%uuid of player%} to 0
		set {ks::%uuid of player%} to 0
		set {kshigh::%uuid of player%} to 0
		set {rank::%uuid of player%} to "Default"
	wait 3 ticks
	teleport player to {spawn}

on respawn:
	teleport player to {spawn}

on death of player:
	if {bounty.%uuid of victim%} is set:
		if attacker is set:
			victim is not attacker
			add {bounty.%uuid of victim%} to {balance::%uuid of attacker%}
			broadcast "&7"
			broadcast "&6[Bounty] &fThe &6&l$%{bounty.%uuid of victim%}% &fbounty on &e%victim% &fhas been claimed by &e%attacker%&f!"
			broadcast "&7"
			send "&6[Eco] &a$%{bounty.%uuid of victim%}% &7has been added to your account! &o(Claimed bounty)" to attacker
			delete {bounty.%uuid of victim%}
	if attacker is a player:

		set death message to ""

		set {_name} to name of attacker's tool
		set {_lore} to lore of attacker's tool
		replace all "||" with nl in {_lore}

		set {_enchants} to enchantments of attacker's tool

		if ("%length of {_lore}%" parsed as integer) is less than 3:
			set {_lore} to "&7No CE's"

		if {_name} is not set:
			if attacker's tool is a sword:
				set {_name} to "&ca sword"
			else if attacker's tool is a axe:
				set {_name} to "&can axe"
			else if attacker's tool is a bow:
				set {_name} to "&carchery"
			else:
				set {_name} to "&ca tool"
			
		set {_weapon} to "<tooltip:&7%{_enchants} ? ""No Enchantments""%%nl%%{_lore}%>%{_name}%"

		set {_ran} to random integer between 1 and 5
		if {_ran} = 1:
			send "&c%victim% &7was roasted by &c%attacker%&7 using &c%{_weapon}%&7!" to all players
		if {_ran} = 2:
			send "&c%victim% &7was slain by &c%attacker%&7 using &c%{_weapon}%&7!" to all players
		if {_ran} = 3:
			send "&c%victim% &7took an L from &c%attacker%&7 using &c%{_weapon}%&7!" to all players
		if {_ran} = 4:
			send "&c%victim% &7was killed by &c%attacker%&7 using &c%{_weapon}%&7!" to all players
		if {_ran} = 5:
			send "&c%victim% &7was smashed to bits by &c%attacker%&7 using &c%{_weapon}%&7!" to all players
		add 1 to {kills::%uuid of attacker%}
		add 1 to {ks::%uuid of attacker%}
		if {ks::%uuid of attacker%} is greater than {kshigh::%uuid of attacker%}:
			set {kshigh::%uuid of attacker%} to {ks::%uuid of attacker%}
		add 1 to {deaths::%uuid of victim%}
		if {ks::%uuid of victim%} is set:
			set {ks::%uuid of victim%} to 0
			send "&6[Killstreaks] &7You've lost your killstreak of &c%{ks::%uuid of victim%}%&7." to victim
		set {_victim} to {balance::%victim's uuid%} / 100
		add {_victim} to {balance::%attacker's uuid%}
		remove {_victim} from {balance::%victim's uuid%}
		send "&6[Death] &7You lost &c$%{_victim}%&7." to victim
		send "&6[Kill] &7You gained &a$%{_victim}%&7." to attacker
	else:
		set death message to "&c%victim% &7died"
		set {ks::%uuid of victim%} to 0
		add 1 to {deaths::%uuid of victim%}
		send "&6[Killstreaks] &7You've lost your killstreak of &c%{ks::%uuid of victim%}%&7." to victim

on damage:
	if damage cause is fall or suffocation:
		cancel event

on server ping:
	set {maxPlayers} to max player count

on store:
	if name of player's inventory contains "Shop >":
		cancel event

on sign change:
	if line 1 of event-block is "[Disposal]":
		if player has permission "rank.admin":
			set line 1 of event-block to "&7"
			set line 2 of event-block to "&6[Disposal]"
			set line 3 of event-block to "&eRight click"
			set line 4 of event-block to "&7"

on right-click:
	if line 2 of event-block is "&6[Disposal]":
		make player execute command "/trash"

on stepping on a pressure plate:
	"%region at location of player%" is "spawn in world %world%"
	wait 8 ticks
	push player forwards at speed 3
	push player upwards at speed 2

every 1 second:
	loop all players:
		if {rank::%loop-player's uuid%} is not set:
			set {rank::%loop-player's uuid%} to "default"
		set tab header to "%nl%&f&l* &6Beans &f&l*%nl%        &7Elytra, pvp and mining      %nl% &7&l&m*&7 FaactoNetwork &7&l&m*%nl%" and footer to "%nl%&7(&nSeason 8&7)%nl%%nl%&f&l* &6Online: &f%number of all players%&e/&f%{maxPlayers}% &f&l*%nl%&7" for loop-player
		if {bounty.%uuid of loop-player%} is set:
			set tablist name of loop-player to " %{ranks::%{rank::%loop-player's uuid%}%}%%loop-player% &6&l$%{bounty.%uuid of loop-player%}%"
		else:
			set tablist name of loop-player to " %{ranks::%{rank::%loop-player's uuid%}%}%%loop-player%"
	add 1 to {scoreboard_timer}
	if {scoreboard_timer} is greater than or equal to 5:
		set {scoreboard_timer} to 0
		loop all players:
			set {_time} to now
			wipe loop-player's sidebar
			set name of sidebar of loop-player to "&6Beans &7(&nSeason 8&7)"
			set score "&1" in sidebar of loop-player to 10
			set score "&6[Personal]" in sidebar of loop-player to 9
			set score "  &eRank: &f%{rank::%uuid of loop-player%}%" in sidebar of loop-player to 8
			set score "  &eBalance: &a$%{balance::%uuid of loop-player%}%" in sidebar of loop-player to 7
			set score "&2" in sidebar of loop-player to 6
			set score "&6[Stats]" in sidebar of loop-player to 5
			set score "  &eKD: &a%{kills::%uuid of loop-player%}%&f/&c%{deaths::%uuid of loop-player%}%" in sidebar of loop-player to 4
			set score "  &eKS: &f%{ks::%uuid of loop-player%}% &7(&6%{kshigh::%uuid of loop-player%}%&7)" in sidebar of loop-player to 3
			set score "&3" in sidebar of loop-player to 2
			set score "&7&m*&7&o (FactoNetwork) &7&m*" in sidebar of loop-player to 1

every 3 minutes:
	set {_i} to a random integer between 1 and 2
	if {_i} is 1:
		all players command "/discord"
	else if {_i} is 2:
		send "" to all players
		send "&ebuy stuff from our store with &6/buy &e:O" to all players
		send "" to all players

command /tutorial:
	trigger:
		if {tutorial::%uuid of player%} does not exist:
			hide the player from all players
			loop 100 times:
				send "&r"
			send "&6[Tutorial] &7Welcome to &ebeans season 8&7."
			play "ENTITY_PLAYER_LEVELUP" to player at volume 10
			wait 5 seconds

			loop 100 times:
				send "&r"
			teleport player to {tutorial}
			send "&6[Tutorial] &7Beans is an &eelytra, pvp and mining &7server, developed by the &eFactoNetwork &7team." to player
			play "ENTITY_PLAYER_LEVELUP" to player at volume 10
			wait 5 seconds

			loop 100 times:
				send "&r"
			teleport player to {spawn}
			send "&6[Tutorial] &7This is our spawn, you &erespawn &7here everytime you are &ckilled &7or execute /spawn. You can also &esell &7items and do other things in this area." to player
			play "ENTITY_PLAYER_LEVELUP" to player at volume 10
			wait 7.5 seconds


			loop 100 times:
				send "&r"
			send "&6[Tutorial] &7Welcome to beans &eseason 8&7, if you have any more &fquestions &7feel free to ask around." to player
			send "&r"
			send "&6[Eco] &a$1000 &7has been added to your account! &o(Finished tutorial!)" to player
			teleport player to {spawn}
			add 1000 to {balance::%uuid of player%}
			set {tutorial::%uuid of player%} to true
			reveal the player from all players

command /discord [<text>]:
	trigger:
		send "&f&l* &eJoin the discord! <tooltip:&eClick me!><link:https://discord.gg/8kqCk3G>&6Click me!"

command /spawn [<text>]:
	trigger:
		teleport player to {spawn}
		send "&6[Warps] &7You've been teleported to spawn."

command /help [<number>] [<text>]:
	trigger:
		if arg 1 is not set:
			send ""
			send "&f&l* &eHelp &7(1/2)"
			send ""
			send " &6/help: &elist of commands"
			send " &6/tutorial: &eserver tutorial"
			send " &6/discord: &elink to our discord"
			send " &6/quests: &eview your quests"
			send " &6/staff: &eview the current online staff"
			send ""
		else if arg 1 is set:
			if arg 1 is 1:
				player command "/help"
			else if arg 1 is 2:
				send ""
				send "&f&l* &eHelp &7(2/2)"
				send ""
				send " &6/shop: &eserver shop"
				send " &6/balance: &eview your money"
				send " &6/pay: &epay a user money"
				send " &6/bounty: &ebounty management"
				send " &6/baltop: &eview the richest users"
				send ""
			else if arg 1 is not 1 or 2:
				player command "/help"

# end beans.sk

function sc(p: text, t: text):
	send "&a[STAFF] &7%{_p}%&8: &a%{_t}%" to all players where [input has permission "rank.mod" or "rank.helper"]
	send "`[STAFF]` **%{_p}%:** %{_t}%" to channel with id "551546585285394443" with "beans"

function ac(p: player, t: text):
	send "&b[ADMIN] &7%{_p}%&8: &b%{_t}%" to all players where [input has permission "rank.admin"]

command /sc [<text>]:
	aliases: /staffchat
	permission: rank.helper
	permission message: &cYou don't have access to that command.
	trigger:
		if arg 1 is not set:
			send "&cUsage: /staffchat <toggle | message ...>"
		else:
			if arg 1 is "toggle":
				if {sc::%player's uuid%} is not set:
					set {sc::%player's uuid%} to true
					send "&7Enabled staff chat."
				else:
					delete {sc::%player's uuid%}
					send "&7Disabled staff chat."
			else:
				sc(name of player, arg 1)

command /ac [<text>]:
	aliases: /adminchat
	permission: rank.srmod
	permission message: &cYou don't have access to that command.
	trigger:
		if arg 1 is not set:
			send "&cUsage: /adminchat <toggle | message ...>"
		else:
			if arg 1 is "toggle":
				if {ac::%player's uuid%} is not set:
					set {ac::%player's uuid%} to true
					send "&7Enabled admin chat."
				else:
					delete {ac::%player's uuid%}
					send "&7Disabled admin chat."
			else:
				ac(player, arg 1)

on chat:
	set chat format to "%{ranks::%{rank::%player's uuid%}%}%%player% &8» &f%message%"
	if {ac::%player's uuid%} is set:
		cancel event
		ac(player, message)
	else:
		if {sc::%player's uuid%} is set:
			cancel event
			sc(name of player, message)
		else:
			player does not have permission "rank.mod"
			if {chat} is set:
				cancel event
				send "&6[Beans] &7Chat is current muted by &e%{chat}%&7. &6[%{chat::reason}%]"
			else:
				if {message::%player's uuid%} is message:
					cancel event
					send "&6[Beans] &7Please don't repeat messages."
				else:
					set {message::%player's uuid%} to message
					if {mute::%player's uuid%} is set:
						cancel event
						send "&7You are currently muted by &6%{mute::staff::%player's uuid%}%&7. &e[%{mute::%player's uuid%}%]"
					else:
						set {_m} to message
						if first 5 characters of {_m} is "%{message}%":
							add 1 to {attempts}
							if {attempts} is greater than or equal to 5:
								set {chat} to "Console"
								set {chat::reason} to "Possible spam bots detected."
								send "" to all players
								send "&6[Beans] &7Chat has been muted. Possible spam bots detected." to all players
								send "" to all players			
								wait 30 seconds
								if {chat} is "Console":
									delete {chat}
									delete {chat::reason}
									send "" to all players
									send "&6[Beans] &7Chat has been unmuted." to all players
									send "" to all players	
						else:
							delete {attempts}	
						set {message} to first 4 characters of {_m}
					
			
command /chat [<text>] [<text>]:
	permission: rank.mod
	permission message: &cYou don't have access to that command
	trigger:
		if arg 1 is not set:
			send "&cUsage: /chat <mute | clear>"
		else:
			if arg 1 is not "mute" or "clear":
				player command "/chat"
			else if arg 1 is "mute":
				if {chat} is set:
					delete {chat}
					delete {chat::reason}
					send "" to all players
					send "&6[Beans] &7Chat has been unmuted by &e%player%&7." to all players
					send "" to all players
				else:
					if arg 2 is not set:
						player command "/chat"
					else:
						set {chat} to player
						set {chat::reason} to arg 2
						send "" to all players
						send "&6[Beans] &7Chat has been muted by &e%player%&7. &6[%arg 2%]" to all players
						send "" to all players						
			if arg 1 is "clear":
				loop 300 times:
					send "" to all players where [input does not have permission "rank.mod" or "rank.helper"]
				send "" to all players
				send "&6[Beans] &7Chat has been cleared by &e%player%&7." to all players
				send "" to all players

# end chat.sk

on rightclick on sign:
	if line 2 of event-block is "&6[Repair]":
		if {balance::%player's uuid%} is greater than or equal to 5000:
			if durability of player's tool is greater than 0:
				remove 5000 from {balance::%player's uuid%}
				repair player's tool by 10000
				send "&6[Repair] &7Successfully repaired your tool."
			else:
				send "&6[Repair] &7I can't repair that tool..."
		else:
			play "ENTITY_VILLAGER_NO" to player at volume 10000
			send "&6[Repair] &7You don't have enough money for that!"

command /shop [<text>] [<text>]:
	trigger:
		if arg-1 is set:
			play "ENTITY_ENDERDRAGON_FLAP" to player at volume 10000
			if arg-1 is "Combat":
				open virtual chest inventory with size 3 named "&8Shop > Combat" to player
				wait 1 tick
				format gui slot 0 of player with feather named "&c&lBACK" to run:
					
					make player execute command "/shop"
				format gui slot 4 of player with emerald named "&a&lBALANCE&f: &6$%{balance::%uuid of player%}%" to do nothing
				format gui slot 10 of player with diamond helmet named "&bDiamond helmet &7(&n$400&7)" with lore "&f%nl%&f&l* &7Right click to buy!%nl%&7" to run:
					
					if {balance::%uuid of player%} is greater than or equal to 400:
						play "BLOCK_NOTE_PLING" to player at volume 10000
						remove 400 from {balance::%uuid of player%}
						give player 1 diamond helmet
						send "&6[Shop] &7You've purchased &f1x Diamond helmet &7for &e$400"
					else:
						play "ENTITY_VILLAGER_NO" to player at volume 10000
						send "&6[Shop] &7You don't have enough money for that!"
				format gui slot 11 of player with diamond chestplate named "&bDiamond chestplate &7(&n$500&7)" with lore "&f%nl%&f&l* &7Right click to buy!%nl%&7" to run:
					
					if {balance::%uuid of player%} is greater than or equal to 500:
						play "BLOCK_NOTE_PLING" to player at volume 10000
						remove 500 from {balance::%uuid of player%}
						give player 1 diamond chestplate
						send "&6[Shop] &7You've purchased &f1x Diamond chestplate &7for &e$500"
					else:
						play "ENTITY_VILLAGER_NO" to player at volume 10000
						send "&6[Shop] &7You don't have enough money for that!"
						
				format gui slot 12 of player with diamond leggings named "&bDiamond leggings &7(&n$400&7)" with lore "&f%nl%&f&l* &7Right click to buy!%nl%&7" to run:
					
					if {balance::%uuid of player%} is greater than or equal to 400:
						play "BLOCK_NOTE_PLING" to player at volume 10000
						remove 400 from {balance::%uuid of player%}
						give player 1 diamond leggings
						send "&6[Shop] &7You've purchased &f1x Diamond leggings &7for &e$400"
						
					else:
						play "ENTITY_VILLAGER_NO" to player at volume 10000
						send "&6[Shop] &7You don't have enough money for that!"
						
				format gui slot 13 of player with diamond boots named "&bDiamond boots &7(&n$350&7)" with lore "&f%nl%&f&l* &7Right click to buy!%nl%&7" to run:
					
					if {balance::%uuid of player%} is greater than or equal to 350:
						play "BLOCK_NOTE_PLING" to player at volume 10000
						remove 350 from {balance::%uuid of player%}
						give player 1 diamond boots
						send "&6[Shop] &7You've purchased &f1x Diamond helmet &7for &e$350"
						
					else:
						play "ENTITY_VILLAGER_NO" to player at volume 10000
						send "&6[Shop] &7You don't have enough money for that!"
						
				format gui slot 14 of player with diamond sword named "&bDiamond sword &7(&n$500&7)" with lore "&f%nl%&f&l* &7Right click to buy!%nl%&7" to run:
					
					if {balance::%uuid of player%} is greater than or equal to 500:
						play "BLOCK_NOTE_PLING" to player at volume 10000
						remove 500 from {balance::%uuid of player%}
						give player 1 diamond sword
						send "&6[Shop] &7You've purchased &f1x Diamond sword &7for &e$500"
						
					else:
						play "ENTITY_VILLAGER_NO" to player at volume 10000
						send "&6[Shop] &7You don't have enough money for that!"
						
				format gui slot 15 of player with bow named "&bBow &7(&n$500&7)" with lore "&f%nl%&f&l* &7Right click to buy!%nl%&7" to run:
					
					if {balance::%uuid of player%} is greater than or equal to 500:
						play "BLOCK_NOTE_PLING" to player at volume 10000
						remove 500 from {balance::%uuid of player%}
						give player 1 bow
						send "&6[Shop] &7You've purchased &f1x Bow &7for &e$500"
						
					else:
						play "ENTITY_VILLAGER_NO" to player at volume 10000
						send "&6[Shop] &7You don't have enough money for that!"
						
				format gui slot 16 of player with arrows named "&b&n16x&b Arrows &7(&n$100&7)" with lore "&f%nl%&f&l* &7Right click to buy!%nl%&7" to run:
					
					if {balance::%uuid of player%} is greater than or equal to 100:
						play "BLOCK_NOTE_PLING" to player at volume 10000
						remove 100 from {balance::%uuid of player%}
						give player 16 arrows
						send "&6[Shop] &7You've purchased &f16x Arrows &7for &e$100"
						
					else:
						play "ENTITY_VILLAGER_NO" to player at volume 10000
						send "&6[Shop] &7You don't have enough money for that!"
						
			if arg-1 is "Tools":
				open virtual chest inventory with size 3 named "&8Shop > Tools" to player
				wait 1 tick
				format gui slot 0 of player with feather named "&c&lBACK" to run:
					
					make player execute command "/shop"
				format gui slot 4 of player with emerald named "&a&lBALANCE&f: &6$%{balance::%uuid of player%}%" to do nothing
				format gui slot 10 of player with diamond pickaxe named "&bDiamond pickaxe &7(&n$250&7)" with lore "&f%nl%&f&l* &7Right click to buy!%nl%&7" to run:
					
					if {balance::%uuid of player%} is greater than or equal to 250:
						play "BLOCK_NOTE_PLING" to player at volume 10000
						remove 250 from {balance::%uuid of player%}
						give player 1 diamond pickaxe
						send "&6[Shop] &7You've purchased &f1x Diamond pickaxe &7for &e$250"
						
					else:
						play "ENTITY_VILLAGER_NO" to player at volume 10000
						send "&6[Shop] &7You don't have enough money for that!"
						
				format gui slot 11 of player with diamond axe named "&bDiamond axe &7(&n$150&7)" with lore "&f%nl%&f&l* &7Right click to buy!%nl%&7" to run:
					
					if {balance::%uuid of player%} is greater than or equal to 150:
						play "BLOCK_NOTE_PLING" to player at volume 10000
						remove 150 from {balance::%uuid of player%}
						give player 1 diamond axe
						send "&6[Shop] &7You've purchased &f1x Diamond axe &7for &e$150"
						
					else:
						play "ENTITY_VILLAGER_NO" to player at volume 10000
						send "&6[Shop] &7You don't have enough money for that!"
						
				format gui slot 12 of player with diamond shovel named "&bDiamond shovel &7(&n$100&7)" with lore "&f%nl%&f&l* &7Right click to buy!%nl%&7" to run:
					
					if {balance::%uuid of player%} is greater than or equal to 100:
						play "BLOCK_NOTE_PLING" to player at volume 10000
						remove 100 from {balance::%uuid of player%}
						give player 1 diamond shovel
						send "&6[Shop] &7You've purchased &f1x Diamond shovel &7for &e$100"
						
					else:
						play "ENTITY_VILLAGER_NO" to player at volume 10000
						send "&6[Shop] &7You don't have enough money for that!"
						
			if arg-1 is "Blocks":
				open virtual chest inventory with size 3 named "&8Shop > Blocks" to player
				wait 1 tick
				format gui slot 0 of player with feather named "&c&lBACK" to run:
					
					make player execute command "/shop"
				format gui slot 4 of player with emerald named "&a&lBALANCE&f: &6$%{balance::%uuid of player%}%" to do nothing
				format gui slot 10 of player with oak log named "&6&n64x&6 Wood &7(&n$100&7)" with lore "&f%nl%&f&l* &7Right click to buy!%nl%&7" to run:
					
					if {balance::%uuid of player%} is greater than or equal to 100:
						play "BLOCK_NOTE_PLING" to player at volume 10000
						remove 250 from {balance::%uuid of player%}
						give player 64 oak log
						send "&6[Shop] &7You've purchased &f64x Oak Log &7for &e$100"
						
					else:
						play "ENTITY_VILLAGER_NO" to player at volume 10000
						send "&6[Shop] &7You don't have enough money for that!"
						
				format gui slot 11 of player with stone named "&6&n64x&6 Stone &7(&n$100&7)" with lore "&f%nl%&f&l* &7Right click to buy!%nl%&7" to run:
					
					if {balance::%uuid of player%} is greater than or equal to 100:
						play "BLOCK_NOTE_PLING" to player at volume 10000
						remove 250 from {balance::%uuid of player%}
						give player 64 stone
						send "&6[Shop] &7You've purchased &f64x Stone &7for &e$100"
						
					else:
						play "ENTITY_VILLAGER_NO" to player at volume 10000
						send "&6[Shop] &7You don't have enough money for that!"
						
			if arg-1 is "Misc":
				open virtual chest inventory with size 3 named "&8Shop > Misc" to player
				wait 1 tick
				format gui slot 0 of player with feather named "&c&lBACK" to run:
					
					make player execute command "/shop"
				format gui slot 4 of player with emerald named "&a&lBALANCE&f: &6$%{balance::%uuid of player%}%" to do nothing
				format gui slot 10 of player with golden apple named "&6Golden apple &7(&n$50&7)" with lore "&f%nl%&f&l* &7Right click to buy!%nl%&7" to run:
					
					if {balance::%uuid of player%} is greater than or equal to 50:
						play "BLOCK_NOTE_PLING" to player at volume 10000
						remove 50 from {balance::%uuid of player%}
						give player 1 golden apple
						send "&6[Shop] &7You've purchased &f1x Golden apple &7for &e$50"
						
					else:
						play "ENTITY_VILLAGER_NO" to player at volume 10000
						send "&6[Shop] &7You don't have enough money for that!"
						
				format gui slot 11 of player with bottles o' enchanting named "&6&n100 &6XP &7(&n$200&7)" with lore "&f%nl%&f&l* &7Right click to buy!%nl%&7" to run:
					if {balance::%uuid of player%} is greater than or equal to 200:
						play "BLOCK_NOTE_PLING" to player at volume 10000
						remove 200 from {balance::%uuid of player%}
						give 100 xp to player
						send "&6[Shop] &7You've purchased &f100xp &7for &e$200"
						
					else:
						play "ENTITY_VILLAGER_NO" to player at volume 10000
						send "&6[Shop] &7You don't have enough money for that!"

				format gui slot 20 of player with bottles o' enchanting named "&6&n500 &6XP &7(&n$1000&7)" with lore "&f%nl%&f&l* &7Right click to buy!%nl%&7" to run:
					if {balance::%uuid of player%} is greater than or equal to 1000:
						play "BLOCK_NOTE_PLING" to player at volume 10000
						remove 1000 from {balance::%uuid of player%}
						give 500 xp to player
						send "&6[Shop] &7You've purchased &f500xp &7for &e$1000"
						
					else:
						play "ENTITY_VILLAGER_NO" to player at volume 10000
						send "&6[Shop] &7You don't have enough money for that!"
						
				format gui slot 12 of player with firework named "&6&n32x&6 Fireworks &7(&n$100&7)" with lore "&f%nl%&f&l* &7Right click to buy!%nl%&7" to run:
					
					if {balance::%uuid of player%} is greater than or equal to 100:
						play "BLOCK_NOTE_PLING" to player at volume 10000
						remove 100 from {balance::%uuid of player%}
						give player 32 firework
						send "&6[Shop] &7You've purchased &f32x Fireworks &7for &e$100"
						
					else:
						play "ENTITY_VILLAGER_NO" to player at volume 10000
						send "&6[Shop] &7You don't have enough money for that!"
						
				format gui slot 13 of player with lapis named "&6&n64x&6 Lapis &7(&n$200&7)" with lore "&f%nl%&f&l* &7Right click to buy!%nl%&7" to run:
					
					if {balance::%uuid of player%} is greater than or equal to 200:
						play "BLOCK_NOTE_PLING" to player at volume 10000
						remove 200 from {balance::%uuid of player%}
						give player 64 lapis
						send "&6[Shop] &7You've purchased &f64x Lapis &7for &e$200"
						
					else:
						play "ENTITY_VILLAGER_NO" to player at volume 10000
						send "&6[Shop] &7You don't have enough money for that!"
						
				format gui slot 14 of player with elytra named "&6&n1x&6 Elytra &7(&n$100&7)" with lore "&f%nl%&f&l* &7Right click to buy!%nl%&7" to run:
					
					if {balance::%uuid of player%} is greater than or equal to 100:
						play "BLOCK_NOTE_PLING" to player at volume 10000
						remove 100 from {balance::%uuid of player%}
						give player 1 elytra
						send "&6[Shop] &7You've purchased &f1x Elytra &7for &e$100"
						
					else:
						play "ENTITY_VILLAGER_NO" to player at volume 10000
						send "&6[Shop] &7You don't have enough money for that!"

				format gui slot 15 of player with ender pearl named "&6&n4x&6 Ender Pearl &7(&n$1200&7)" with lore "&f%nl%&f&l* &7Right click to buy!%nl%&7" to run:
					
					if {balance::%uuid of player%} is greater than or equal to 1200:
						play "BLOCK_NOTE_PLING" to player at volume 10000
						remove 1200 from {balance::%uuid of player%}
						give player 4 ender pearls
						send "&6[Shop] &7You've purchased &f4x Ender Pearl &7for &e$1200"
						
					else:
						play "ENTITY_VILLAGER_NO" to player at volume 10000
						send "&6[Shop] &7You don't have enough money for that!"
						
	
		else:
			play "ENTITY_ENDERDRAGON_FLAP" to player at volume 10000
			open virtual chest inventory with size 3 named "&8Shop > Main" to player
			wait 1 tick
			format gui slot 10 of player with iron sword named "&6&lCOMBAT &7(Right click)" to run:
				
				make player execute command "/shop Combat"
			format gui slot 12 of player with iron pickaxe named "&6&lTOOLS &7(Right click)" to run:
				
				make player execute command "/shop Tools"
			format gui slot 14 of player with oak log named "&6&lBLOCKS &7(Right click)" to run:
				
				make player execute command "/shop Blocks"
			format gui slot 16 of player with firework rocket named "&6&lMISC &7(Right click)" to run:
				
				make player execute command "/shop Misc"
			format gui slot 4 of player with emerald named "&a&lBALANCE&f: &6$%{balance::%uuid of player%}%" to do nothing


command /eco [<offline player>] [<text>] [<integer>]:
	permission: rank.admin
	trigger:
		if arg 1 is not set:
			send "&cUsage: /eco <player> <add|remove|set> <amount>"
		else:
			if arg 2 is not "add" or "remove" or "set":
				player command "/eco"
			else if arg 2 is "set":
				send "&6[Economy] &7You set %arg 1%'s balance to &e$%arg 3%&7."
				set {balance::%arg 1's uuid%} to arg 3
			else if arg 2 is "add":
				send "&6[Economy] &7You added &3$%arg 3% &7to %arg 1%'s balance."
				add arg 3 to {balance::%arg 1's uuid%}
			else if arg 2 is "remove":
				send "&6[Economy] &7You removed &3$%arg 3% &7from %arg 1%'s balance."
				remove arg 3 from {balance::%arg 1's uuid%}

command /balance [<offline player>] [<text>]:
	aliases: /bal
	trigger:
		if arg 1 is not set:
			send "&6[Balance] &7You have a balance of &e$%{balance::%uuid of player%}%&7."
		else:
			if {balance::%arg 1's uuid%} is not set:
				send "&cThat player has not joined before."
			else:
				send "&6[Balance] &7%arg 1% has a balance of &e$%{balance::%uuid of arg 1%}%&7."

command /pay [<offline player>] [<integer>] [<text>]:
	trigger:
		if arg 2 is not set:
			send "&cUsage: /pay <player> <amount greater than 100>"
		else:
			if {balance::%arg 1's uuid%} is not set:
				send "&cThat player has not joined before."
			else:
				if arg 2 is less than 100:
					player command "/pay"
				else:
					if arg 2 is greater than {balance::%player's uuid%}:
						send "&cYou don't have that much money!"
					else:
						remove arg 2 from {balance::%player's uuid%}
						add arg 2 to {balance::%arg 1's uuid%}
						send "&6[Pay] &7You've given %arg-1% an amount of &e$%arg-2%&7."
						send "&6[Pay] &7You've received &e$%arg-2% &7from %player%." to arg 1

command /bounty [<offline player>] [<integer>]:
	trigger:
		if arg 2 is not set:
			send "&cUsage: /bounty <player> <amount>"
		else:
			if arg 1 is not online:
				send "&cThat player is offline."
			else:
				if arg 2 is less than 10000:
					send "&cYou must set at least a $10000 bounty."
				else:
					if {balance::%player's uuid%} is less than arg 2:
						send "&cYou don't have that much money."
					else:
						remove arg 2 from {balance::%player's uuid%}
						add arg 2 to {bounty.%arg 1's uuid%}
						send "&7$%arg 2% has been removed from your account."
						send "" to all players
						send "&6[Bounty] &e%player% &7set a bounty of &e$%arg 2% &7on &e%arg 1%&7." to all players
						send "" to all players

command /baltop [<text>]:
	trigger:
		loop {balance::*}:
			add 1 to {_size}
			if {_low.to.high.list::%loop-value%} is not set:
				set {_low.to.high.list::%loop-value%} to loop-index
			else:
				set {_n} to 0
				loop {_size} times:
					set {_n} to {_n}+1
					{_low.to.high.list::%loop-value-1%.%{_n}%} is not set
					set {_low.to.high.list::%loop-value-1%.%{_n}%} to loop-index
					stop loop
		wait 1 tick
		set {_n} to size of {_low.to.high.list::*}
		loop {_low.to.high.list::*}:
			set {_high.to.low.list::%{_n}%} to loop-value
			set {_n} to {_n}-1
		wait 1 tick
		set {_i} to 0
		send "&7"
		send "&f&l* &eTop 5 Richest Players &f&l*"
		send "&7"
		loop {_high.to.low.list::*}:
			add 1 to {_topnumber}
			set {_player} to "%loop-value%" parsed as offlineplayer
			send "&6##%{_topnumber}% &7%{_player}% &f($%{balance::%loop-value%}%)"
			add 1 to {_i}
			if {_topnumber} > 4:
				stop loop
		set {_time} to now
		send "&7"
		send "&7&o(Last updated %{_time}%)"
		send "&7"

# end economy.sk

on food level change:
	cancel event
	set player's food level to 20

command /fly [<text>]:
	permission: rank.admin
	permission message: &cYou cannot use this command
	trigger:
		if player's flight mode is false:
			send "&6[Staff] &7You've enabled &6Fly"
			set player's fly mode to true
		else if player's flight mode is true:
			send "&6[Staff] &7You've disabled &6Fly"
			set player's fly mode to false

command /invsee [<offlineplayer>]:
	usage: &c/invsee <player>
	permission: rank.helper
	trigger:
		if arg 1 is not set:
			send "&cUsage: /invsee <player>"
		else:
			if player has permission "rank.mod":
				show arg 1's inventory to player
			else:
				open arg 1's inventory to player
			send "&6[Staff] &7You've opened &6%arg 1%'s &7inventory"

command /tp [<offlineplayer>] [<text>]:
	permission: rank.helper
	permission message: &cYou don't have access to that command.
	trigger:
		if arg 1 is not set:
			send "&c/tp[here] (player)"
		else if arg 1 is set:
			if arg 1 is offline:
				send "&c%arg 1% is offline."
			else if arg 1 is online:
				teleport player to arg 1
				send "&6[Staff] &7Teleported to &6%arg 1%."

command /tphere [<offlineplayer>] [<text>]:
	permission: rank.srmod
	permission message: &cYou don't have access to that command.
	trigger:
		if arg 1 is not set:
			send "&c/tp[here] (player)"
		else if arg 1 is set:
			if arg 1 is offline:
				send "&c%arg 1% is offline."
			else if arg 1 is online:
				teleport arg 1 to player
				send "&6[Staff] &7Teleported &6%arg 1% &7to &6you."

command /gmc [<offlineplayer>] [<text>]:
	permission: rank.admin
	permission message: &cYou don't have access to that command.
	trigger:
		if arg 1 is not set:
			set the player's gamemode to creative
			send "&6[Staff] &7You are now in &6Creative mode."
		else if arg 1 is set:
			if arg 1 is offline:
				send "&c%arg 1% is offline."
			else if arg 1 is online:
				set the arg 1's gamemode to creative
				send "&6[Staff] &7You updated &6%arg 1%'s &7mode to &6Creative."
				send "&6[Staff] &7You are now in &6Creative mode." to arg 1

command /gms [<offlineplayer>] [<text>]:
	permission: rank.helper
	permission message: &cYou don't have access to that command.
	trigger:
		if arg 1 is not set:
			set the player's gamemode to survival
			send "&6[Staff] &7You are now in &6Survival mode."
		else if arg 1 is set:
			if arg 1 is offline:
				send "&c%arg 1% is offline."
			else if arg 1 is online:
				set the arg 1's gamemode to survival
				send "&6[Staff] &7You updated &6%arg 1%'s &7mode to &6Survival."
				send "&6[Staff] &7You are now in &6Survival mode." to arg 1

command /gma [<offlineplayer>] [<text>]:
	permission: rank.admin
	permission message: &cYou don't have access to that command.
	trigger:
		if arg 1 is not set:
			set the player's gamemode to adventure
			send "&6[Staff] &7You are now in &6Adventure mode."
		else if arg 1 is set:
			if arg 1 is offline:
				send "&c%arg 1% is offline."
			else if arg 1 is online:
				set the arg 1's gamemode to adventure
				send "&6[Staff] &7You updated &6%arg 1%'s &7mode to &6Adventure."
				send "&6[Staff] &7You are now in &6Adventure mode." to arg 1

command /gmsp [<offlineplayer>] [<text>]:
	permission: rank.helper
	permission message: &cYou don't have access to that command.
	trigger:
		if arg 1 is not set:
			set the player's gamemode to spectator
			send "&6[Staff] &7You are now in &6Spectator mode."
		else if arg 1 is set:
			if arg 1 is offline:
				send "&c%arg 1% is offline."
			else if arg 1 is online:
				set the arg 1's gamemode to spectator
				send "&6[Staff] &7You updated &6%arg 1%'s &7mode to &6Spectator."
				send "&6[Staff] &7You are now in &6Spectator mode." to arg 1

command /trash [<text>]:
	trigger:
		open virtual chest inventory with size 6 named "&8Disposal bin" to player

command /helpop [<text>]:
	trigger:
		if arg 1 is not set:
			send "&cUsage: /helpop <message ...>"
		else:
			if arg 1 is "%{helpop::%player's uuid%}%":
				send "&6[Helpop] &7Please don't repeat messages."
			else:
				send "`[Helpop]` **%player%:** %arg 1%" to channel with id "550828868953571348" with "beans"
				set {helpop::%player's uuid%} to colored arg 1
				send "&6[Helpop] &7%player%&8: &6%arg 1%" to all players where [input has permission "rank.helper"] 
				if player does not have permission "rank.mod":
					send "&6[Helpop] &7%player%&8: &6%arg 1%"

command /rules [<text>]:
	trigger:
		send ""
		send " &f&l* &6Rules"
		send ""
		send " &6&l* &eNo Spamming or Flooding the chat"
		send " &6&l* &eNo unfair client modifications"
		send " &6&l* &eNo discrimination or harassment"
		send " &6&l* &eUse common sense ffs"
		send ""

command /enderchest [<offlineplayer>] [<text>]:
	aliases: /ec
	trigger:
		if arg 1 is not set:
			open player's enderchest to player 
		else:
			if player does not have permission "rank.admin":
				open player's enderchest to player
			else:
				open arg 1's enderchest to player

on rightclick on anvil:
	wait 3 minutes
	set clicked block to anvil

command /workbench [<text>]:
	aliases: /wb
	trigger:
		open crafting table for player

command /stats [<offlineplayer>] [<text>]:
	trigger:
		if arg 1 is not set:
			set {_p} to player
			set {_uuid} to player's uuid
		else:
			set {_p} to arg 1
			set {_uuid} to arg 1's uuid
		if {balance::%{_uuid}%} is not set:
			send "&cThat player has never joined."
		else:
			send ""
			send " &f&l* &6Stats (&e%{_p}%&6)"
			send ""
			send " &6Rank: &e%{rank::%{_uuid}%}%"
			send " &6Kills: &e%{kills::%{_uuid}%}%"
			send " &6Deaths: &e%{deaths::%{_uuid}%}%"
			send " &6K/D: &e%(rounded down ({kills::%{_uuid}%}*100)/{deaths::%{_uuid}%})/100%"
			send " &6Money: &e$%{balance::%{_uuid}%}%"
			send ""

# end essentials.sk

command /ban [<offlineplayer>] [<text>]:
	permission: rank.helper
	trigger:
		if arg 1 is not set:
			send "&cUsage: /ban <player> <reason>"
		else:
			if arg 1 has permission "rank.mod":
				send "&6[P] &7Wow, &e%player% &7tried punishing &e%arg 1%&7." to all players where [input has permission "rank.helper"]
			else:
				kick arg 1
				ban arg 1 due to arg 2
				send "&6[P] &6%arg 1% &7has been banned by &6%player% &7for &6%arg 2% &7[Forever]" to all players

command /unban [<offlineplayer>]:
	permission: rank.helper
	trigger:
		if arg 1 is not set:
			send "&cUsage: /unban <player>"
		else:
			unban arg 1 
			send "&6[Staff] &7%arg 1% has been &6unbanned" to all players where [input has permission "rank.helper"]

command /mute [<offline player>] [<text>]:
	permission: rank.helper
	trigger:
		if arg 2 is not set:
			send "&cUsage: /mute <player> <reason>"
		else:
			set {mute::%arg 1's uuid%} to arg 2
			set {mute::staff::%arg 1's uuid%} to name of player
			send "&6[P] &6%arg 1% &7has been muted by &6%player%&7. &e[%arg 2%]" to all players where [input has permission "rank.helper"]

command /unmute [<offline player>]:
	permission: rank.helper
	trigger:
		if arg 1 is not set:
			send "&cUsage: /unmute <player>"
		else:
			delete {mute::%arg 1's uuid%}
			delete {mute::staff::%arg 1's uuid%}
			send "&6[Staff] &7%arg 1% has been &6unmuted" to all players where [input has permission "rank.helper"]

# end moti.sk

command /sell [<text>]:
	trigger:
		if arg 1 is not set:
			send "&cUsage: /sell <hand/all>"
		else if arg 1 is set:


			# START VALUES

			set {worth::cobble_stone} to 0.25
			set {worth::stone} to 0.25

			set {worth::iron_ingot} to 10
			set {worth::iron_ore} to 10
			set {worth::iron_block} to 90

			set {worth::golden_ingot} to 20
			set {worth::gold_ore} to 20
			set {worth::gold_block} to 180

			set {worth::diamond} to 25
			set {worth::diamond_ore} to 25
			set {worth::diamond_block} to 225

			set {worth::emerald_item} to 35
			set {worth::emerald_ore} to 35
			set {worth::emerald_block} to 315

			# END VALUES


			if arg 1 is not "hand" or "all":
				player command "/sell"

			else if arg 1 is "all":

				loop all items in player's inventory:
					set {_item} to "%1 of loop-item%"

					if {worth::%{_item}%} is set:
						set {_count} to amount of loop-item in player's inventory
						add {_count} to {_total}
						add {worth::%{_item}%} * {_count} to {_profit}
						remove 2304 of loop-item from player's inventory
	
				if {_total} is not set:
					send "&6[Sell] &7You had no sellable items."
				else if {_total} is set:
					add {_profit} to {balance::%player's uuid%}
					send "&6[Sell] &7You've sold &f%{_total}% items &7for &e$%{_profit}%"

			else if arg 1 is "hand":

				set {_item} to "%1 of tool%"

				if {worth::%{_item}%} is not set:
					send "&6[Sell] &7That item is not sellable."

				else if {worth::%{_item}%} is set:
					set {_count} to amount of tool in player's inventory
					set {_profit} to {worth::%{_item}%} * {_count}
					add {_profit} to {balance::%player's uuid%}
					send "&6[Sell] &7You've sold &f%{_count}%x %1 of tool% &7for &e$%{_profit}%"
					remove all tool from player's inventory

command /warp [<text>]:
	trigger:
		if arg 1 is not set:
			send ""
			send " &f&l* &6Warps"
			send ""
			send "<command:/warp enchant> &6Enchant &e(Click Here)" 
			send ""
		else:
			if {warp::%arg 1%} is not set:
				send "&6[Warps] &7That warp does not exist."
			else:
				teleport player to {warp::%arg 1%}
				send "&6[Warps] &7You've been teleported to %arg 1%."

command /setwarp [<text>]:
	permission: rank.admin
	permission message: &cYou don't have access to that command.
	trigger:
		if arg 1 is not set:
			send "&cUsage: /setwarp <warp ...>"
		else:
			send "&6[Warps] &7You've set &6%arg 1% &7to &c%location of player%&7."
			set {warp::%arg 1%} to location of player

command /delwarp [<text>]:
	permission: rank.admin
	permission message: &cYou don't have access to that command.
	trigger:
		if arg 1 is not set:
			send "&cUsage: /delwarp <warp ...>"
		else:
			if {warp::%arg 1%} is set:
				send "&6[Warps] &7You've deleted &6%arg 1%."
				delete {warp::%arg 1%}
			else:
				send "&6[Warps] &7That warp does not exist."

# end scopes.sk

command /rank [<text>] [<text>] [<text>]:
	permission: rank.srmod
	permission message: &cYou don't have access to that command.
	trigger:
		if arg 1 is not set:
			send "&cUsage: /rank <list|set|edit|create|delete>"
		else:
			if arg 1 is not "list" or "set" or "edit" or "create" or "delete":
				player command "/rank"
			else:
				if arg 1 is "list":
					send "Ranks:"
					send "%{ranks::*}%"
				else:
					if arg 2 is not set:
						player command "/rank"
					else:

						if arg 1 is "edit":
							if {ranks::%arg 2%} is not set:
								send "&cThat rank does not exist."
							else:
								if arg 3 is not set:
									player command "/rank"
								else:
									set {ranks::%arg 2%} to colored arg 3
									send "&c[Ranks] &7Set prefix of %arg 2% to %arg 3%&7."

						else if arg 1 is "set":
							if {ranks::%arg 3%} is not set:
								send "&cThat rank does not exist."
							else:
								set {_p} to arg 2 parsed as offline player
								set {_uuid} to {_p}'s uuid
								command "/pex user %{_p}% group set %arg 3%"
								set {rank::%{_uuid}%} to arg 3
								send "&c[Ranks] &7Set %{_p}%'s rank to %arg 3%"		

						else if arg 1 is "create":
							if arg 3 is not set:
								player command "/rank"
							else:
								if {ranks::%arg 2%} is set:
									player command "/rank edit %arg 2% %arg 3%"
								else:
									set {ranks::%arg 2%} to colored arg 3
									send "&c[Ranks] &7Created rank (%arg 2%) %arg 3%&7."

						else if arg 1 is "delete"
							if arg 3 is not set:
								player command "/rank"
							else:
								if {ranks::%arg 2%} is not set:
									send "&cThat rank does not exist."
								else:
									delete {ranks::%arg 2%}
									send "&c[Ranks] &7Created deleted rank %arg 2%."
							

command /staff [<text>]:
	trigger:
		loop all players:
			if {rank::%uuid of loop-player%} is "Helper", "Mod", "Sr.Mod", "Admin" or "Owner":
				add loop-player to {staff::*}
		if {staff::*} is not set:
			set {staff::*} to "None"
		set {_staff} to "%{staff::*}%"
		delete {staff::*}
		send "&7"
		send "&f&l* &6Online staff: &e%{_staff}%"
		send "&7"

command /broadcast [<text>]:
	aliases: /bc, /alert
	permission: rank.admin
	trigger:
		if arg-1 is set:
			broadcast "&7"
			broadcast "&7(&6&n&oAlert&7) &f%arg-1%"
			broadcast "&7"
			play "BLOCK_NOTE_PLING" to all players at volume 1000
		else:
			send "&cUsage: /broadcast <message ...>"

on chat:
	if message is "abc":
		cancel event
	if {muted::%player's uuid%} is true:
		if {muteDu::%player's uuid%} is "Forever":
			cancel event
			send "&6[Error] &fYou're currently muted for '&e%{muteRe::%player's uuid%}%&f'"
			send "&6[Mute] &fExpires in &cNever&f."
		else:	
			set {_diff} to difference between now and {muteSt::%player's uuid%}
			set {_remain} to difference between {muteDu::%player's uuid%} and {_diff}
			if {_diff} is smaller than {muteDu::%player's uuid%}:
				cancel event
				send "&6[Error] &fYou're currently muted for '&e%{muteRe::%player's uuid%}%&f'"
				send "&6[Mute] &fExpires in &c%{_remain}%&f."
			else:
				delete {muted::%player's uuid%}
				delete {muteDu::%player's uuid%}
				delete {muteSt::%player's uuid%}

every 2 ticks:
	loop all players:
		if {muted::%loop-player's uuid%} is set:
			set {_diff} to difference between now and {muteSt::%loop-player's uuid%}
			set {_remain} to difference between {muteDu::%loop-player's uuid%} and {_diff}
			if {_diff} is smaller than {muteDu::%loop-player's uuid%}:
				set loop-player's action bar to "&6[Mute] &fExpires in &c%{_remain}%&f."
			else:
				delete {muted::%loop-player's uuid%}
				delete {muteDu::%loop-player's uuid%}
				delete {muteSt::%loop-player's uuid%}
				send "&6[Mute] &fYou're no longer muted." to loop-player
				set loop-player's action bar to "&6[Mute] &fMute has expired."


command /warn [<offlineplayer>] [<text>]:
	permission: rank.helper
	permission message: &cYou don't have access to that command.
	trigger:
		if arg 2 is not set:
			send "&cUsage: /warn <player> <reason ... | revert>"
		else:
			if arg 2 is "revert":
				if {warnings::%player's uuid%} is not set:
					send "&cThat player has no warnings."
				else:
					remove 1 from {warnings::%player's uuid%}
					send "&6[P] &6%arg 1%&7's latest warning has been reverted by &6%player%&7." to all players
			else:
				add 1 to {warnings::%player's uuid%}
				send "&6[P] &6%arg 1% &7has been warned by &6%player%&7. &e[%arg 2%]" to all players

# end staff.sk

```

```
on skript load:
    login to "xxx" with the name "beans"
 
options:
    prefix: ?, "%mention tag of event-bot% "
 
discord command ping:
    prefixes: {@prefix}
    trigger:
        reply with "Pong!"
 
discord command command <text>:
    prefixes: {@prefix}
    trigger:
        if event-member does not have permission administrator:
            reply with "You don't have access to that command."
        else:
            command arg
 
on chat:
    if event is not canceled:
        send "**%player%:** %message%" to channel with id "552991851045584897" with "beans"
 
on guild message received:
    if id of event-channel is "552991851045584897":
        send "&3[Discord] &7%event-user%##%discriminator of event-user%&8: &f%event-message%" to all players
 
on join:
    send ":inbox_tray: **%player%** joined the server." to channel with id "552991851045584897" with "beans"
 
on quit:
    send ":outbox_tray: **%player%** left the server." to channel with id "552991851045584897" with "beans"
 
command /auc [<text>] [<text>]:
    permission: rank.admin
    permission message: An unxpected issue has occured. This has been disabled.
    trigger:
        if arg 1 is not set:
            send "&c/auc <start | cancel | info> ([<amount>])"
        else:
            if arg 1 is not "start" or "cancel" or "info":
                player command "/auc"
            else:
                if arg 1 is "info":
                    if {auc::owner} is not set:
                        send "&cThere is no current auction."
                    else:
                        if {auc::bidder} is not set:
                            set {_bid} to {auc::bid}
                        else:
                            set {_bid} to {auc::bid} + 50
                        set {_name} to name of {auc::item} ? type of {auc::item}
                        set {_lore} to lore of {auc::item}
                        replace all "||" with nl in {_lore}
                        if {_lore} is "":
                            set {_lore} to "&7No Lore"
                        set {_enchantments::*} to enchantments of {auc::item}
                        loop {_enchantments::*}:
                            add 1 to {_n}
                            set {_e::%{_n}%} to "%loop-value% %level of loop-value on {auc::item}%%nl%"
                        set {_e2} to "%{_e::*}%"
                        replace all ", " and " and " with "" in {_e2}
                        if "%{_e2}%" is "<none>":
                            set {_e2} to "No Enchantments"
                        set {_tooltip} to "&e(%{auc::count}%x) &8| &7%{_name} ? type of {auc::item}%&r &8| &e(%type of {auc::item}%)%nl%&7%{_e2} ? ""No Enchantments""%%nl%&7%{_lore} ? ""No Lore""%"
                        set {_weapon} to "<tooltip:%{_tooltip}%>&a&l[ &f%{auc::count}%x %name of tool ? type of {auc::item}% &a&l]&r"
                        send ""
                        send "&6[Auction] &7%{auc::owner}% started an auction for %{_weapon}% &6[$%short({_bid})%]"
                        send ""
                else if arg 1 is "cancel":
                    if {auc::owner} is not set:
                        send "&cThere is no current auction."
                    else:
                        if "%{auc::owner}%" is not "%player%":
                            send "&cbruh how you finna do %{auc::owner}% like that..."
                        else:
                            if {auc::time} is less than 10:
                                send "&cYou can't cancel an auction with that little time left :O"
                            else:
                                give {auc::count} of {auc::item} to player
                                send "&6[Auctions] &7The auction has been canceled by &e%player%&7."
                                if {auc::bidder} is set:
                                    set {_bidder} to {auc::bidder}'s uuid
                                    add {auc::bid} to {balance::%{_bidder}%}
                                delete {auc::*}
                else if arg 1 is "start":
                    if {auc::owner} is set:
                        send "&cThere is an auction in progress!"
                    else:
                        set {_amount} to arg 2 parsed as integer
                        if {_amount} is not set:
                            send "&cMust be an integer."
                        else:
                            if {_amount} is less than 10:
                                send "&cYou must sell that for more than $10."
                            else:
                                if {_amount} is greater than 25000:
                                    send "&cYou must sell that for less than $25,000."
                                else:
                                    if player is holding air:
                                        send "&cYou can't sell that."
                                    else:
 
                                        if durability of tool is not 0:
                                            send "&cYou can only sell a repaired item."
                                        else:
                                            set {_enchantments} to "%enchantments of tool%"
                                            if "%{_enchantments}%" is "<none>":
                                                set {auc::item} to "%tool%"
                                            else:
                                                set {auc::item} to "%tool% of %{_enchantments}%"
                                            if {auc::item} is not set:
                                                set {auc::item} to "%1 of tool%"
 
                                            set {auc::item} to {auc::item} parsed as item
                                           
                                            set {auc::count} to amount of tool in player's inventory
                                            set {auc::owner} to player
                                            set {auc::bid} to {_amount}
                                            remove {auc::count} of tool from player's inventory
               
                                            set {auc::time} to 30
                                            all players command "/auc info"
                       
command /bid [<number>]:
    trigger:
        if arg 1 is not set:
            send "&c/bid <integer>"
        else:
            if {auc::owner} is not set:
                send "&cThere is no current auction."
            else:
                if "%{auc::owner}%" is "%player%":
                    send "&cYou can't bid on your own auction."
                else:
                    if "%{auc::bidder}%" is "%player%":
                        send "&cYou have already bid on that."
                    else:
                        set {_amount} to (rounded up arg 1)
                        if {balance::%player's uuid%} is less than {_amount}:
                            send "&cInsufficient Funds!"
                        else:
                            if arg 1 is less than or equal to ({auc::bid} + 50):
                                send "&cYou must bid at least $%{auc::bid} + 50%."
                            else:
                                set {_bidder} to {auc::bidder}'s uuid
                                add {auc::bid} to {balance::%{_bidder}%}
                                set {auc::bidder} to player
                                set {auc::bid} to {_amount}
                                remove {auc::bid} from {balance::%player's uuid%}
                                send "&6[Auctions] &e%player% &7has bid &e$%{_amount}%&7." to all players
 
every second:
    if {auc::time} is set:
        remove 1 from {auc::time}
        if {auc::time} is 20 or 15 or 10 or 5 or 4 or 3 or 2 or 1:
            send "&6[Auctions] &7There are &e%{auc::time}% &7seconds remaining." to all players
        else if {auc::time} is 0:
            if {auc::bidder} is not set:
                send "&6[Auctions] &7No one won the auction :(" to all players
                if {auc::owner} is offline:
                    set {_owner} to {auc::owner}'s uuid
                    set {itemq::%{_owner}%} to {auc::item}
                    set {itemqb::%{_owner}%} to {auc::bid}
                else:
                    give {auc::count} of {auc::item} to {auc::owner}
            else:
                send "&6[Auctions] &e%{auc::bidder}% &7won the auction for &e$%{auc::bid}%&7!" to all players
                set {_owner} to {auc::owner}'s uuid
                add {auc::bid} to {balance::%{_owner}%}
                if {auc::bidder} is offline:
                    set {_bidder} to {auc::bidder}'s uuid
                    set {itemq::%{_bidder}%} to {auc::item}
                    set {itemqb::%{_bidder}%} to {auc::bid}
                else:
                    give {auc::count} of {auc::item} to {auc::bidder}
            delete {auc::*}
 
on join:
    if {itemq::%player's uuid%} is set:
        send "&6[Auctions] &7You won the auction for &e$%{itemqb::%player's uuid%}%&7!"
        give 1 of {itemq::%player's uuid%} to player
        delete {itemq::%player's uuid%}
        delete {itemqb::%player's uuid%}
 
# auc::time - time left in auction
# auc::bidder - person bidding
# auc::owner - auc starter
# auc::bid - current bid
# auc::item - item for sale
# auc::count - amount of item
 
on load:
    delete {mrl}
    send "&6[Beans] &7The mine may be reset again! (/reset)" to all players
 
command /reset [<text>]:
    trigger:
        if player has permission "rank.jrmod":
            set {_r} to player's name
        else:
            if {mrl} is set:
                send "&6[Beans] &7Currently on cooldown!"
            else:
                set {_r} to true
                set {_r1} to true
 
        if {_r} is set:
            loop all players:
                "%region at loop-player%" is "mine in world ul_world"
                teleport loop-player to location(x-coordinate of player, 55, z-coordinate of player, world)
 
            loop all blocks in region region at location(0, 25, 0, world):
                loop-block is not bedrock
                set {_int} to a random integer between 1 and 100
                if {_int} is between 1 and 60:
                    set loop-block to stone
                else if {_int} is between 61 and 69:
                    set loop-block to coal ore
                else if {_int} is between 70 and 78:
                    set loop-block to iron ore
                else if {_int} is between 79 and 83:
                    set loop-block to gold ore
                else if {_int} is between 84 and 89:
                    set loop-block to diamond ore
                else if {_int} is between 89 and 94:
                    set loop-block to emerald ore
                else:
                    set loop-block to stone
 
            loop all blocks in region region at location(0, 55, 0, world):
                set loop-block to air
           
            send "&6[Beans] &7The mine has been reset by &e%player%&7! (/reset)" to all players
       
        if {_r1} is set:
            set {mrl} to true
            wait 5 minutes
            delete {mrl}
            send "&6[Beans] &7The mine may be reset again! (/reset)" to all players
 
command /sell [<text>]:
    trigger:
        if arg 1 is not set:
            send "&c/sell <hand|all>"
        else if arg 1 is set:
            if arg 1 is not "hand" or "all":
                player command "/sell"
            else:
 
                set {_booster} to 1.0
                add {booster} to {_booster}
                add size of all players / 100 to {_booster}
                if player has permission "rank.mvp":
                    add 0.15 to {_booster}
                if player has permission "rank.vip":
                    add 0.1 to {_booster}
 
                if player is holding any pickaxe:
                    set {_lore} to lore of tool
                    if {_lore} contains "Merchant":
                        chance of 40%:
                            send "&6[Merchant] &e+7x booster!"
                            add 7.0 to {_booster}
 
                if arg 1 is "all":
                    loop all items in player's inventory:
                        set {_item} to "%1 of loop-item%"
                        if {worth::%{_item}%} is set:
                            set {_count} to amount of loop-item in player's inventory
                            add {_count} to {_total}
                            add {worth::%{_item}%} * {_count} to {_profit}
                            remove 2304 of loop-item from player's inventory
                    if {_total} is not set:
                        send "&6[Sell] &7You had no sellable items."
                    else if {_total} is set:
                        set {_profit} to {_profit} * {_booster}
                        add {_profit} to {balance::%player's uuid%}
                        send "&6[Sell] &7Sold &e%{_total}% &7items for &e$%short({_profit})%&7. &6(%{_booster}%x booster)"
 
                if arg 1 is "hand":
                    set {_item} to "%1 of player's tool%"
                    if {worth::%{_item}%} is not set:
                        send "&6[Sell] &7That item is not sellable."
                    else if {worth::%{_item}%} is set:
                        set {_count} to amount of tool in player's inventory
                        set {_profit} to {worth::%{_item}%} * {_count}
                        set {_profit} to {_profit} * {_booster}
                        add {_profit} to {balance::%player's uuid%}
                        send "&6[Sell] &7Sold &e%{_count}%x %1 of tool% &7for &e$%short({_profit})%&7. &6(%{_booster}%x booster)"
                        remove all tool from player's inventory
 
command /worth [<text>]:
    trigger:
        set {_item} to "%1 of tool%"
        if {worth::%{_item}%} is not set:
            send "&6[Sell] &7That item is not sellable."
        else:
            send "&6[Sell] &7That is worth &e$%short({worth::%{_item}%})%."
 
command /setworth [<number>]:
    permission: admin
    trigger:
        set {_item} to "%1 of tool%"
        if arg 1 is not set:
            send "&c/setworth <amount>"
        else:
            if arg 1 is -1:
                delete {worth::%{_item}%}
                send "&6[Sell] &7That item is now worth nothing."
            else:
                set {worth::%{_item}%} to arg 1
                send "&6[Sell] &7Set worth of &e%1 of tool% &7to &e$%arg 1%&7."
 
command /prices [<text>]:
    trigger:
        loop {worth::*}:
            send "%loop-index% - %loop-value%"
 
function purchase(p: player, i: item, c: number, co: number):
    set {_u} to {_p}'s uuid
    set {_bal} to {balance::%{_u}%}
    if {_bal} is less than {_co}:
        play "ENTITY_VILLAGER_NO" to {_p} at volume 10000
        set {_amount} to {_co} - {balance::%{_u}%}
        send "&6[Shop] &7You need &e$%{_amount}% more &7to purchase that." to {_p}
    else:
        if {_p} has not enough space for {_c} of {_i}:
            send "&cYour inventory is full!" to {_p}
        else:
            if {_i} is diamond helmet:
                give {_p} all diamond armor
            else:
                give {_p} {_c} of {_i}
            remove {_co} from {balance::%{_u}%}
            shop({_p}, {shop::%{_u}%})
            play "BLOCK_NOTE_PLING" to {_p} at volume 10000
            send "&6[Shop] &7You've purchased &f%{_c}%x %{_i}% &7for &e$%{_co}%" to {_p}
 
function shop(p: player, t: text):
    set {_u} to {_p}'s uuid
    set {shop::%{_u}%} to {_t}
    set {_bal} to short({balance::%{_u}%})
    set {_lore} to "&7Click to purchase."
 
    play "ENTITY_ENDERDRAGON_FLAP" to {_p} at volume 10000
    open virtual chest inventory with size 1 named "&8Shop &3($%{_bal}%)" to {_p}
    format gui slot 0 of {_p} with feather named "&c&lMain Menu" with lore "&7Click to return to the main menu." to run function shop({_p}, "main")
 
    if {_t} is "main":
        format gui slot 3 of {_p} with oak wood log named "&a&lBlocks Shop" with lore "&7Click to view the blocks shop." to run function shop({_p}, "blocks")
        format gui slot 4 of {_p} with diamond sword named "&3&lCombat Shop" with lore "&7Click to view the combat shop." to run function shop({_p}, "combat")
        format gui slot 5 of {_p} with lapis named "&b&lMisc Shop" with lore "&7Click to view the misc shop." to run function shop({_p}, "misc")
 
    else if {_t} is "blocks":
        format gui slot 2 of {_p} with prismarine named "&f16x &bPrismarine &7(&n$100&7)" with lore {_lore} to run function purchase({_p}, prismarine, 16, 100)
        format gui slot 3 of {_p} with sea lantern named "&f4x &bSea Lantern &7(&n$100&7)" with lore {_lore} to run function purchase({_p}, sea lantern, 4, 100)
        format gui slot 4 of {_p} with oak wood log named "&f16x &bLogs &7(&n$60&7)" with lore {_lore} to run function purchase({_p}, oak wood log, 16, 60)
        format gui slot 5 of {_p} with white wool block named "&f16x &bWool &7(&n$60&7)" with lore {_lore} to run function purchase({_p}, white wool block, 16, 60)
        format gui slot 6 of {_p} with stone named "&f64x &bStone &7(&n$20&7)" with lore {_lore} to run function purchase({_p}, stone, 64, 20)
 
    else if {_t} is "combat":
        format gui slot 2 of {_p} with turtle helmet named "&f&l1x &bTurtle helmet &7(&n$5,000&7)" with lore {_lore} to run function purchase({_p}, turtle helmet, 1, 5000)
        format gui slot 3 of {_p} with diamond helmet named "&f&l1x &bSet of Diamond armor &7(&n$100&7)" with lore {_lore} to run function purchase({_p}, diamond helmet, 1, 100)
        format gui slot 4 of {_p} with diamond sword named "&f&l1x &bDiamond Sword &7(&n$50&7)" with lore {_lore} to run function purchase({_p}, diamond sword, 1, 50)
        format gui slot 5 of {_p} with bow named "&f&l1x &bBow&7(&n$50&7)" with lore {_lore} to run function purchase({_p}, bow, 1, 50)
        format gui slot 6 of {_p} with arrow named "&f&l4x &bArrows &7(&n$20&7)" with lore {_lore} to run function purchase({_p}, arrow, 4, 20)
 
    else if {_t} is "misc":
        format gui slot 2 of {_p} with elytra named "&f&l1x &bElytra &7(&n$5&7)" with lore {_lore} to run function purchase({_p}, elytra, 1, 5)
        format gui slot 3 of {_p} with lapis named "&f&l16x &bLapis &7(&n$20&7)" with lore {_lore} to run function purchase({_p}, lapis, 16, 20)
        format gui slot 4 of {_p} with book named "&f&l4x &bBook &7(&n$50&7)" with lore {_lore} to run function purchase({_p}, book, 4, 50)
        format gui slot 5 of {_p} with firework named "&f&l16x &bFirework &7(&n$50&7)" with lore {_lore} to run function purchase({_p}, firework, 16, 50)
        format gui slot 6 of {_p} with xp bottle named "&f&l16x &bXP Bottles &7(&n$50&7)" with lore {_lore} to run function purchase({_p}, xp bottle, 16, 50)
        format gui slot 7 of {_p} with golden apple named "&f&l4x &bGolden Apple &7(&n$250&7)" with lore {_lore} to run function purchase({_p}, golden apple, 4, 250)
 
command /shop [<text>]:
    trigger:
        set {_s} to arg 1 ? "main"
        shop(player, {_s})
 
command /bounty [<offlineplayer>] [<number>]:
    cooldown: 3 seconds
    cooldown message: &6[Bounty] &7Calm thou breasts
    trigger:
        if arg 2 is not set:
            send "&c/bounty <player> <amount>"
        else:
            if arg 1 is offline:
                send "&cThat player is offline."
            else:
                if arg 2 is less than 500:
                    send "&cBounty has to be greater than $500."
                else:
                    if {balance::%player's uuid%} is less than arg 2:
                        send "&cYou don't have that much money."
                    else:
                        remove arg 2 from {balance::%player's uuid%}
                        add arg 2 to {bounty::%arg 1's uuid%}
                        send "%nl%&6[Bounty] &e%player% &7added a &e$%arg 2% &7bounty on &e%arg 1%&7.%nl%" to all players
 
on death of player:
    "%attacker%" is not "%victim%"
    "%attacker%" is not "<none>"
    set {_b} to {bounty::%victim's uuid%}
    {_b} is set
    send "%nl%&6[Bounty] &e%attacker% &7claimed the &e$%{_b}% &7on &e%victim%&7.%nl% " to all players
    add {_b} to {balance::%attacker's uuid%}
    delete {bounty::%victim's uuid%}
 
command /tool [<item>]:
    trigger:
        open virtual chest inventory with size 1 for player
        format gui slot 0 of player with arg to close
 
on chat:
 
    if {recent} is first 3 characters of message:
        cancel event
        send "&6Possible spam detected."
 
    set {recent} to first 3 characters of message
   
    if {mute::%player's uuid%} is set:
        if {mutet::%player's uuid%} is not set:
            send {mute::%player's uuid%}
            cancel event
        else:
            if difference between {mutet::%player's uuid%} and now is greater than {mutet2::%player's uuid%}:
                send "&6[Beans] &eYou have been unmuted!"
                delete {mute::%player's uuid%}
                delete {mutet::%player's uuid%}
                delete {mutet2::%player's uuid%}
                set chat format to "&7%player's prefix%%player%%player's suffix%&8: &f%message%"
            else:
                send {mute::%player's uuid%}
                cancel event
       
    else:
        if player doesn't have permission "rank.jrmod":
       
            if {chat} is set:
                cancel event
                send "&6[Beans] &7Chat is currently muted by &e%{chat}%&7."
 
        if message contains "[item]":
            {chat} is not set
            player is not holding air
            cancel event
 
            set {_name} to name of tool ? type of tool
            set {_lore} to lore of tool
            replace all "||" with nl in {_lore}
            if {_lore} is "":
                set {_lore} to "&7No Lore"
            set {_enchantments::*} to enchantments of tool
            loop {_enchantments::*}:
                add 1 to {_n}
                set {_e::%{_n}%} to "%loop-value% %level of loop-value on tool%%nl%"
            set {_e2} to "%{_e::*}%"
            replace all ", " and " and " with "" in {_e2}
            if "%{_e2}%" is "<none>":
                set {_e2} to "No Enchantments"
            set {_tooltip} to "&e(%amount of tool in player's inventory%x) &8| &7%{_name} ? type of tool%&r &8| &e(%type of tool%)%nl%&7%{_e2} ? ""No Enchantments""%%nl%&7%{_lore} ? ""No Lore""%"
            set {_weapon} to "<tooltip:%{_tooltip}%>&a&l[ &f%amount of tool in player's inventory%x %name of tool ? type of tool% &a&l]&r"
 
            replace all "[item]" with "%{_weapon}%" in message
            send "&7%player's prefix%%player%%player's suffix%&8: &f%message%" to all players
 
        set chat format to "&7%player's prefix%%player%%player's suffix%&8: &f%message%"
 
command /chat [<text>]:
    permission: rank.jrmod
    permission message: &cYou don't have access to that command.
    trigger:
        if arg 1 is not set:
            send "&cUsage: /chat <mute | clear>"
        else:
            if arg 1 is not "mute" or "clear":
                player command "/chat"
            else if arg 1 is "mute":
                if {chat} is not set:
                    set {chat} to player's name
                    send "%nl%&6[Beans] &7Chat has been muted by &e%player%&7.%nl%" to all players
                else:
                    delete {chat}
                    send "%nl%&6[Beans] &7Chat has been unmuted by &e%player%&7.%nl%" to all players
            else if arg 1 is "clear":
                loop 200 times:
                    send "" to all players
                send "&6[Beans] &7Chat has been cleared by &e%player%&7.%nl%" to all players
 
on quit:
    if {ct::%player%} is set:
        send "&c%player% &7just logged out in combat!" to all players
        set {_attacker} to {attacker::%player%}
        set {_u} to {_attacker}'s uuid
        add 1 to {kills::%{_u}%}
        add 1 to {deaths::%player's uuid%}
        delete {attacker::%player%}
 
on command:
    {ct::%player%} is set
    set {_c} to command
    if {_c} is "hub" or "lobby" or "server":
        add 1 to {confirm::%player%}
        if {confirm::%player%} is 1:
            cancel event
            send "Type command again to confirm. (Punishable Offense)"
        else:
            delete {confirm::%player%}
    else if {_c} is "spawn":
        cancel event
        send "You can't use that command in combat!"
 
on damage of player:
 
    if event is not canceled:
 
        "%damage cause%" is not "suffocation"
        attacker is a player
 
        set {attacker::%victim%} to attacker
 
        if {ct::%attacker%} is not set:
            send "&7You have combat tagged &c%victim%&7." to attacker
 
        if {ct::%victim%} is not set:
            send "&7You've been combat tagged by &c%attacker%&7." to victim
 
        set {ct::%attacker%} to 20
        set {ct::%victim%} to 20
 
every second:
    loop all players:
        if {ct::%loop-player%} is set:
            remove 1 from {ct::%loop-player%}
            if {ct::%loop-player%} is 0:
                delete {ct::%loop-player%}
                send "&7You are free to log out!" to loop-player
 
command /ct [<text>]:
    trigger:
        if {ct::%player%} is not set:
            send "&7You are not combat tagged."
        else:
            send "&7You are combat tagged for &c%{ct::%player%}% &7seconds."
 
on load:
    add "<link:https://discord.gg/kHF76Qq>Click here to join the discord!" to {announcements::*}
    add "<command:/repair>Tool durability getting low? Use /repair! ($50)" to {announcements::*}
    add "<command:Look at my [item]!>You can display your item in chat by typing [item]." to {announcements::*}
    add "<command:/shop>Want to buy materials? Use /shop!" to {announcements::*}
 
every 2 minutes:
    send "&6[Beans] &7%random element out of {announcements::*}%" to all players
 
command /bc [<text>]:
    permission: rank.srmod
    permission message: &cYou don't have access to that command.
    trigger:
        if arg 1 is not set:
            send "&c/bc <message>"
        else:
            send "&6[Beans] &7%arg 1%" to all players
           
command /ec [<text>]:
    trigger:
        open player's ender chest to player
 
command /balance [<offlineplayer>]:
    aliases: /bal
    trigger:
        if arg 1 is not set:
            send "&6[Beans] &e%player% &7has a balance of &e$%{balance::%player's uuid%}%&7."
        else:
            if {balance::%arg 1's uuid%} is not set:
                send "&cHmm... It seems that user has never joined."
            else:
                send "&6[Beans] &e%arg 1% &7has a balance of &e$%{balance::%arg 1's uuid%}%&7."
 
command /pay [<offlineplayer>] [<number>]:
    trigger:
        if arg 2 is not set:
            send "&cUsage: /pay <player> <amount>"
        else:
            if arg 1 is offline:
                send "&cThat player is offline."
            else:
                if arg 2 is less than 10:
                    send "&cYou must pay %arg 1% more than $10."
                else:
                    if {balance::%player's uuid%} is less than arg 2:
                        set {_missing} to arg 2 - {balance::%player's uuid%}
                        send "&6[Beans] &7You are missing &e$%{_missing}%&7."
                    else:
                        send "&6[Beans] &e%player% &7paid you &e$%arg 2%&7." to arg 1
                        send "&6[Beans] &e%arg 1% &7recieved &e$%arg 2%&7."
                        remove arg 2 from {balance::%player's uuid%}
                        add arg 2 to {balance::%arg 1's uuid%}
 
 
command /eco [<text>] [<offlineplayer>] [<number>]:
    permission: rank.admin
    permission message: &cYou don't have access to that command.
    trigger:
        if arg 3 is not set:
            send "&cUsage: /eco <set | add | remove> <player> <amount>"
        else:
            if arg 1 is "set":
                set {balance::%arg 2's uuid%} to arg 3
            else if arg 1 is "add":
                add arg 3 to {balance::%arg 2's uuid%}
            else if arg 1 is "remove":
                remove arg 3 from {balance::%arg 2's uuid%}
            player command "/bal %arg 2%"
 
function short(n: num) :: string:
    set {_units::*} to "K", "M", "B", "T", "q", "Q", "s", "S" and "O"
    loop size of {_units::*} times:
        {_n} >= 1000 ^ loop-num:
            {_n} < 1000 ^ (loop-num + 1)
            return "%{_n} / 1000 ^ loop-num%%{_units::%loop-num%}%"
    return "%{_n}%"
 
every minute:
    assign()
 
function assign():
 
    delete {mined::*}
    loop {blocks::*}:
        add 1 to {_size}
        if {_mined::%loop-value%} is not set:
            set {_mined::%loop-value%} to loop-index
        else:
            set {_mn} to 0
            loop {_size} times:
                set {_mn} to {_mn}+1
                {_mined::%loop-value-1%.%{_mn}%} is not set
                set {_mined::%loop-value-1%.%{_mn}%} to loop-index
                stop loop
    wait 1 tick
    set {_mn} to size of {_mined::*}
    loop {_mined::*}:
        set {_mined2::%{_mn}%} to loop-value
        set {_mn} to {_mn}-1
    wait 1 tick
    set {_i} to 0
    loop {_mined2::*}:
        add 1 to {_topnumber1}
        set {_player} to "%loop-value%" parsed as offlineplayer
        set {_u} to {_player}'s uuid
        set {mined::%{_u}%} to {_topnumber}
        set {mined::%{_topnumber1}%::player} to {_player}
 
    delete {baltop::*}
    loop {balance::*}:
        add 1 to {_size}
        if {_baltop::%loop-value%} is not set:
            set {_baltop::%loop-value%} to loop-index
        else:
            set {_bn} to 0
            loop {_size} times:
                set {_bn} to {_bn}+1
                {_baltop::%loop-value-1%.%{_bn}%} is not set
                set {_baltop::%loop-value-1%.%{_bn}%} to loop-index
                stop loop
    wait 1 tick
    set {_bn} to size of {_baltop::*}
    loop {_baltop::*}:
        set {_baltop2::%{_bn}%} to loop-value
        set {_bn} to {_bn}-1
    wait 1 tick
    set {_i} to 0
    loop {_baltop2::*}:
        add 1 to {_topnumber}
        set {_player} to "%loop-value%" parsed as offlineplayer
        set {_u} to {_player}'s uuid
        set {baltop::%{_u}%} to {_topnumber}
        set {baltop::%{_topnumber}%::player} to {_player}
 
    delete {killtop::*}
    loop {kills::*}:
        add 1 to {_size}
        if {_killtop::%loop-value%} is not set:
            set {_killtop::%loop-value%} to loop-index
        else:
            set {_kn} to 0
            loop {_size} times:
                set {_kn} to {_kn}+1
                {_killtop::%loop-value-1%.%{_kn}%} is not set
                set {_killtop::%loop-value-1%.%{_kn}%} to loop-index
                stop loop
    wait 1 tick
    set {_kn} to size of {_killtop::*}
    loop {_killtop::*}:
        set {_killtop2::%{_kn}%} to loop-value
        set {_kn} to {_kn}-1
    wait 1 tick
    set {_i} to 0
    loop {_killtop2::*}:
        add 1 to {_topnumber2}
        set {_player} to "%loop-value%" parsed as offlineplayer
        set {_u} to {_player}'s uuid
        set {killtop::%{_u}%} to {_topnumber2}
        set {killtop::%{_topnumber2}%::player} to {_player}
 
command /baltop [<text>]:
    trigger:
        send ""
        send "                  &6&lBaltop"
        send ""
 
        loop 5 times:
            set {_p%loop-number%} to {baltop::%loop-number%::player}
            set {_pu%loop-number%} to {_p%loop-number%}'s uuid
            set {_b%loop-number%} to short({balance::%{_pu%loop-number%}%})
 
        send " &e(##1) &7%{baltop::1::player}% &e$%{_b1}%"
        send " &e(##2) &7%{baltop::2::player}% &e$%{_b2}%"
        send " &e(##3) &7%{baltop::3::player}% &e$%{_b3}%"
        send " &e(##4) &7%{baltop::4::player}% &e$%{_b4}%"
        send " &e(##5) &7%{baltop::5::player}% &e$%{_b5}%"
        if {baltop::%player's uuid%} is set:
            if {baltop::%player's uuid%} is not between 0 and 5:
                send " &6(##%{baltop::%player's uuid%}%) &7%player% &e$%short({balance::%player's uuid%})%"
        send ""
 
command /blocktop [<text>]:
    trigger:
        send ""
        send "                  &6&lBlocktop"
        send ""
 
        loop 5 times:
            set {_p%loop-number%} to {mined::%loop-number%::player}
            set {_pu%loop-number%} to {_p%loop-number%}'s uuid
            set {_b%loop-number%} to short({blocks::%{_pu%loop-number%}%})
 
        send " &e(##1) &7%{mined::1::player}% &e%{_b1}% blocks"
        send " &e(##2) &7%{mined::2::player}% &e%{_b2}% blocks"
        send " &e(##3) &7%{mined::3::player}% &e%{_b3}% blocks"
        send " &e(##4) &7%{mined::4::player}% &e%{_b4}% blocks"
        send " &e(##5) &7%{mined::5::player}% &e%{_b5}% blocks"
        if {mined::%player's uuid%} is set:
            if {mined::%player's uuid%} is not between 0 and 5:
                send " &6(##%{mined::%player's uuid%}%) &7%player% &e%short({mined::%player's uuid%})% blocks"
        send ""
 
command /killtop [<text>]:
    trigger:
        send ""
        send "                  &6&lKilltop"
        send ""
 
        loop 6 times:
            set {_p%loop-number%} to {killtop::%loop-number%::player}
            set {_pu%loop-number%} to {_p%loop-number%}'s uuid
            set {_b%loop-number%} to short({kills::%{_pu%loop-number%}%})
 
        send " &e(##1) &7%{killtop::2::player}% &e%{_b2}% kills"
        send " &e(##2) &7%{killtop::3::player}% &e%{_b3}% kills"
        send " &e(##3) &7%{killtop::4::player}% &e%{_b4}% kills"
        send " &e(##4) &7%{killtop::5::player}% &e%{_b5}% kills"
        send " &e(##5) &7%{killtop::6::player}% &e%{_b6}% kills"
        if {killtop::%player's uuid%} is set:
            if {killtop::%player's uuid%} is not between 0 and 5:
                send " &6(##%{killtop::%player's uuid%}%) &7%player% &e%short({kills::%player's uuid%})% kills"
        send ""
 
command /gmc [<offlineplayer>]:
    permission: rank.srmod
    permission message: &cYou don't have access to that command.
    trigger:
        set {_p} to arg 1 ? player
        set {_p}'s gamemode to creative
 
command /gms [<offlineplayer>]:
    permission: rank.jrmod
    permission message: &cYou don't have access to that command.
    trigger:
        if player has permission "rank.srmod":
            set {_p} to arg 1 ? player
        else:
            set {_p} to player
        set {_p}'s gamemode to survival
 
command /gmsp [<offlineplayer>]:
    permission: rank.jrmod
    permission message: &cYou don't have access to that command.
    trigger:
        if player has permission "rank.srmod":
            set {_p} to arg 1 ? player
        else:
            set {_p} to player
        set {_p}'s gamemode to spectator
 
command /sc [<text>]:
    permission: rank.jrmod
    permission message: &cYou don't have access to that command.
    trigger:
        if arg 1 is not set:
            send "&c/sc <message>"
        else:
            send " &c(Staff) &7%player%&8: &c%arg 1%" to all players where [input has permission "rank.jrmod"]
 
command /ac [<text>]:
    permission: rank.srmod
    permission message: &cYou don't have access to that command.
    trigger:
        if arg 1 is not set:
            send "&c/ac <message>"
        else:
            send " &b(Staff) &7%player%&8: &b%arg 1%" to all players where [input has permission "rank.srmod"]
 
command /discord [<text>]:
    trigger:
        send "<link:https://discord.gg/kHF76Qq>&6[Beans] &7Click here to join our discord!"
 
command /help [<text>]:
    trigger:
        if arg 1 is not set:
            send ""
            send " &6[Beans] &7Help Page"
            send ""
            send " <command:/help eco>&e&lEconomy&7: click for economy help"
            send " <command:/help misc>&e&lMisc&7: click for misc. help"
            if player has permission "rank.jrmod":
                send " <command:/help jrmodplus>&6&lStaff&7: click for staff help"
            send ""
        else:
            if arg 1 is "eco" or "misc" or "jrmodplus":
                send ""
                send " &6[Beans] &7Help Page"
                send ""
                if arg 1 is "eco":
                    send " &e/bal&7: view someone's balance"
                    send " &e/baltop&7: view the richest players"
                    send " &e/pay&7: pay a user"
                    send " &e/auc&7: auction system"
                else if arg 1 is "misc":
                    send " &e/spawn&7: teleport to spawn"
                    send " &e/pv&7: open one of your private vaults"
                    send " &e/ct&7: view your combat tag"
                    send " &e/ec&7: open your ender chest"
                else if arg 1 is "jrmodplus":
                    send " &e/sc&7: staff chat (jrmod+)"
                    send " &e/ac&7: admin chat (srmod+)"
                    send " &e/gmc&7: gamemode creative (srmod+)"
                    send " &e/gms&7: gamemode survival (jrmod+)"
                    send " &e/gmsp&7: gamemode spectator (jrmod+)"
                    send " &e/chat&7: manage the chat (jrmod+)"
                send ""
            else:
                player command "/help"
 
command /rename [<text>]:
    trigger:
        if tool is air:
            send "&6[Rename] &7u cant rename that"
        else:
            if arg 1 is not set:
                send "&c/rename <item name>"
            else:
                if player does not have permission "rank.vip":
                    if {balance::%player's uuid%} is less than 50:
                        send "&6[Rename] &7That costs $50."
                    else:
                        if arg 1 contains "&l" or "&o":
                            send "&6[Rename] &7Only donators may have bold or italic."
                        else:
                            remove 50 from {balance::%player's uuid%}
                            send "&6[Rename] &7Successfully renamed your item."
                            set name of tool to arg 1
                else:
                    send "&6[Rename] &7Successfully renamed your item."
                    set name of tool to colored arg 1
 
command /repair [<text>]:
    trigger:
        if player is holding air:
            send "&6[Repair] &7so you just gonna repair air? ok then"
        else:
            if player does not have permission "rank.vip":
                if {balance::%player's uuid%} is less than 50:
                    send "&6[Repair] &7That costs $50."
                else:
                    if durability of tool is less than 1:
                        send "&6[Repair] &7That item can't be repaired."
                    else:
                        remove 50 from {balance::%player's uuid%}
                        repair player's tool by 1500
                        send "&6[Repair] &7Successffully repaired your item."
            else:
                if durability of tool is less than 1:
                    send "&6[Repair] &7That item can't be repaired."
                else:
                    remove 15 from {balance::%player's uuid%}
                    repair player's tool by 1500
                    send "&6[Repair] &7Successfully repaired your item."
 
 
command /invsee [<offlineplayer>]:
    permission: rank.jrmod
    permission message: &cYou don't have access to that command.
    trigger:
        set {_p} to arg 1 ? player
        if {_p} is offline:
            send "&cThat player is offline."
        else:
            show {_p}'s inventory for player
 
command /rules [<text>]:
    trigger:
        send ""
        send " &6[Beans] &7List of rules"
        send ""
        send " &e1. &7use common sense ffs"
        send ""
 
command /trash [<text>]:
    aliases: /mrscopes
    trigger:
        open virtual chest inventory with size 5 named "&8Trash" to player
 
command /tp [<offlineplayer>]:
    permission: rank.jrmod
    permission message: &cYou don't have access to that command.
    trigger:
        if arg 1 is offline:
            send "&6[Beans] &cPlayer not found"
        else:      
            teleport player to arg 1
            send "&6[Beans] &aTeleported to %arg 1%!"
 
command /tphere [<offlineplayer>]:
    permission: rank.jrmod
    permission message: &cYou don't have access to that command.
    trigger:
        if arg 1 is offline:
            send "&6[Beans] &cPlayer not found"
        else:      
            teleport arg 1 to player
            send "&6[Beans] &aTeleported %arg 1% to you!"
 
options:
    logo: &6[Beans]
    permission: rank.jrmod
    permissionalert: rank.srmod
   
command /vanish:
    permission: {@permission}
    permission message: &4You do not have access to this command!
    aliases: /v
    executable by: player
    trigger:
        if {vanish.%player%} is not set:
            hide the player from all players
            send "{@logo} &7You are &cVanish&7."
            set {vanish.%player%} to true
            loop all players:
                if loop-player has permission "{@permissionalert}":
                    send "" to loop-player
                    send "&8[&4Alert&8] &c%player% &7is now in vanish." to loop-player
                    send "" to loop-player
 
        else:
            reveal the player from all players
            send "{@logo} &7You are no longer &cVanish&7."
            delete {vanish.%player%}
            loop all players:
                if loop-player has permission "{@permissionalert}":
                    send "" to loop-player
                    send "&8[&4Alert&8] &c%player% &7is no longer in vanish." to loop-player
                    send "" to loop-player
 
 
on quit:   
    if {vanish.%player%} is set:
        delete {vanish.%player%}
on join:
    loop all players:
        if {vanish.%loop-player%} is true:
        reveal the loop-player from all players
        hide the loop-player from all players
       
command /vanishinfo [<offline player>]:
    aliases: /vinfo, /vi
    permission: {@permission}
    permission message: &4You do not have access to this command!
    aliases: /vinfo
    executable by: player
    trigger:
        if arg 1 is not set:
            if {vanish.%player%} is set:
                send ""
                send "&6[Beans] &e%player%"
                send "&8*&7Vanish: &aTrue"
                send ""
            else:
                send ""
                send "&6[Beans] &e%player%"
                send "&8*&7Vanish: &cFase"
                send ""
        if arg 1 is set:
            if {vanish.%arg 1%} is set:
                send ""
                send "&6[Beans] &e%arg 1%"
                send "&8*&7Vanish: &aTrue"
                send ""
            else:
                send ""
                send "&6[Beans] &e%arg 1%"
                send "&8*&7Vanish: &cFalse"
                send ""
 
command /ban [<offlineplayer>] [<text>]:
    permission: rank.jrmod
    permission message: &cYou don't have access to that command.
    trigger:
        if arg 2 is not set:
            send "&c/ban <player> <reason>"
        else:
            send "%nl% &6%player% &7banned &6%arg 1% &7for &6%arg 2%&7.%nl% " to all players
            set {_r} to "%nl% &6You've been banned!%nl%%nl% &ePunished by: &7%player%%nl% &eReason: &7%arg 2%%nl% "
            add "(%now%) &6%player% &7banned &6%arg 1% &e[%arg 2%]" to {punishments::%arg 1's uuid%::*}
            kick arg 1 due to {_r}
            ban arg 1 due to {_r}
 
command /unban [<offlineplayer>] [<text>]:
    permission: rank.jrmod
    permission message: &cYou don't have access to that command.
    trigger:
        if arg 1 is not set:
            send "&c/unban <player>"
        else:
            send "%nl% &6%player% &7unbanned &6%arg 1%&7.%nl% " to all players
            unban arg 1
 
command /kick [<offlineplayer>] [<text>]:
    permission: rank.jrmod
    permission message: &cYou don't have access to that command.
    trigger:
        if arg 2 is not set:
            send "&c/kick <player> <reason>"
        else:
            send "%nl% &6%player% &7kicked &6%arg 1% &7for &6%arg 2%&7.%nl% " to all players
            set {_r} to "%nl% &6You've been kicked!%nl%%nl% &ePunished by: &7%player%%nl% &eReason: &7%arg 2%%nl% "
            add "(%now%) &6%player% &7kicked &6%arg 1% &e[%arg 2%]" to {punishments::%arg 1's uuid%::*}
            kick arg 1 due to {_r} 
 
command /mute [<offlineplayer>] [<text>] [<text>]:
    permission: rank.jrmod
    permission message: &cYou don't have access to that command.
    trigger:
        if arg 3 is not set:
            send "&c/mute <player> <time | forever> <reason>"
        else:
            if arg 2 is "forever":
                send "%nl% &6%player% &7muted &6%arg 1% &7for &6%arg 3%&7.%nl% " to all players
                add "(%now%) &6%player% &7muted &6%arg 1% &e[%arg 3%]" to {punishments::%arg 1's uuid%::*}
                set {mute::%arg 1's uuid%} to "%nl% &6You've been muted!%nl%%nl% &ePunished by: &7%player%%nl% &eReason: &7%arg 3%%nl% "
            else:
                set {_t} to toTimespan(arg 2)
                if {_t} is not set:
                    send "&cInvalid Time!"
                else:
                    send "%nl% &6%player% &7muted &6%arg 1% &7for &6%arg 3%&7. &e[%{_t}%]%nl% " to all players
                    add "(%now%) &6%player% &7muted &6%arg 1% &e[%arg 3%] &e%{_t}%" to {punishments::%arg 1's uuid%::*}
                    set {mute::%arg 1's uuid%} to "%nl% &6You've been muted!%nl%%nl% &ePunished by: &7%player%%nl% &eReason: &7%arg 3%%nl% &eLength: &7%{_t}%%nl% &eTime muted: &7%now%%nl% "
                    set {mutet::%arg 1's uuid%} to {_t} from now
                    set {mutet2::%arg 1's uuid%} to {_t}
 
command /unmute [<offlineplayer>]:
    permission: rank.jrmod
    permission message: &cYou don't have access to that command.
    trigger:
        if arg 1 is not set:
            send "&c/unmute <player>"
        else:
            send "%nl% &6%player% &7unmuted &6%arg 1%&7.%nl% " to all players
            delete {mute::%arg 1's uuid%}
 
command /warn [<offlineplayer>] [<text>]:
    permission: rank.jrmod
    permission message: &cYou don't have access to that command.
    trigger:
        if arg 2 is not set:
            send "&c/warn <player> <reason>"
        else:
            send "%nl% &6%player% &7warned &6%arg 1% &7for &6%arg 2%&7.%nl% " to all players
            add "(%now%) &6%player% &7warned &6%arg 1% &e[%arg 2%]" to {punishments::%arg 1's uuid%::*}
 
command /history [<offlineplayer>]:
    permission: rank.jrmod
    permission message: &cYou don't have access to that command.
    trigger:
        if arg 1 is not set:
            send "&c/history <player>"
        else:
            loop {punishments::%arg 1's uuid%::*}:
                add "%loop-value%%nl%&f" to {_p::*}
            set {_p2} to "%{_p::*}%"
            replace all ", " and " and" with "" in {_p2}
            set {_p2} to "No Punishments" if {_p2} is "<none>"
            send ""
            send "<tooltip:%{_p2}%> &6%arg 1%'s Punishments <hover>"
            send ""
 
every second:
    loop all players:
        {mute::%loop-player's uuid%} is set
        {mutet::%loop-player's uuid%} is set
        if difference between {mutet::%loop-player's uuid%} and now is less than 1 second:
            send "&6[Beans] &eYou have been unmuted!" to loop-player
            delete {mute::%loop-player's uuid%}
            delete {mutet::%loop-player's uuid%}
            delete {mutet2::%loop-player's uuid%}
 
function toTimespan(t: text) :: timespan:
    set {_conversion::s} to "seconds"
    set {_conversion::m} to "minutes"
    set {_conversion::h} to "hours"
    set {_conversion::d} to "days"
    set {_l} to length of {_t}
    set {_a} to 1 if {_l} is 2
    set {_a} to 2 if {_l} is 3
    set {_l::1} to first {_a} characters of {_t}
    set {_l::2} to last character of {_t}
    set {_t} to "%{_l::1}% %{_conversion::%{_l::2}%}%"
    return ({_t} parsed as timespan)
 
function newPlayer(p: player):
    spawn({_p})
    set {_u} to {_p}'s uuid
    set {joined::%{_u}%} to true
    set {balance::%{_u}%} to 25
    set {blocks::%{_u}%} to 0
    set {kills::%{_u}%} to 0
    set {deaths::%{_u}%} to 0
    clear {_p}'s inventory
    give {_p} 1 diamond pickaxe
    set {_p}'s chestplate to elytra
 
on join:
    set player's gamemode to survival
    spawn(player)
    if {joined::%player's uuid%} is not set:
        newPlayer(player)
        set join message to "&6[Beans] &7Welcome &e%player% &7to the server! &e[##%size of all offline players%]"
    else:
        set join message to "&7%player% joined the server."
 
on quit:
    set quit message to "&7%player% left the server."
 
on damage of player:
    damage cause is fall
    cancel event
 
on break:
    if y-coordinate of event-block is less than 25:
        cancel event
 
on explosion:
    cancel event
 
every second:
    loop all players:
        if {balance::%loop-player's uuid%} is not set:
            newPlayer(loop-player)
        else if {blocks::%loop-player's uuid%} is not set:
            set {blocks::%loop-player's uuid%} to 0
            set {kills::%loop-player's uuid%} to 0
            set {deaths::%loop-player's uuid%} to 0
        set tablist name of loop-player to " &7%loop-player's prefix%%loop-player% &6&l%{bounty::%loop-player's uuid%} ? """"%"
        set tab header to "%nl%&f&l* &6Beans &f&l*%nl%        &7Elytra, pvp and mining      %nl% &7&l&m*&7 FaactoNetwork &7&l&m*%nl%" and footer to "%nl%&7(&nSeason 9&7)%nl%%nl%&f&l* &6Online: &f%number of all players%&e/&f%{maxPlayers}% &f&l*%nl%&7" for loop-player
 
on server ping:
    set {maxPlayers} to max player count
   
on food level change:
    if player's food level is not 20:
        set player's food level to 20
    else:
        cancel event
 
function spawn(p: player):
    set {_int} to a random integer between 1 and 4
    teleport {_p} to {spawn%{_int}%}
 
command /spawn [<offlineplayer>]:
    cooldown: 2 seconds
    cooldown message: &6[Beans] &7You're using that command too quickly!
    trigger:
        if arg 1 is not set:
            spawn(player)
        else:
            if player does not have permission "rank.admin":
                spawn(player)
            else:
                spawn(arg 1)
                send "&6[Beans] &7Teleported &e%arg 1% &7to spawn."
 
on respawn:
    wait 5 ticks
    spawn(player)
 
on death:
    delete {ct::%victim%}
    set {_a} to {balance::%victim's uuid%} / 100
    send "&6[Beans] &7You lost &e$%{_a}%&7, OMG!" to victim
    send "&6[Beans] &7Wowwww, you gained &e$%{_a}%&7." to attacker
    remove {_a} from {balance::%victim's uuid%}
    add {_e} to {balance::%attacker's uuid%}
    add 1 to {kills::%attacker's uuid%}
    add 1 to {deaths::%victim's uuid%}
 
on load:
    delete {ces::*}
 
    add "Laser" to {ces::*}
    add "Haste" to {ces::*}
    add "Merchant" to {ces::*}
    add "Superbreaker" to {ces::*}
    add "Explosive" to {ces::*}
 
    add "Nuke" to {ces::*}
    add "Nuke" to {ces::*}
    add "Autosell" to {ces::*}
    add "Autosell" to {ces::*}
    add "Upgrader" to {ces::*}
    add "Upgrader" to {ces::*}
    add "Lightning" to {ces::*}
    add "Lightning" to {ces::*}
 
    add "Xp" to {ces::*}
    add "Xp" to {ces::*}
    add "Xp" to {ces::*}
    add "Unbreakable" to {ces::*}
    add "Unbreakable" to {ces::*}
    add "Unbreakable" to {ces::*}
    add "Speed" to {ces::*}
    add "Speed" to {ces::*}
    add "Speed" to {ces::*}
    add "Furnace" to {ces::*}
    add "Furnace" to {ces::*}
    add "Furnace" to {ces::*}
 
on item damage:
    if lore of item contains "Unbreakable":
        cancel event
 
on mine:
    "%region at event-block%" is "mine in world ul_world"
    player is holding any pickaxe
    add 1 to {blocks::%player's uuid%}
    set {_n} to a random integer between 1 and 10000
 
    if {_n} is 1:
        set {_n2} to a random element out of {ces::*}
        send "%nl%&6[Beans] &e&l%player% &ejust got the %{_n2}% enchantment from mining! &6(0.01%% chance)%nl%" to all players
        ench(player, tool, {_n2})
 
    set {_lore} to lore of tool
 
    if player has not enough space for event-block:
        if {_lore} contains "Autosell":
            player command "/sell all"
 
    if {_lore} contains "Haste":
        remove haste from player
        apply haste 3 without particles to player for 3 seconds
       
    if {_lore} contains "Speed":
        remove speed from player
        apply speed 5 without particles to player for 3 seconds
 
    if {_lore} contains "Upgrader":
        chance of 20%:
            give player 1 of smelt(upgrade(event-block))
 
    if {_lore} contains "Xp":
        chance of 10%:
            set {_x} to a random number between 10 and 100
            add {_x} to xp of player
 
    if {_lore} contains "Lightning":
        chance of 5%:
            strike lightning effect at the event-block
            loop blocks below event-block:
                "%region at loop-block%" is "mine in world ul_world"
                loop-block is not bedrock
                chance of 75%:
                    if {_lore} contains "Xp":
                        chance of 3%:
                            set {_x} to a random number between 10 and 100
                            add {_x} to xp of player
                    set {_a} to a random integer between 1 and 3
                    add {_a} to xp of player
                    chance of 20%:
                        set {_l} to level of fortune on player's tool
                    if {_l} is set:
                        set {_b} to smelt(loop-block)
                        if {_lore} contains "Upgrader":
                            chance of 20%:
                                set {_b} to smelt(upgrade(loop-block))
                        give player {_l} of {_b}
                    else:
                        give player 1 of smelt(loop-block)            
                give player 1 of smelt(loop-block)
                set loop-block to air
 
    if {_lore} contains "Explosive":
        chance of 25%:
            loop all blocks in radius 1.5 around event-block:
                loop-block is not bedrock
                "%region at loop-block%" is "mine in world ul_world"
                chance of 75%:
                    if {_lore} contains "Xp":
                        chance of 3%:
                            set {_x} to a random number between 10 and 100
                            add {_x} to xp of player
                    set {_a} to a random integer between 1 and 3
                    add {_a} to xp of player
                    chance of 20%:
                        set {_l} to level of fortune on player's tool
                    if {_l} is set:
                        set {_b} to smelt(loop-block)
                        if {_lore} contains "Upgrader":
                            chance of 20%:
                                set {_b} to smelt(upgrade(loop-block))
                        give player {_l} of {_b}
                    else:
                        give player 1 of smelt(loop-block)
                chance of 10%:
                    add 1 to {blocks::%player's uuid%}
                set loop-block to air
 
    if {_lore} contains "Nuke":
        chance of 3.5%:
            loop all blocks in radius 4.5 around event-block:
                loop-block is not bedrock
                "%region at loop-block%" is "mine in world ul_world"
                chance of 25%:
                    if {_lore} contains "Xp":
                        chance of 2%:
                            set {_x} to a random number between 10 and 100
                            add {_x} to xp of player
                    set {_a} to a random integer between 1 and 3
                    add {_a} to xp of player
                    chance of 3%:
                        set {_l} to level of fortune on player's tool
                    if {_l} is set:
                        set {_b} to smelt(loop-block)
                        give player {_l} of {_b}
                    else:
                        give player 1 of smelt(loop-block)
                chance of 3%:
                    add 1 to {blocks::%player's uuid%}
                set loop-block to air
 
 
    if {_lore} contains "Laser":
        chance of 1%:
            loop blocks north of the event-block:
                "%region at loop-block%" contains "mine"
                loop-block is not bedrock
                chance of 10%:
                    add 1 to {blocks::%player's uuid%}
                give player 1 of smelt(loop-block)
                set loop-block to air
                show smoke at loop-block
            loop blocks south of the event-block:
                "%region at loop-block%" contains "mine"
                loop-block is not bedrock
                chance of 10%:
                    add 1 to {blocks::%player's uuid%}
                give player 1 of smelt(loop-block)
                set loop-block to air
                show smoke at loop-block
            loop blocks east of the event-block:
                "%region at loop-block%" contains "mine"
                loop-block is not bedrock
                chance of 10%:
                    add 1 to {blocks::%player's uuid%}
                give player 1 of smelt(loop-block)
                set loop-block to air
                show smoke at loop-block
            loop blocks west of the event-block:
                "%region at loop-block%" contains "mine"
                loop-block is not bedrock
                chance of 10%:
                    add 1 to {blocks::%player's uuid%}
                give player 1 of smelt(loop-block)
                set loop-block to air
                show smoke at loop-block
 
    if {_lore} contains "Furnace":
        if event-block is any ore:
            chance of 75%:
                set {_a} to a random integer between 1 and 3
                add {_a} to xp of player
        if player's tool is enchanted with fortune:
            chance of 20%:
                set {_l} to level of fortune on player's tool
        if {_l} is set:
            set {_b} to smelt(event-block)
            give player {_l} of {_b}
        else:
            give player 1 of smelt(event-block)
        set event-block to air
 
    if {ach::%player's uuid%::1} is not set:
        if {blocks::%player's uuid%} is greater than 5000:
            set {_n2} to a random element out of {ces::*}
            send "%nl%&6[Beans] &e&l%player% &ejust got the %{_n2}% enchantment from mining! &6(5000 blocks)%nl%" to all players
            ench(player, tool, {_n2})
            set {ach::%player's uuid%::1} to true
 
    if {ach::%player's uuid%::2} is not set:
        if {blocks::%player's uuid%} is greater than 25000:
            set {_n2} to a random element out of {ces::*}
            send "%nl%&6[Beans] &e&l%player% &ejust got the %{_n2}% enchantment from mining! &6(25000 blocks)%nl%" to all players
            ench(player, tool, {_n2})
            set {ach::%player's uuid%::2} to true
 
    if {ach::%player's uuid%::3} is not set:
        if {blocks::%player's uuid%} is greater than 50000:
            set {_n2} to a random element out of {ces::*}
            send "%nl%&6[Beans] &e&l%player% &ejust got the %{_n2}% enchantment from mining! &6(50000 blocks)%nl%" to all players
            ench(player, tool, {_n2})
            set {ach::%player's uuid%::3} to true
 
    if {ach::%player's uuid%::4} is not set:
        if {blocks::%player's uuid%} is greater than 100000:
            set {_n2} to a random element out of {ces::*}
            send "%nl%&6[Beans] &e&l%player% &ejust got the %{_n2}% enchantment from mining! &6(100000 blocks)%nl%" to all players
            ench(player, tool, {_n2})
            set {ach::%player's uuid%::4} to true
 
 
on rightclick with diamond pickaxe:
    if lore of tool contains "Superbreaker":
        if {sb::%player's uuid%} is set:
            send "&6[Superbreaker] &7Currently on cooldown."
        else:
            set {sb::%player's uuid%} to true
            set {_e} to level of efficiency on tool
            send "&6[Superbreaker] &7Activated."
            enchant tool with "efficiency %level of efficiency of tool + 5%" parsed as enchantment type
            wait 10 seconds
            loop all items in player's inventory:
                set {_e::%loop-item%} to level of efficiency on loop-item
                if {_e::%loop-item%} is greater than 5:
                    enchant loop-item with efficiency 5
            send "&6[Superbreaker] &7Disabled."
            wait 1 minute 30 seconds
            send "&6[Superbreaker] &7You can now use superbreaker again."
            delete {sb::%player's uuid%}
 
on load:
    delete {sb::*}
 
on join:
    loop all items in player's inventory:
        set {_e::%loop-item%} to level of efficiency on loop-item
        {_e::%loop-item%} is set
        if {_e::%loop-item%} is greater than 5:
            enchant loop-item with efficiency 5
    delete {sb::%player's uuid%}
 
function upgrade(i: item) :: item:
    set {_b} to coal ore if {_i} is stone
    set {_b} to iron ore if {_i} is coal ore
    set {_b} to gold ore if {_i} is iron ore
    set {_b} to diamond ore if {_i} is gold ore
    set {_b} to emerald ore if {_i} is diamond ore
    set {_b} to emerald block if {_i} is emerald ore
    return {_b}
 
function smelt(i: item) :: item:
    set {_s} to emerald if {_i} is emerald ore
    set {_s} to diamond if {_i} is diamond ore
    set {_s} to gold ingot if {_i} is gold ore
    set {_s} to iron ingot if {_i} is iron ore
    set {_s} to coal if {_i} is coal ore
    set {_s} to stone if {_i} is stone or cobblestone
    return {_s}
 
function ench(p: player, i: item, e: text):
    set {_l::*} to lore of {_i} split at "||"
    if {_l::*} contains "&d%{_e}%":
        send "&6[Enchanter] &7Your tool already has that enchantment. Here's $10k. &6Successfully added %{_e}% to your stored enchantments." to {_p}
        set {_u} to {_p}'s uuid
        add {_e} to {stored::%{_u}%::*}
        add 10000 to {balance::%{_u}%}
    else:
        set {_l2} to lore of {_i}
        if {_l2} is "":
            set lore of {_i} to "&d%{_e}%"
        else:
            set lore of {_i} to "%{_l2}%||&d%{_e}%"
 
command /stats [<offlineplayer>]:
    trigger:
        set {_p} to arg 1 ? player
        set {_u} to {_p}'s uuid
        if {blocks::%{_u}%} is not set:
            send "&cThat player has not joined."
        else:
            send ""
            send " &6[Stats] &7Viewing &e%{_p}%'s &7stats"
            send ""
            send " &eBlocks&7: %{blocks::%{_u}%}%"
            send " &eKills&7: %{kills::%{_u}%}%"
            send " &eDeaths&7: %{deaths::%{_u}%}%"
            send " &eBalance&7: $%short({balance::%{_u}%})%"
            send ""
 
command /pickaxe [<text>]:
    trigger:
        give player diamond pickaxe
 
command /ce [<text>]:
    trigger:
        send "&6[Beans] &eCustom enchantments are completely random. 1/10000 chance of getting them when you mine. There is /lotto which gives you a chance to get one for xp levels."
 
command /lotto [<text>]:
    trigger:
        if player is not holding any pickaxe:
            send "&cYou must be holding a pickaxe."
        else:
            if xp of player is less than 50000:
                send "&cYou don't have enough xp! (50k required, you have %xp of player%)"
            else:
                remove 50000 from xp of player
                set {_n} to a random integer between 1 and 100
                if {_n} is between 1 and 3:
                    set {_n2} to a random element out of {ces::*}
                    send "%nl%&6[Beans] &e&l%player% &ejust got the %{_n2}% enchantment from the lotto! &6(3%% chance)%nl%" to all players
                    ench(player, tool, {_n2})
                else:
                    send "&6&lUNLUCKY!!!"
 
command /xp [<text>]:
    trigger:
        add amount of xp bottles in player's inventory * random integer between 3 and 11 to player's xp
        remove 2304 xp bottles from player's inventory
 
command /store [<text>]:
    trigger:
        if arg 1 is not set:
            send "&c/store <enchantments | list>"
        else:
            if arg 1 is "list":
                loop {stored::%player's uuid%::*}:
                    if {_ces::*} does not contain loop-value:
                        add loop-value to {_ces::*}
                send ""
                send " &6[Beans] &7Stored CE's"
                send ""
                loop {_ces::*}:
                    send "&e%loop-value%"
                send ""
            else if arg 1 is "enchantments":
                set {_l::*} to lore of tool split at "||"
                replace all "||" with "" in {_l::*}
                loop {_l::*}:
                    if loop-value is not "":
                        add uncolored loop-value to {stored::%player's uuid%::*}
                        set lore of tool to ""
                        send "&7Successfully stored &6%loop-value%&7."
            else:
                player command "/store"
 
command /withdraw [<text>]:
    trigger:
        if arg 1 is not set:
            send "&c/withdraw <enchantment>"
        else:
            if {stored::%player's uuid%::*} does not contain arg 1:
                send "&cYou don't have that enchantment stored. (/store list)"
            else:
                if lore of tool contains arg 1:
                    send "&cYour tool already has that enchantment."
                else:
                    remove arg 1 from {stored::%player's uuid%::*}
                    set lore of tool to "%lore of tool%||&d%arg 1%"

```

```
every tick:
	loop all players:
		if {car::%loop-player%} is set:
			push loop-player's vehicle forwards at speed {speed::%loop-player%}
			{race} is set
			if block 1 under loop-player is red stained hardened clay:
				{winners::*} doesn't contain loop-player
				exit(loop-player)
				add loop-player to {winners::*}
				send "&a%loop-player% &acame in place %size of {winners::*}%&a! (%difference between now and {raceStart}%&a)" to all players
				teleport loop-player to {start}
				if size of {winners::*} is {race}:
					raceEnd()	
		if loop-player's name is {bad}:
			ignite loop-player for 1 day
			loop 50 times:
				strike lightning at loop-player if loop-player's health > 2
			if block at location of loop-player is water:
				set block at location of loop-player to air

on drop:
	cancel event if {inCar::%player%} is set

on right click with emerald block:
	{inCar::%player%} is set
	set {car::%player%} to true
	set tool to 1 redstone block named "&c&lSTOP &7(Right Click)"

on right click with redstone block:
	{inCar::%player%} is set
	delete {car::%player%}
	set tool to 1 emerald block named "&a&lGO &7(Right Click)"
	
on right click with carrot on a stick:
	{inCar::%player%} is set
	set {_s} to {speed::%player%} ? 1
	if {_s} is 1 or 2:
		add 1 to {speed::%player%}
	else:
		set {speed::%player%} to 1
	set name of tool to "&b&lSpeed (%{speed::%player%}%)"
	
on vehicle enter:
	delete {jcd::%player%}
	{boat::%player%} is not true
	set {boat::%player%} to true
	set {speed::%player%} to 1
	set {inCar::%player%} to true
	give player 1 emerald block named "&a&lGO &7(Right Click)"
	give player 1 carrot on a stick named "&b&lSpeed (1)"
	wait 3 ticks
	delete {boat::%player%}
	
on vehicle exit:
	{boat::%player%} is not true
	if {race} is set:
		{winners::*} doesn't contain player
		cancel event
	else:
		exit(player)

on place:
	player's gamemode is not creative
	if {inCar::%player%} is set:
		cancel event
		tool is air
		if {car::%player%} is not set:
			set tool to emerald block named "&a&lGO &7(Right Click)"
			set {car::%player%} to true
		else:
			set tool to redstone block named "&c&lSTOP &7(Right Click)"
			delete {car::%player%}
	cancel event if within(location of event-block, {track1}, {track2}) is true
	cancel event if event-block is boat
	
on break:
	player's gamemode is not creative
	cancel event if {inCar::%player%} is set 
	cancel event if within(location of event-block, {track1}, {track2}) is true
	
on damage:
	cancel event if within(location of victim, {track1}, {track2}) is true
	
on vehicle damage:
	within(location of player, {track1}, {track2}) is true
	cancel event if player's gamemode is not creative
	
on inventory click:
	cancel event if {inCar::%player%} is set
	
on craft:
	if item is any boat:
		cancel event
		
on quit:
	delete {car::%player%}
	delete {inCar::%player%}
	
command /race [<text>]:
	permission: admin
	trigger:
		if arg is not set:
			send "&c/race (start | end)"
		else:
			if arg is "end":
				raceEnd()
			else:
				set {_n} to 6
				loop 6 times:
					wait 1 second
					remove 1 from {_n}
					if {_n} is between 1 and 5:
						send "&bRace starting in %{_n}% &bseconds!" to all players
					else:
						send "&dGO!" to all players
						set {race} to size of {incar::*}
						set {raceStart} to now
						delete {winners::*}
						loop all blocks within block at {race1} and block at {race2}:
							set loop-block to air
					
function raceEnd():
	delete {racestart}
	delete {winners::*}
	send "&cThe race has ended!" to all players
	kill all boats
	loop {boats::*}:
		spawn boat at loop-value
	loop all blocks within block at {race1} and block at {race2}:
		set loop-block to iron bars
	delete {race}

function exit(p: player):
	delete {inCar::%{_p}%}
	delete {speed::%{_p}%}
	delete {car::%{_p}%}
	remove all emerald blocks named "&a&lGO &7(Right Click)" from {_p}'s inventory
	remove all redstone blocks named "&c&lSTOP &7(Right Click)" from {_p}'s inventory
	remove all carrot on a stick named "&b&lSpeed (1)" from {_p}'s inventory
	remove all carrot on a stick named "&b&lSpeed (2)" from {_p}'s inventory
	remove all carrot on a stick named "&b&lSpeed (3)" from {_p}'s inventory
	remove all slime block named "&d&lJump &7(Right Click)" from {_p}'s inventory

on chat:
	if {muted::%player%} is not set:
		set chat format to "&7%player(player)%&8: &f%message%"
	else:
		cancel event
		send "&cYou are muted, you may not speak."

on chat:
	if player has permission "mod":
		set chat format to "&7%player(player)%&8: &f%message%"
	else:
		if {chatmute} is set:
			cancel event
			send "&cThe chat is currently muted."
		else:
			if {chatmute} is not set:
				set chat format to "&7%player(player)%&8: &f%message%"

			
command /discord [<text>]:
	trigger:
		send "<link:https://discord.gg/gWePYJT>&7Join or receive blacklist. (Click here)"
		
every 2 minutes:
	add "%nl%&7You can buy stuff with &b/shop&7.%nl%" to {_tips::*}
	add "%nl%&7You can sell stuff with &b/sell&7.%nl%" to {_tips::*}
	add "%nl%&7Upgrade your diamond pickaxe by &bShift + Right Clicking &7it.%nl%" to {_tips::*}
	add "%nl%&7Join our discord with /discord.%nl%" to {_tips::*}
	
	send "%random element out of {_tips::*}%" to all players 
	
command /lb [<text>]:
	trigger:
		if {%arg%::*} is not set:
			send "&c/lb (stat)"
		else:
			
			set {_top::*} to sorted {%arg%::*} from highest to lowest with format "@index"
			loop {_top::*}:
				("%loop-value%" parsed as offline player) is not "<none>", "null" or null
				add 1 to {_n}
				set {_t::%{_n}%} to ("%loop-value%" parsed as offline player)
			send ""
			send " &bTop %arg%"
			send ""
			loop 5 times:
				send " &b##%loop-number% &7%{_t::%loop-number%}% &b%short({%arg%::%{_t::%loop-number%}%})%" if {_t::%loop-number%} is set
			send ""

on load:
	reset("normal")
	delete {party}
	
	delete {ct::*}
	
function level(l: number, p: player, rp: boolean) :: text:

	set {_c} to "&7" if {_l} is between 1 and 9
	set {_c} to "&2" if {_l} is between 10 and 29
	set {_c} to "&d" if {_l} is between 30 and 49
	set {_c} to "&6" if {_l} is between 50 and 59
	set {_c} to "&b" if {_l} is between 60 and 79
	set {_c} to "&a" if {_l} is between 80 and 99
	set {_c} to "&c&l" if {_l} >= 100
	
	set {_level} to "&8[%{_c}%%{_l}%&8]"
	
	set {_pr} to {prestige::%{_p}%}
	set {_prestige} to ""
	set {_prestige} to "&6&l%{_pr}%♦ " if {_pr} is greater than 0
	set {_prestige} to "" if {_rp} is false
	
	return "%{_prestige}%%{_level}%"
	
function player(p: player) :: text:
	return " %level({level::%{_p}%}, {_p}, true)% %{_p}'s prefix%%{_p}%%{tags::%{tag::%{_p}%}%} ? """"% &6%{bounty::%{_p}%} ? """"%"
	
function xpr(p: player) :: number:
	set {_l} to {level::%{_p}%}
	set {_r} to ({_l} * 200) * ({prestige::%{_p}%} + 1)
	return {_r} if {_l} is not 100
	return 0 if {_l} is 100
	
function xp(b: block) :: number:
	return 1 if {_b} is stone
	return 2 if {_b} is coal ore
	return 3 if {_b} is iron ore
	return 5 if {_b} is gold ore
	return 7 if {_b} is diamond ore
	return 10 if {_b} is emerald ore
	return 10 if {_b} is diamond block
	
function short(n: num) :: string:
    set {_units::*} to "K", "M", "B", "T", "q", "Q", "s", "S" and "O"
    loop size of {_units::*} times:
        {_n} >= 1000 ^ loop-num:
            {_n} < 1000 ^ (loop-num + 1)
            return "%{_n} / 1000 ^ loop-num%%{_units::%loop-num%}%"
    return "%{_n}%"
	
function deathXP(a: player, v: player) :: number:
	add {level::%{_v}%} / 2 to {xp::%{_a}%}
	return {level::%{_v}%} / 2
	
function health(p: player) :: number:
	if {_p}'s health <= 1:
		return 1 
	else:
		return {_p}'s health
		
function sb(p: player):
	wipe {_p} sidebar
	set name of sidebar of {_p} to "       &6&lBEANS &7[%amount of players%&7/42]     "
	set score "" in sidebar of {_p} to 8
	set score " &6Kills: &7%{kills::%{_p}%}%" in sidebar of {_p} to 7
	set score " &6Deaths: &7%{deaths::%{_p}%}%" in sidebar of {_p} to 6
	set score "&r" in sidebar of {_p} to 5
	set score " &6Money: &7$%short({balance::%{_p}%})%" in sidebar of {_p} to 4
	set score " &6Tokens: &7%{tokens::%{_p}%}%" in sidebar of {_p} to 3
	set score "&r&r" in sidebar of {_p} to 2
	set score " &6Blocks: &7%short({blocks::%{_p}%})%" in sidebar of {_p} to 1
	set score "&r&r&r" in sidebar of {_p} to 0

every 5 minutes:
	{party} is not set
	set {_i} to a random integer between 1 and 100
	reset("normal") if {_i} is between 1 and 90
	if {_i} is between 91 and 100:
		command "/mine party" if {party} is not set
		wait 10 second
		command "/mine party" if {party} is set
	send "%nl% &7Clearing all drops in &610 seconds&7.%nl%" to all players
	wait 5 seconds
	set {_n} to 6
	loop 5 times:
		remove 1 from {_n}
		send " &7Clearing all drops in &6%{_n}% &6seconds&7." to all players
		wait 1 second
	send "%nl% &7Successfully cleared &6%amount of dropped items in all worlds% &7drops!%nl%" to all players
	kill all dropped items in all worlds
		
every second:
	loop all players:
	
		set loop-player's tab list header to "%nl%   &6&lBEANS%nl%  &7epic mine pvp%nl% %nl%"
		set loop-player's tab list footer to "%nl%   %player(loop-player)% %nl%   &6Ping: &7%loop-player's ping%&7ms%nl%  &6TPS: &7%tps from last minute%%nl% %nl%"
		
		set score "&4❤" below loop-player to health(loop-player) for all players
		
		if {xp::%loop-player%} >= xpr(loop-player):
			if {level::%loop-player%} < 99:
				add 1 to {level::%loop-player%}
				send " &7You leveled up to %level({level::%loop-player%}, loop-player, true)%&7." to loop-player
			if {level::%loop-player%} is 99:
				send "%nl% %player(loop-player)% &7has achieved level %level(100, loop-player, true)%&7!%nl%" to all players
				set {xp::%loop-player%} to 0
				set {level::%loop-player%} to 100
		set {level::%loop-player%} to 1 if {level::%loop-player%} isn't set
		add 0 to {kills::%loop-player%}
		add 0 to {deaths::%loop-player%}
		add 0 to {balance::%loop-player%}
		add 0 to {prestige::%loop-player%}
		add 0 to {tokens::%loop-player%}
		add 0 to {max::%loop-player%}
		add 0 to {blocks::%loop-player%}
		add 1 second to {playtime::%loop-player%}
		set loop-player's tab list name to player(loop-player)
		if {ct::%loop-player%} is set:
			{v::%loop-player%} isn't set
			send action bar "&cYou are tagged for %{ct::%loop-player%}% seconds." to loop-player
			remove 1 from {ct::%loop-player%}
			delete {ct::%loop-player%} if {ct::%loop-player%} is 0
		else:
			{v::%loop-player%} isn't set
			send action bar "%level({level::%loop-player%}, loop-player, false)% &8-> &6%{xp::%loop-player%} ? 0%&8/&6%xpr(loop-player)% &8-> %level({level::%loop-player%} + 1, loop-player, false)%" to loop-player
		if {v::%loop-player%} is set:
			if loop-player has permission "mod":
				hide loop-player from all players where [input doesn't have permission "mod"]
				send action bar "&a&lYou are vanished!" to loop-player
			else:
				delete {v::%loop-player%}
		else:
			loop-player has permission "mod"
			reveal loop-player to all players
		
every 10 seconds:
	loop all players:
		sb(loop-player)
			
on respawn:
	wait 3 ticks
	teleport player to {spawn}
	
on step on slime block:
	push player upward at speed 3
	push player forward at speed 10
	
on food level change:
	cancel event
	
on break:
	event is not canceled
	within(location of event-block, {mine1}, {mine2}) is true
	add 1 to {blocks::%player%}
	add xp(block) to {xp::%player%}
	chance of 0.05%:
		send "&7You've recieved &a1x Mine Key&7."
		give player 1 tripwire hook named "&a&lMine Key &7(Right Click)" with lore "&7Right click to open." 
	
on damage of player:
	cancel event if damage type is fall or suffocation
	within(location of victim, {spawn1}, {spawn2}) isn't true
	attacker isn't victim
	attacker is a player
	set {ctP::%attacker%} to victim
	set {ctP::%victim%} to attacker
	set {ct::%attacker%} to 10
	set {ct::%victim%} to 10
	
on join:
	reset player's walking speed
	set join message to "&7%player(player)%&7joined." if player has played before
	if {ct::%player%} is set:
		delete {ct::%player%}
		send "&cYou left while combat tagged. A death has been added to your stats."
		teleport player to {spawn}
	if player has not played before:
		teleport player to {spawn}
		player command "/kit"
		set join message to "&7%player% &7joined. &a(##%amount of offline players%)" 
	if {v::%player%} is set:
		send "%nl% &aYou are vanished!%nl%"
	wait 1.1 seconds
	sb(player)
	if {q::%player%::*} is set:
		loop {q::%player%::*}:
			send loop-value to player
			remove loop-value from {q::%player%::*}
			command loop-value
		
on quit:
	set quit message to "&7%player(player)%&7left the server."
	player's gamemode is not creative
	if {ct::%player%} is set:
		add 1 to {deaths::%player%}
		add 1 to {kills::%{ctP::%player%}%}
		set quit message to "&c%player% &cleft while combat tagged by &c%{ctP::%player%}%."
		delete {ctP::%player%}
		
on death:
	delete {ct::%victim%}
	delete {ctP::%victim%}
	add 1 to {kills::%attacker%}
	add 1 to {deaths::%victim%}
	send "&7You killed &c%victim%&7. &b(+%deathXP(attacker, victim)%&b xp)" to attacker
	send "&7You were killed by &c%attacker%&7." to victim
	victim is not attacker
	if {bounty::%victim%} is set:
		send "%nl% &b%victim%&b's &7bounty of &b%{bounty::%victim%}% &7has been claimed by &b%attacker%&7!%nl%" to all players
		add {bounty::%victim%} to {tokens::%attacker%}
		delete {bounty::%victim%}
	
on command:
	player's name is set
	player's gamemode is not creative
	{ct::%player%} is set
	if command is "spawn":
		cancel event
		player command "/ct"
	
on inventory close:
	if inventory name of event-inventory contains "blocks", "combat" or "misc":
		wait 3 ticks
		inventory name of player's inventory doesn't contain "blocks", "combat" or "misc"
		shop(player, "main")
	type of event-inventory is anvil inventory
	if targeted block is not unbroken anvil or westward unbroken anvil:
		set block 1 above targeted block to unbroken anvil if facing of block 1 above targeted block is north
		set block 1 above targeted block to westward unbroken anvil if facing of block 1 above targeted block is west
	set targeted block to unbroken anvil if facing of targeted block is north
	set targeted block to westward unbroken anvil if facing of targeted block is west
	
on right click:
	if name of tool contains "mine key":
		type of tool is tripwire hook
		cancel event
		set {_c} to amount of tool in player's inventory
		loop {_c} times:
			set {_i} to random integer between 1 and 100
			add random integer between 500 and 2500 to {_$} if {_i} is between 1 and 60
			add random integer between 100 and 500 to {_xp} if {_i} is between 61 and 90
			add 1 to {_k} if {_i} is between 91 and 100
		if {_$} is set:
			add {_$} to {balance::%player%}
			send "&a+$%short({_$})%"
		if {_xp} is set:
			add {_xp} to {xp::%player%}
			send "&b+%short({_xp})% &bxp"
		if {_k} is set:
			send "&7You've received &6%{_k}%&6x Rare key&7."
			give player {_k} of prismarine shard named "&6&lRare key &7(Right Click)" with lore "&7Right click to open."	
						
		remove {_c} of tool from player's inventory
		
	if name of tool contains "rare key":
		type of tool is prismarine shard
		cancel event
		set {_c} to amount of tool in player's inventory
		loop {_c} times:
			set {_i} to random integer between 1 and 100
			add random integer between 5000 and 20000 to {_$} if {_i} is between 1 and 60
			add random integer between 1000 and 5000 to {_xp} if {_i} is between 61 and 90
			add 1 to {_k} if {_i} is between 91 and 100
		if {_$} is set:
			add {_$} to {balance::%player%}
			send "&a+$%short({_$})%"
		if {_xp} is set:
			add {_xp} to {xp::%player%}
			send "&b+%short({_xp})% &bxp"
		if {_k} is set:
			send "&7You've received &5%{_k}%&5x Epic key&7."
			give player {_k} of ender eye named "&5&lEpic key &7(Right Click)" with lore "&7Right click to open."	
						
		remove {_c} of tool from player's inventory
		
	if name of tool contains "epic key":
		type of tool is eye of ender
		cancel event
		set {_c} to amount of tool in player's inventory
		loop {_c} times:
			set {_i} to random integer between 1 and 100
			add random integer between 25000 and 50000 to {_$} if {_i} is between 1 and 60
			add random integer between 10000 and 10000 to {_xp} if {_i} is between 61 and 90
			add 1 to {_k} if {_i} is between 91 and 100
		if {_$} is set:
			add {_$} to {balance::%player%}
			send "&a+$%short({_$})%"
		if {_xp} is set:
			add {_xp} to {xp::%player%}
			send "&b+%short({_xp})% &bxp"
		if {_k} is set:
			set {_t} to random integer between 1 and 4
			send "&7You've received &c%{_t}% &ctokens&7."
			add {_t} to {tokens::%player%}
						
		remove {_c} of tool from player's inventory
	
command /ct [<text>]:
	trigger:
		if {ct::%player%} isn't set:
			send "&cYou aren't combat tagged."
		else:
			send "&cYou're tagged for %{ct::%player%}% &cmore seconds."
					
command /mine [<text>]:
	permission: mod
	permission message: &cYou don't have access to that command.
	trigger:
		if arg is not set:
			send "&c/mine (reset, party)"
		else:
			if arg is "reset":
				reset("normal")
				send "%nl%&7The mine has been reset by &7%player(player)%&7.%nl%"
			else if arg is "party":
				player has permission "admin"
				if {party} is not set:
					send "%nl%&7%player(player) ? ""Console""% &7has started a mine party!%nl%"
					set {party} to true
					reset("party")
				else:
					send "%nl%&7%player(player) ? ""Console""% &7has ended the mine party :(%nl%"
					delete {party}
					reset("normal")
			else:
				player command "/mine"
			
command /playtime [<offlineplayer=%player%>]:
	trigger:
		if {playtime::%arg%} isn't set:
			send "&cThat player has no playtime."
		else:
			send "&6%arg% &7has &6%{playtime::%arg%}% &7playtime."
			
command /spawn [<text>]:
	trigger:
		if {perks::%player%::*} is set:
			if {perks::%player%::*} contains "instant tp":
				set {_t} to true
		set {_t} to true if player's gamemode is creative
		teleport player to {spawn} if {_t} is true
		{_t} is not true
		send "&7Teleporting to spawn in 3 seconds. Don't move."
		set {_s} to 3
		set {_l} to player's location
		loop 3 times:
			wait 1 second
			remove 1 from {_s}
			if "%player's location%" isn't "%{_l}%":
				send "&cTeleport request canceled."
				stop loop
			else:
				if {_s} is 0:
					teleport player to {spawn}
					send "&7Teleported."
				else:
					send "&7Teleporting to spawn in %{_s}% &7seconds."
					
command /tpa [<offlineplayer>]:
	trigger:
		if arg is not set:
			send "&c/tpa (player)"
		else:
			if arg is offline:
				send "&cThat player is offline."
			else:
				if {requests::%arg%} is set:
					send "&cThat player has requests disabled."
				else:
					set {tpr::%arg%} to player
					send "&7Sent a teleport request to &b%arg%&7."
					send "&b%player% &7sent you a teleport request. &b<command:/tpyes>(Click to accept)" to arg
	
command /tpyes [<text>]:
	trigger:
		if {tpr::%player%} is not set:
			send "&cYou have no incoming requests."
		else:
			set {_p} to {tpr::%player%}
			send "&7Accepted &b%{_p}%&b's &7request."
			if {perks::%{_p}%::*} is set:
				if {perks::%{_p}%::*} contains "instant tp":
					set {_t} to true
			set {_t} to true if {_p}'s gamemode is creative
			teleport {_p} to player if {_t} is true
			{_t} is not true
			send "&7Teleporting in 3 seconds. Don't move." to {_p}
			set {_s} to 3
			set {_l} to {_p}'s location
			loop 3 times:
				wait 1 second
				remove 1 from {_s}
				if "%{_p}'s location%" isn't "%{_l}%":
					send "&cTeleport request canceled." to {_p}
					send "&cTeleport request canceled."
					stop loop
				else:
					if {_s} is 0:
						teleport {_p} to player
						send "&7Teleported."
					else:
						send "&7Teleporting in %{_s}% &7seconds." to {_p}
						
			delete {tpr::%player%}
		

command /tpno [<text>]:
	trigger:
		set {_p} to {tpr::%player%}
		if {tpr::%player%} is not set:
			send "&cYou have no incoming requests."
		else:
			send "&7Denied &b%{_p}%&b's &7request."
			send "&b%player% &7denied your request." to {_p}
			delete {tpr::%player%}

command /tptoggle [<text>]:
	trigger:
		if {requests::%player%} is not set:
			set {requests::%player%} to true
			send "&7You will no longer receive tpa requests."
		else:
			delete {requests::%player%}
			send "&7You will now receive tpa requests."
					
command /kit [<text>]:
	cooldown: 10 minutes
	cooldown message: &cYou must wait 10 minutes before you can receive the starter kit again.
	trigger:
		give player 1 iron pickaxe
		give player 1 elytra
	
command /prestige [<text>]:
	trigger:
		if {level::%player%} is not 100:
			send "&cYou require level 100 to prestige."
		else:
			send "%nl%%nl% %player(player)% &7has prestiged!%nl%%nl%" to all players
			add 1 to {prestige::%player%}
			add ({prestige::%player%} * 2) to {tokens::%player%}
			send "&a+%({prestige::%player%} * 2)% tokens!"
			set {level::%player%} to 1
	
command /sell [<text>]:
	trigger:
		if arg 1 is not set:
			send "&c/sell (hand | all)"
		else:
		
			set {_worth::cobblestone block} to 1
			set {_worth::coal} to 2
			set {_worth::iron ore} to 5
			set {_worth::gold ore} to 10
			set {_worth::diamond} to 20
			set {_worth::emerald} to 30
			set {_worth::diamond block} to 180
			
			if arg is "hand":
				set {_t} to "%type of tool%"
				if {_worth::%{_t}%} is not set:
					send "&cThat item is not sellable."
				else:
					set {_c} to amount of tool in player's inventory
					set {_$} to {_c} * {_worth::%{_t}%}
					send "&7Sold &e%{_c}%&ex %type of tool% &7for &e$%{_$}%&7."
					add {_$} to {balance::%player%}
					remove {_c} of tool from player's inventory
				
			else if arg is "all":
				loop all items in player's inventory:
					set {_t} to "%type of loop-item%"
					if {_worth::%{_t}%} is set:
						set {_c} to amount of loop-item in player's inventory
						add {_c} to {_total}
						add {_worth::%{_t}%} * {_c} to {_$}
						remove 2304 of loop-item from player's inventory
				if {_$} is set:
					send "&7Sold &e%{_total}%&ex &7items for &e$%{_$}%&7."
					add {_$} to {balance::%player%}
				else:
					send "&cYou had no sellable items."
			else:
				player command "/sell"
				

function purchase(p: player, i: item, c: number, co: number):
    set {_bal} to {balance::%{_p}%}
    if {_bal} is less than {_co}:
        set {_amount} to {_co} - {balance::%{_p}%}
        send "&7You need &e$%{_amount}% &7more to purchase that." to {_p}
    else:
        if {_p} has not enough space for {_c} of {_i}:
            send "&cYour inventory is full!" to {_p}
        else:
            if {_i} is diamond helmet:
                give {_p} all diamond armor
            else:
                give {_p} {_c} of {_i}
            remove {_co} from {balance::%{_p}%}
            shop({_p}, {shop::%{_p}%})
            send "&7You've purchased &f%{_c}%x %{_i}% &7for &e$%{_co}%&7." to {_p}
 
function shop(p: player, t: text):
    set {shop::%{_p}%} to {_t}
    set {_bal} to short({balance::%{_p}%})
    set {_lore} to "&7Click to purchase."

    open virtual chest inventory with size 1 named "&8%{_t}% &3($%{_bal}%)" to {_p}
 
    if {_t} is "main":
        wait 3 ticks
        format gui slot 3 of {_p} with oak wood log named "&a&lBlocks Shop" with lore "&7Click to view the blocks shop." to run function shop({_p}, "blocks")
        format gui slot 4 of {_p} with diamond sword named "&3&lCombat Shop" with lore "&7Click to view the combat shop." to run function shop({_p}, "combat")
        format gui slot 5 of {_p} with lapis named "&b&lMisc Shop" with lore "&7Click to view the misc shop." to run function shop({_p}, "misc")
 
    else if {_t} is "blocks":
        format gui slot 2 of {_p} with prismarine named "&f16x &bPrismarine &7(&n$100&7)" with lore {_lore} to run function purchase({_p}, prismarine, 16, 100)
        format gui slot 3 of {_p} with sea lantern named "&f4x &bSea Lantern &7(&n$100&7)" with lore {_lore} to run function purchase({_p}, sea lantern, 4, 100)
        format gui slot 4 of {_p} with oak wood log named "&f16x &bLogs &7(&n$60&7)" with lore {_lore} to run function purchase({_p}, oak wood log, 16, 60)
        format gui slot 5 of {_p} with white wool block named "&f16x &bWool &7(&n$60&7)" with lore {_lore} to run function purchase({_p}, white wool block, 16, 60)
        format gui slot 6 of {_p} with stone named "&f64x &bStone &7(&n$20&7)" with lore {_lore} to run function purchase({_p}, stone, 64, 20)
 
    else if {_t} is "combat":
        format gui slot 2 of {_p} with diamond helmet named "&f&l1x &bSet of Diamond armor &7(&n$100&7)" with lore {_lore} to run function purchase({_p}, diamond helmet, 1, 100)
        format gui slot 3 of {_p} with diamond sword named "&f&l1x &bDiamond Sword &7(&n$50&7)" with lore {_lore} to run function purchase({_p}, diamond sword, 1, 50)
        format gui slot 4 of {_p} with bow named "&f&l1x &bBow&7(&n$50&7)" with lore {_lore} to run function purchase({_p}, bow, 1, 50)
        format gui slot 5 of {_p} with arrow named "&f&l4x &bArrows &7(&n$20&7)" with lore {_lore} to run function purchase({_p}, arrow, 4, 20)
        format gui slot 6 of {_p} with totem of undying named "&f&l1x &bTotem of Undying &7(&n$500&7)" with lore {_lore} to run function purchase({_p}, totem of undying, 1, 500)
 
    else if {_t} is "misc":
        format gui slot 1 of {_p} with elytra named "&f&l1x &bElytra &7(&n$5&7)" with lore {_lore} to run function purchase({_p}, elytra, 1, 5)
        format gui slot 2 of {_p} with lapis named "&f&l16x &bLapis &7(&n$20&7)" with lore {_lore} to run function purchase({_p}, lapis, 16, 20)
        format gui slot 3 of {_p} with book named "&f&l4x &bBook &7(&n$50&7)" with lore {_lore} to run function purchase({_p}, book, 4, 50)
        format gui slot 4 of {_p} with firework named "&f&l16x &bFirework &7(&n$50&7)" with lore {_lore} to run function purchase({_p}, firework, 16, 50)
        format gui slot 5 of {_p} with xp bottle named "&f&l16x &bXP Bottles &7(&n$50&7)" with lore {_lore} to run function purchase({_p}, xp bottle, 16, 50)
        format gui slot 6 of {_p} with diamond pickaxe named "&f&l1x &bDiamond Pickaxe &7(&n$100&7)" with lore {_lore} to run function purchase({_p}, diamond pickaxe, 1, 100)
        format gui slot 7 of {_p} with golden apple named "&f&l4x &bGolden Apple &7(&n$250&7)" with lore {_lore} to run function purchase({_p}, golden apple, 4, 250)

command /shop [<text>]:
    trigger:
        set {_s} to arg ? "main"
        shop(player, {_s})
		
command /balance [<offlineplayer=%player%>]:
	aliases: /bal
	trigger:
		if {balance::%arg%} is not set:
			send "&cThat player has no money."
		else:
			send "&6%arg% &7has &6$%short({balance::%arg%})%&7."

command /tokens [<offlineplayer=%player%>]:
	aliases: /t
	trigger:
		if {tokens::%arg%} is not set:
			send "&cThat player has no tokens."
		else:
			send "&6%arg% &7has &6%short({tokens::%arg%})%&7."

			
command /stats [<offlineplayer=%player%>]:
	trigger:
		if {kills::%arg%} is not set:
			send "&cThat player has no stats."
		else:
		
			add "Kills" to {_stats::*}
			add "Deaths" to {_stats::*}
			add "Blocks" to {_stats::*}
			add "Balance" to {_stats::*}
			add "Playtime" to {_stats::*}
			
			send ""
			send "&7%player(arg)%&7's stats" if arg is online
			send " &7%arg%&7's stats" if arg is offline
			send ""
			loop {_stats::*}:
				send " &6%loop-value%&8: &7%{%loop-value%::%arg%} ? 0%"
			send ""
			
command /fix [<text>]:
	permission: admin
	permission message: &cBuy this command with /buy.
	trigger:
		loop all items in player's inventory:
			repair loop-item by 10000 if durability of loop-item is greater than 1
		send "&7Repaired all items in your inventory."

command /bounty [<offlineplayer>] [<integer>]:
	trigger:
		if arg 2 isn't set:
			send "&c/bounty (player) (tokens)"
		else:
			if arg 1 is offline:
				send "&cThat player is offline."
			else:
				if arg 2 is less than 1:
					send "&cBounty must be greater than 1."
				else:
					if {tokens::%player%} < arg 2:
						send "&cYou don't have enough tokens for that."
					else:
						remove arg 2 from {tokens::%player%}
						add arg 2 to {bounty::%arg 1%}
						send "%nl% &b%arg 1% &7now has a bounty of &b%{bounty::%arg 1%}%&7!%nl%" to all players
						
command /v [<text>]:
	permission: mod
	permission message: &cYou don't have access to that command.
	trigger:
		if {v::%player%} isn't set:
			set {v::%player%} to true
			send "&7You are now vanished."
		else:
			delete {v::%player%}
			send "&7You are no longer vanished."
			
command /pay [<offlineplayer>] [<integer>]:
	trigger:
		if arg 2 is not set:
			send "&c/pay (player) (amount)"
		else:
			if arg 1 is offline:
				send "&cThat player is offline."
			else:
				if arg 2 is less than 1000:
					send "&cYou must pay atleast $1k."
				else:
					if {balance::%player%} < arg 2:
						send "&cYou don't have enough money."
					else:
						send " &7Successfully paid &b%arg 1% &b%short(arg 2)%&7."
						send " &b%player% &7send you &b%short(arg 2)%&7." to arg 1
						remove arg 2 from {balance::%player%}
						add arg 2 to {balance::%arg 1%}
		
command /warp [<text>]:
	trigger:
		if arg is not set:
			loop {warps::*}:
				add formatted "<command:/warp loop-index>&7%loop-index%" to {_warps::*}
			send ""
			send " &bWarps:"
			send formatted " &7%{_warps::*}%"
			send ""
		else:
			if {warps::%arg%} is not set:
				player command "/warps"
			else:
				if {perks::%player%::*} is set:
					if {perks::%player%::*} contains "instant tp":
						set {_t} to true
				set {_t} to true if player's gamemode is creative
				teleport player to {warps::%arg%}
				{_t} is not true
				send "&7Teleporting in 3 seconds. Don't move."
				set {_s} to 3
				set {_l} to player's location
				loop 3 times:
					wait 1 second
					remove 1 from {_s}
					if "%{_p}'s location%" isn't "%{_l}%":
						send "&cTeleport request canceled."
						stop loop
					else:
						if {_s} is 0:
							teleport player to {warps::%arg%}
							send "&7Teleported."
						else:
							send "&7Teleporting in %{_s}% &7seconds."

command /kickbots [<text>]:
    permission: mod
    permission message: &cYou don't have access to that command.
    trigger:
        kick all players where [{level::%input%} < 3] due to "possible bot"

function pvSize(p: player) :: integer:
	return 6 if {_p} has permission "maniac"
	return 5 if {_p} has permission "godfather"
	return 4 if {_p} has permission "kingpin"

command /process [<offlineplayer>] [<text>] [<text>]:
	permission: admin
	permission message: &cYou don't have access to that command.
	trigger:
		if arg 2 is not set:
			send "&c/process (player) (package | list) (additional info)"
		else:
			if arg 1 is offline:
				add "/process %arg 1% %arg 2% %arg 3%" to {q::%arg 1%::*}
			else:
				if arg 2 is "list":
					send ""
					send " &bList of packages:"
					send " &7- Kingpin"
					send " &7- Godfather"
					send " &7- Maniac"
					send ""
				else:
					if arg 2 is not "kingpin", "godfather" or "maniac":
						player command "/process list"
					else:
						broadcast ""
						broadcast "&3[DONATION] &b%arg 1% &7has purchased &b%arg 2%! &7(/buy)"
						broadcast ""
						if arg 2 is "kingpin":
							add 1 ender eye named "&5&lEpic key &7(Right Click)" with lore "&7Right click to open." to arg 1's inventory
							add 3 prismarine shard named "&6&lRare key &7(Right Click)" with lore "&7Right click to open." to arg 1's inventory
							add 5 tripwire hook named "&a&lMine Key &7(Right Click)" with lore "&7Right click to open." to arg 1's inventory
							add .5 to {sellmulti::%arg 1%}
							add .5 to {xpmulti::%arg 1%}
							add 5 to {tokens::%arg 1%}
							add "kingpin" to arg 1's groups
						if arg 2 is "godfather":
							add 3 ender eye named "&5&lEpic key &7(Right Click)" with lore "&7Right click to open." to arg 1's inventory
							add  5 prismarine shard named "&6&lRare key &7(Right Click)" with lore "&7Right click to open." to arg 1's inventory
							add 10 tripwire hook named "&a&lMine Key &7(Right Click)" with lore "&7Right click to open." to arg 1's inventory 
							add .75 to {sellmulti::%arg 1%}
							add .75 to {xpmulti::%arg 1%}
							add 10 to {tokens::%arg 1%}
							add "godfather" to arg 1's groups					
						if arg 2 is "maniac":
							add 5 ender eye named "&5&lEpic key &7(Right Click)" with lore "&7Right click to open." to arg 1's inventory
							add 10 prismarine shard named "&6&lRare key &7(Right Click)" with lore "&7Right click to open." to arg 1's inventory
							add 20 tripwire hook named "&a&lMine Key &7(Right Click)" with lore "&7Right click to open." to arg 1's inventory
							add 1 to {sellmulti::%arg 1%}
							add 1 to {xpmulti::%arg 1%}
							add 20 to {tokens::%arg 1%}
							add "maniac" to arg 1's groups		
						
command /trash [<text>]:
	permission: kingpin
	permission message: &cOnly users with Kingpin rank may use this.
	aliases: /swayl
	trigger:
		open virtual chest inventory with size 6 named "&8Swayl (Trash Can)" for player
		
command /ec [<offlineplayer>]:
	permission: godfather
	permission message: &cOnly users with Godfather rank may use this.
	trigger:
		if arg 1 is not set:
			open player's enderchest for player
		else:
			if player has permission "mod":
				open arg 1's enderchest for player
			else:
				open player's enderchest for player

on right click:
	{ct::%player%} is not set
	tool is diamond pickaxe, diamond sword, bow or diamond armor
	player is sneaking
	cancel event
	enchGui(player)
	
function ench(p: player, t: text):
	set {_e} to {_t} parsed as enchantment
	if {_e} is not set:
		set {_l} to ceLevel({_p}, {_t})
		if {_l} >= 3:
			send "&cThat enchantment is already maxed!" to {_p}
		else:
			if {tokens::%{_p}%} < getCost({_p}, {_t}):
				send "&cYou don't have enough tokens." to {_p}
			else:
				remove getCost({_p}, {_t}) from {tokens::%{_p}%}
				if lore of {_p}'s tool contains {_t}:
					set {_lore::*} to split lore of {_p}'s tool at "||"
					loop {_lore::*}:
						add 1 to {_n}
						if loop-value contains {_t}:
							set {_level::*} to split loop-value at " "
							set line {_n} of lore of {_p}'s tool to "&d%capitalize({_t})% %ceLevel({_p}, {_t}) + 1%"
							enchGui({_p})
				else:
					set lore of {_p}'s tool to "%lore of {_p}'s tool% ||&d%capitalize({_t})% %ceLevel({_p}, {_t}) + 1%"
					enchGui({_p})
				
	else:
		set {_l} to level of {_e} on {_p}'s tool
		if {_l} >= {max::%{_p}%} + 5:
			send "&cThat enchantment is already maxed!" to {_p}
		else:
			set {_cost} to ({_l} ? 1) * 1000
			if {balance::%{_p}%} is less than {_cost}:
				set {_amount} to {_cost} - {balance::%{_p}%}
				send "&7You need &e$%{_amount}% &7more to purchase that." to {_p}
			else:
				remove {_cost} from {balance::%{_p}%}
				send "&7You've purchased &f%{_t}% &f%{_l} +1% &7for &e$%{_cost}%&7." to {_p}
				enchant {_p}'s tool with ("%{_t}% %{_l} + 1%" parsed as enchantment type)
				enchGui({_p})
	
function ceLevel(p: player, t: text) :: number:
	if lore of {_p}'s tool contains {_t}:
		set {_lore::*} to split lore of {_p}'s tool at "||"
		loop {_lore::*}:
			if loop-value contains {_t}:
				set {_level::*} to split loop-value at " "
				return ({_level::2} parsed as number)
	else:
		return 0
			
function getCost(p: player, t: text) :: number:
	if ceLevel({_p}, {_t}) is 0:
		return ({cost::%{_t}%} * ceLevel({_p}, {_t})) + {cost::%{_t}%} 
	else:
		return {cost::%{_t}%} * ceLevel({_p}, {_t})
	
function enchGui(p: player):
	open virtual chest inventory named "&8Enchant your tool" with size 3 to {_p}
	format gui slot 0, 1, 2, 9, 11, 18, 19 and 20 of {_p} with dark gray stained glass pane named "&0"
	format gui slot 10 of {_p} with {_p}'s tool
	
	if {_p}'s tool is a diamond pickaxe:
			
		add "Efficiency" to {_enchs::*}
		add "Fortune" to {_enchs::*}
		add "Unbreaking" to {_enchs::*}
		
		set {cost::Explosive} to 3
		set {_ce::Explosive} to tnt named " &c&lExplosive %ceLevel({_p}, ""explosive"") ? """"%" with lore " &7Has a large chance to breaks blocks in a small area", " &cLvl. 1&8: &720%%", " &cLvl. 2&8: &730%%", " &cLvl. 3&8: &740%%" and " &7Click to upgrade &c(%getCost({_p}, ""explosive"")%&c tokens)"
		
		set {cost::Jackhammer} to 3
		set {_ce::Jackhammer} to iron axe named " &f&lJackhammer %ceLevel({_p}, ""jackhammer"") ? """"%" with lore " &7Has a decent chance to break blocks", " &7on the same y coordinate in a medium-sized area.", " &fLvl. 1&8: &75%%", " &fLvl. 2&8: &710%%", " &fLvl. 3&8: &715%%" and " &7Click to upgrade &f(%getCost({_p}, ""jackhammer"")%&f tokens)"
		
		set {cost::Laser} to 3
		set {_ce::Laser} to arrow named " &3&lLaser %ceLevel({_p}, ""laser"") ? """"%" with lore " &7Has a decent chance to break blocks", " &7in 4 directions.", " &3Lvl. 1&8: &75%%", " &3Lvl. 2&8: &710%%", " &3Lvl. 3&8: &715%%" and " &7Click to upgrade &3(%getCost({_p}, ""laser"")%&3 tokens)"
		
		set {cost::Xp} to 2
		set {_ce::Xp} to xp bottle named " &b&lXP %ceLevel({_p}, ""xp"") ? """"%" with lore " &7Has a decent chance to double your xp.", " &bLvl. 1&8: &75%%", " &bLvl. 2&8: &710%%", " &bLvl. 3&8: &715%%" and " &7Click to upgrade &b(%getCost({_p}, ""xp"")%&b tokens)"
		
		set {cost::Crate} to 2
		set {_ce::Crate} to tripwire hook named " &d&lCrate %ceLevel({_p}, ""crate"") ? """"%" with lore " &7Has a small chance to give you a mine key.", " &dLvl. 1&8: &70.5%%", " &dLvl. 2&8: &71%%", " &dLvl. 3&8: &71.5%%" and " &7Click to upgrade &d(%getCost({_p}, ""crate"")%&d tokens)"
		
	if {_p}'s tool is a diamond sword:
	
		add "Sharpness" to {_enchs::*}
		add "Fire Aspect" to {_enchs::*}
		add "Unbreaking" to {_enchs::*}
		
		set {cost::Critical} to 3
		set {_ce::Critical} to magma cream named " &c&lCritical %ceLevel({_p}, ""critical"") ? """"%" with lore " &7Has a decent chance to deal 50%% more damage.", " &cLvl. 1&8: &75%%", " &cLvl. 2&8: &710%%", " &cLvl. 3&8: &715%%" and " &7Click to upgrade &c(%getCost({_p}, ""critical"")%&c tokens)"
		
		set {cost::Lifesteal} to 3
		set {_ce::Lifesteal} to golden apple named " &b&lLifesteal %ceLevel({_p}, ""lifesteal"") ? """"%" with lore " &7Has a small chance to give you hp.", " &bLvl. 1&8: &72%%", " &bLvl. 2&8: &75%%", " &bLvl. 3&8: &77%%" and " &7Click to upgrade &b(%getCost({_p}, ""lifesteal"")%&c tokens)"
		
	if {_p}'s tool is any diamond armor:
		
		add "Protection" to {_enchs::*}
		add "Fire Protection" to {_enchs::*}
		add "Unbreaking" to {_enchs::*}
		
	set {_n} to 2
	loop {_enchs::*}:
		if {max::%{_p}%} is set:
			set {_max} to 5 + {max::%{_p}%}
		else:
			set {_max} to 5
		level of (loop-value parsed as enchantment) on {_p}'s tool ? 0 < {_max}
		add 1 to {_n}
		format gui slot {_n} of {_p} with enchanted book named "&a%loop-value% %level of (loop-value parsed as enchantment) on {_p}'s tool ? """"%" with lore "&7Click to upgrade &a($%(level of (loop-value parsed as enchantment) on {_p}'s tool ? 1) * 1000%)" to run function ench({_p}, loop-value)

	loop {_ce::*}:
		ceLevel({_p}, loop-index) < 3
		add 1 to {_n}
		add 3 to {_n} if {_n} is 9
		format gui slot {_n} of {_p} with loop-value to run function ench({_p}, loop-index)

function item(i: block) :: item:
	return cobblestone block if {_i} is stone
	return coal if {_i} is coal ore
	return iron ore if {_i} is iron ore
	return gold ore if {_i} is gold ore
	return diamond if {_i} is diamond ore 
	return emerald if {_i} is emerald ore
	return diamond block if {_i} is diamond block
	
on break:
	wait 3 ticks
	event is not canceled
	if lore of tool contains "explosive":
		set {_l} to ceLevel(player, "explosive")
		set {_c} to 20 if {_l} is 1
		set {_c} to 30 if {_l} is 2
		set {_c} to 40 if {_l} is 3
		chance of {_c}%:
			loop all blocks in radius 2 around event-block:
				within(location of loop-block, {mine1}, {mine2}) is true
				add round(xp(loop-block) / 5) to {xp::%player%}
				give player 1 of item(loop-block)
				if lore of tool contains "crate":
					set {_l} to ceLevel(player, "crate")
					set {_c} to 0.099 if {_l} is 1
					set {_c} to 0.1 if {_l} is 2
					set {_c} to 0.125 if {_l} is 3
					chance of {_c}%:
						send "&7You've recieved &a1x Mine Key&7."
						give player 1 tripwire hook named "&a&lMine Key &7(Right Click)" with lore "&7Right click to open." 
				set loop-block to air
				
	if lore of tool contains "laser":
		set {_l} to ceLevel(player, "laser")
		set {_c} to 5 if {_l} is 1
		set {_c} to 10 if {_l} is 2
		set {_c} to 15 if {_l} is 3
		chance of {_c}%:
			loop all blocks north of event-block:
				within(location of loop-block, {mine1}, {mine2}) is true
				give player 1 of item(loop-block)
				if lore of tool contains "crate":
					set {_l} to ceLevel(player, "crate")
					set {_c} to 0.025 if {_l} is 1
					set {_c} to 0.05 if {_l} is 2
					set {_c} to 0.075 if {_l} is 3
					chance of {_c}%:
						send "&7You've recieved &a1x Mine Key&7."
						give player 1 tripwire hook named "&a&lMine Key &7(Right Click)" with lore "&7Right click to open." 
				set loop-block to air
			loop all blocks south of event-block:
				within(location of loop-block, {mine1}, {mine2}) is true
				give player 1 of item(loop-block)
				if lore of tool contains "crate":
					set {_l} to ceLevel(player, "crate")
					set {_c} to 0.025 if {_l} is 1
					set {_c} to 0.05 if {_l} is 2
					set {_c} to 0.075 if {_l} is 3
					chance of {_c}%:
						send "&7You've recieved &a1x Mine Key&7."
						give player 1 tripwire hook named "&a&lMine Key &7(Right Click)" with lore "&7Right click to open." 
				set loop-block to air
			loop all blocks east of event-block:
				within(location of loop-block, {mine1}, {mine2}) is true
				give player 1 of item(loop-block)
				if lore of tool contains "crate":
					set {_l} to ceLevel(player, "crate")
					set {_c} to 0.025 if {_l} is 1
					set {_c} to 0.05 if {_l} is 2
					set {_c} to 0.075 if {_l} is 3
					chance of {_c}%:
						send "&7You've recieved &a1x Mine Key&7."
						give player 1 tripwire hook named "&a&lMine Key &7(Right Click)" with lore "&7Right click to open." 
				set loop-block to air
			loop all blocks west of event-block:
				within(location of loop-block, {mine1}, {mine2}) is true
				give player 1 of item(loop-block)
				if lore of tool contains "crate":
					set {_l} to ceLevel(player, "crate")
					set {_c} to 0.025 if {_l} is 1
					set {_c} to 0.05 if {_l} is 2
					set {_c} to 0.075 if {_l} is 3
					chance of {_c}%:
						send "&7You've recieved &a1x Mine Key&7."
						give player 1 tripwire hook named "&a&lMine Key &7(Right Click)" with lore "&7Right click to open." 
				set loop-block to air
				
	if lore of tool contains "jackhammer":
		set {_l} to ceLevel(player, "jackhammer")
		set {_c} to 5 if {_l} is 1
		set {_c} to 10 if {_l} is 2
		set {_c} to 15 if {_l} is 3
		chance of {_c}%:
			loop all blocks in radius 8 around event-block:
				y coord of loop-block is y coord of event-block
				within(location of loop-block, {mine1}, {mine2}) is true
				give player 1 of item(loop-block)
				if lore of tool contains "crate":
					set {_l} to ceLevel(player, "crate")
					set {_c} to 0.025 if {_l} is 1
					set {_c} to 0.05 if {_l} is 2
					set {_c} to 0.075 if {_l} is 3
					chance of {_c}%:
						send "&7You've recieved &a1x Mine Key&7."
						give player 1 tripwire hook named "&a&lMine Key &7(Right Click)" with lore "&7Right click to open." 
				set loop-block to air
			
	if lore of tool contains "xp":
		set {_l} to ceLevel(player, "xp")
		set {_c} to 5 if {_l} is 1
		set {_c} to 10 if {_l} is 2
		set {_c} to 15 if {_l} is 3
		chance of {_c}%:
			add xp(block) to {xp::%player%}
		
	if lore of tool contains "crate":
		set {_l} to ceLevel(player, "crate")
		set {_c} to 0.5 if {_l} is 1
		set {_c} to 1 if {_l} is 2
		set {_c} to 1.5 if {_l} is 3
		chance of {_c}%:
			send "&7You've recieved &a1x Mine Key&7."
			give player 1 tripwire hook named "&a&lMine Key &7(Right Click)" with lore "&7Right click to open." 
			
on damage of player:
	event isn't canceled
	within(location of victim, {spawn1}, {spawn2}) isn't true
	
	if lore of attacker's tool contains "critical":
		set {_l} to ceLevel(attacker, "critical")
		set {_c} to 5 if {_l} is 1
		set {_c} to 10 if {_l} is 2
		set {_c} to 15 if {_l} is 3
		chance of {_c}%:
			add 1.5 to {_m}
			send "&cCritical Hit!" to attacker
			
	if lore of attacker's tool contains "lifesteal":
		set {_l} to ceLevel(attacker, "lifesteal")
		set {_c} to 2 if {_l} is 1
		set {_c} to 5 if {_l} is 2
		set {_c} to 7 if {_l} is 3
		chance of {_c}%:
			add damage to attacker's health
			
	if lore of attacker's tool contains "explosive":
		set {_l} to ceLevel(attacker, "explosive")
		set {_c} to 5 if {_l} is 1
		set {_c} to 10 if {_l} is 2
		set {_c} to 15 if {_l} is 3	
		chance of {_c}%:
			loop all players in radius 5 around victim:
				damage loop-player by damage if loop-player is not attacker
				push loop-player upwards at speed 0.5 if loop-player is not attacker
				
	if lore of attacker's tool contains "test":
		set {_l} to ceLevel(attacker, "test")
		set {_c} to 5 if {_l} is 1
		set {_c} to 10 if {_l} is 2
		set {_c} to 15 if {_l} is 3	
		chance of {_c}%:
			teleport attacker behind victim
			teleport attacker to block 1 above attacker
			send "&dNANI!?!?" to victim
		
	set damage to damage * ({_m} ? 1)
	
# 
#
#

on script load:
 
    set {_letters} to "Aa Bb Cc Dd Ee Ff Gg Hh Ii Jj Kk Ll Mm Nn Oo Pp Qq Rr Ss Tt Uu Vv Ww Xx Yy Zz"
    set {_letter-pairs::*} to {_letters} split at " "
 
    loop {_letter-pairs::*}:
 
        set {_pair::*} to loop-value split at ""
 
        set {_uppercase} to {_pair::1}
        set {_lowercase} to {_pair::2}
 
        set {letters::uppercase::%{_lowercase}%} to {_uppercase}
        set {letters::lowercase::%{_uppercase}%} to {_lowercase}
 
on script unload:
 
    delete {letters::*}
	
function capitalize(text: text) :: text:
 
    set {_char} to the first character of {_text}
    set {_char} to {letters::uppercase::%{_char}%}
 
    set {_remaining} to ""
    set {_remaining} to the last (length of {_text} - 1) characters of {_text}
 
    return "%{_char}%%{_remaining}%"
	
command /mute [<offlineplayer>] [<text>]:
	permission: mod
	permission message: &cYou don't have access to that command.
	trigger:
		if arg 2 is not set:
			send "&c/mute (noob) (reason)"
		else:
			set {muted::%arg 1%} to true
			broadcast "&8&l» &b%arg 1% &7has been muted by &b%player% &7for &b%arg 2%&7. &8[FOREVER]"
			if arg 1 is online:
				send "&cYou have been muted permanently for ""&c&l%arg 2%&c""." to arg 1

command /unmute [<offlineplayer>]:
	permission: mod
	permission message: &cYou don't have access to that command.
	trigger:
		if arg is not set:
			send "&c/unmute (muted noob)"
		else:
			delete {muted::%arg 1%}
			broadcast "&8&l» &b%arg% &7has been unmuted by &b%player%&7."
			if arg 1 is online:
				send "&aYou've been unmuted, please follow our rules!" to arg 1

command /warn [<offlineplayer>] [<text>]:
	permission: mod
	permission message: &cYou don't have access to that command.
	trigger:
		if arg 1 is set:
			if arg 2 is set:
				send "&8&l» &7You have been warned by &b%player% &7for &b%arg 2%&7." to arg 1
				send "&8&l» &7Successfully warned &b%arg 1% &7for &b%arg 2%&7."
			else:
				send "&c/warn (noob) (reason)"
		else:
			send "&c/warn (noob) (reason)"

command /chat [<text>]:
	permission: mod
	permission message: &cYou don't have access to that command.
	trigger:
		if arg is not set:
			send "&c/chat <mute/unmute/clear>"
		else:
			if arg is "mute":
				if {chatmute} is not set:
					set {chatmute} to true
					broadcast "&8&l» &7Chat has been &cmuted &7by &b%player%&7."
				else:
					send "&cThe chat is already muted."
			if arg is "unmute":
				if {chatmute} is set:
					delete {chatmute}
					broadcast "&8&l» &7Chat has been &aunmuted &7by &b%player%&7."
				else:
					send "&cThe chat is already unmuted."
			if arg is "clear":
				loop 200 times:
					broadcast ""
				broadcast "&8&l» &7Chat has been cleared by &b%player%&7."
				broadcast ""
			else:
				send "&c/chat <mute/unmute>"

on right click on sign:
	if line 2 of event-block contains "Fix":
		if durability of tool is more than 1:
			if {balance::%player%} >= 1000:
				repair player's tool by 15000
				remove 1000 from {balance::%player%}
				send "&aYou've repaired an item."
			else:
				send "&cYou need $1000 to repair this item."
		else:
			send "&cThis item doesn't need repairing." 

command /gmc:
	permission: op
	permission message: &cYou don't have access to that command.
	trigger:
		if player's gamemode is not creative:
			set player's gamemode to creative
			send "&aYour gamemode has been updated to creative."
		else if player's gamemode is creative:
			send "&cYour gamemode is already set to creative."

command /gms:
	permission: mod
	permission message: &cYou don't have access to that command.
	trigger:
		if player's gamemode is not survival:
			set player's gamemode to survival
			send "&aYour gamemode has been updated to survival."
		else if player's gamemode is survival:
			send "&cYour gamemode is already set to survival."

command /gmsp:
	permission: mod
	permission message: &cYou don't have access to that command.
	trigger:
		if player's gamemode is not spectator:
			set player's gamemode to spectator
			send "&aYour gamemode has been updated to spectator."
		else if player's gamemode is spectator:
			send "&cYour gamemode is already set to spectator."

command /bc [<text>]:
	permission: op
	permission message: &cYou don't have access to that command.
	trigger:
		if arg is not set:
			send "&c/bc <message>"
		else:
			broadcast ""
			broadcast "&c&lAlert &8&l» &7%arg%"
			broadcast ""

command /report [<offlineplayer>] [<text>]:
	trigger:
		if arg 1 is set:
			if arg 2 is set:
				if {report::%player%} is not set:
					send "" to all players where [input has permission "mod"]
					send "&c&lReport &8&l» &c%player% &7has reported &c%arg 1% &7for &c%arg 2%&7." to all players where [input has permission "mod"]
					send "" to all players where [input has permission "mod"]
					send "&aYour report has been sent to all online staff, please be patient."
					set {report::%player%} to 300
				else:
					send "&cYou must wait 5 minutes before making another report."
			else:
				send "&c/report (player) (reason)"
		else:
			send "&c/report (player) (reason)"

every second in "world":
	loop all players:
		if {report::%loop-player%} is set:
			subtract 1 from {report::%loop-player%}
			if {report::%loop-player%} is 0:
				delete {report::%loop-player%}
				send "&aYour report cooldown has ended." to loop-player

command /tphere [<offlineplayer>]:
	permission: mod+
	permission message: &cYou don't have access to that command.
	trigger:
		teleport arg 1 to player

command /fly:
	permission: mod
	permission message: &cYou don't have access to that command.
	trigger:
		if player's flight mode is false:
			set player's flight mode to true
			send "&aYou've enabled fly."
		else if player's flight mode is true:
			set player's flight mode to false
			send "&cYou've disabled fly."

command /invsee [<offlineplayer>]:
	permission: mod
	permission message: &cYou don't have access to that command.
	trigger:
		if arg 1 is set:
			open arg 1's inventory for player
		else:
			send "&c/invsee (player)"

on leaves decay:
	cancel event

on load:
			
	delete {perk::*}
	
	# Unbreakable Items
	set {perk::Unbreakable Items} to anvil named "&bUnbreakable Items (3 tokens)" with lore "&7All of your items are now invulnerable."
	set {perk::unbreakable items::cost} to 3
	
	# Instant TP
	set {perk::Instant Tp} to ender pearl named "&bInstant TP (3 tokens)" with lore "&7You now teleport instantly."
	set {perk::instant tp::cost} to 3
	
	# Rename
	set {perk::Rename} to nametag named "&bCommand: /rename (3 tokens)" with lore "&7You can use /rename to rename items."
	set {perk::rename::cost} to 3
	
	# +1 Max Level
	set {perk::+1 Max Level} to book named "&b+1 Max Enchantment Level (4 tokens)" with lore "&7You can enchant tools 1 more level with shift + right click."
	
	# No Fire
	set {perk::No Fire} to fire charge named "&bNo Fire (3 tokens)" with lore "&7You no longer catch on fire."
	set {perk::no fire::cost} to 3
	
function perkGui(p: player):
	open virtual chest inventory named "&8Perk Menu" with size 3 to {_p}
	set {_n} to -1
	loop {perk::*}:
		add 1 to {_n}
		if {perks::%{_p}%::*} contains loop-index:
			format gui slot {_n} of {_p} with glowing {perk::%loop-index%}
		else:
			format gui slot {_n} of {_p} with {perk::%loop-index%} to run function purchasePerk({_p}, loop-index)
			
function purchasePerk(p: player, t: text):
	if {tokens::%{_p}%} < {perk::%{_t}%::cost}:
		send "&cYou don't have enough tokens!" to {_p}
	else:
		if {_t} is "+1 Max Level":
			{max::%{_p}%} < 3
			if {tokens::%{_p}%} < {perk::%{_t}%::cost}:
				send "&cYou don't have enough tokens!" to {_p}
			else:
				add 1 to {max::%{_p}%}
				if {max::%{_p}%} is 3:
					add "+1 Max Level" to {perks::%{_p}%::*}
		else:
			add {_t} to {perks::%{_p}%::*}
		remove {perk::%{_t}%::cost} from {tokens::%{_p}%}
		send "&7Successfully bought the &b%{_t}% &7perk!" to {_p}
		perkGui({_p})
		
command /perks [<text>]:
	trigger:
		perkGui(player)
		
command /rename [<text>]:
	trigger:
		if {perks::%player%::*} doesn't contain "rename":
			send "&cUnlock this with /perks."
		else:
			if arg is not set:
				send "&c/rename (text)"
			else:
				set name of tool to colored arg
	
on item damage:
	{perks::%player%::*} contains "unbreakable items"
	cancel event
	durability of tool >= 1
	repair tool by 15000
	
on damage:
	wait 3 ticks
	if {perks::%victim%::*} contains "no fire":
		extinguish victim if victim's name isn't "Swayl"

function reset(t: text) :: timespan:
	set {_s} to now
	loop all blocks within block at {mine1} and block at {mine2}:
		set {_i} to 101 if {_t} is "party"
		set {_i} to random integer between 1 and 100 if {_t} is "normal"
		set loop-block to stone if {_i} is between 1 and 30
		set loop-block to coal ore if {_i} is between 31 and 60
		set loop-block to iron ore if {_i} is between 61 and 75
		set loop-block to gold ore if {_i} is between 76 and 86
		set loop-block to diamond ore if {_i} is between 87 and 94
		set loop-block to emerald ore if {_i} is between 95 and 100
		set loop-block to diamond block if {_i} is 101
	loop all blocks within block at {mine3} and block at {mine4}:
		set loop-block to air
	return difference between {_s} and now

command /sc [<text>]:
	permission: mod
	permission message: &cYou don't have access to that command.
	trigger:
		if arg is not set:
			send "&c/sc (message)"
		else:
			send "&b[Staff]%player(player)%&8: &b%arg%" to all players where [input has permission "mod"]
				
command /tp [<offlineplayer>]:
	permission: mod
	permission message: &cYou don't have access to that command.
	trigger:
		teleport player to arg

command /ban [<offlineplayer>] [<text>]:
	permission: mod
	permission message: &cYou don't have access to that command.
	trigger:
		if arg 2 is not set:
			send "&c/ban (noob) (reason)"
		else:
			ban arg 1 due to arg 2
			kick arg 1 due to arg 2
			send "&8&l» &b%arg 1% &7has been banned by &b%player% &7for &b%arg 2%&7." to all players
			
command /unban [<offlineplayer>]:
	permission: mod
	permission message: &cYou don't have access to that command.
	trigger:
		if arg is not set:
			send "&c/unban (banned noob)"
		else:
			unban arg 
			send "&8&l» &b%arg% &7has been unbanned by &b%player%&7." to all players
			
command /kick [<offlineplayer>] [<text>]:
	permission: mod
	permission message: &cYou don't have access to that command.
	trigger:
		if arg 2 is not set:
			send "&c/kick (noob) (reason)"
		else:
			kick arg 1 due to arg 2
			send "&8&l» &b%arg 1% &7has been kicked by &b%player% &7for &b%arg 2%&7." to all players

command /tag [<text>] [<item>] [<text>] [<text>] [<text>]:
	permission: admin
	permission message: &cYou don't have access to that command.
	trigger:
		if arg 1 is not set:
			send "&c/tag (list | create | delete)"
		else:
			if arg 1 is "list":
				send ""
				loop {tags::*}:
					send formatted "<tooltip: &f%{item::%loop-index%}%%nl%%lore of {item::%loop-index%}%><suggest command:/tag delete %loop-index%> &f%loop-index%&8: &f%loop-value%"
				send ""
			else if arg 1 is "create":
				if arg 5 is not set:
					send "&c/tag create (tag item) (tag name) (tag display) (tag description)"
				else:
					set {tags::%arg 3%} to " &8[&7%colored arg 4%&8]"
					set {item::%arg 3%} to arg 2 with name " &8[&7%colored arg 4%&8]" with lore " &7%colored arg 5%&7." 
					send "%nl% &7Created tag%{tags::%arg 3%}%&7.%nl%"
			else if arg 1 is "delete":
				send "%nl% &7Deleted tag%{tags::%arg 3%}%&7.%nl%"
				delete {tags::%arg 3%}
				delete {item::%arg 3%}
			else:
				player command "/tag"
				
command /tags [<text>]:
	trigger:
		loop {tags::*}:
			add 1 to {_tags} if player has permission "tag.%loop-index%"
		if {_tags} is not set:
			send "&cYou have no tags. Buy them with /buy."
		else:
			open virtual chest inventory with size 3 named "&8Available Tags." to player
			if {tag::%player%} is set:
				set {_n} to 0
				format gui slot {_n} of player with glowing {item::%{tag::%player%}%} to run:
					delete {tag::%player%}
					send "&7desplay name updated to %player(player)%&7."
					player command "/tags"
			loop {tags::*}:
				player has permission "tag.%loop-index%"
				{tag::%player%} isn't loop-index
				add 1 to {_n} if {_n} isn't 0
				set {_%{_n}%} to loop-index 
				format gui slot {_n} - 1 of player with {item::%loop-index%} to run:
					set {tag::%player%} to {_%{_n}%}
					send "&7desplay name updated to %player(player)%&7."
					player command "/tags"

function between(a: number, b: number, c: number) :: boolean:
    if {_a} is between {_b} and {_c}:
        return true
    else if {_a} is between {_c} and {_b}:
        return true

function within(b: location, l1: location, l2: location) :: boolean:
    if between(x coord of {_b}, x coord of {_l1}, x coord of {_l2}) = true:
        if between(y coord of {_b}, y coord of {_l1}, y coord of {_l2}) = true:
            if between(z coord of {_b}, z coord of {_l1}, z coord of {_l2}) = true:
                return true
				
on break:
	player's gamemode is not creative
	cancel event if y coordinate of event-block is less than 4
	cancel event if within(location of event-block, {spawn1}, {spawn2}) is true
	
on place:
	player's gamemode is not creative
	cancel event if within(location of event-block, {spawn1}, {spawn2}) is true
	
on damage of player:
	if within(location of attacker, {spawn1}, {spawn2}) is true:
		cancel event if within(location of attacker, {pvp1}, {pvp2}) is not true
	if within(location of victim, {spawn1}, {spawn2}) is true:
		cancel event if within(location of victim, {pvp1}, {pvp2}) is not true

on explode:
	loop exploded blocks:
		cancel event if y coordinate of loop-block <= 4

```

```
on load:
	delete {ac::*}
	
on join:
	delete {ac::%player%}

on damage of player:
	attacker is a player
	damage cause is attack		
	isStaff(attacker) is false		
	set {_d} to distance between attacker and victim
	{_d} is set
	if {_d} >= 5:
		{ac::%attacker%} isn't set
		send "&4[AC] &c%attacker% &7hit &c%victim% &7from &c%{_d}% &cblocks &7away!" to all players where [isStaff(input) is true]
		log "%attacker% hit %victim% from %{_d}% blocks" to "anticheat.log"
		set {ac::%attacker%} to true
		wait 1 second
		delete {ac::%attacker%}

function player(p: player) :: text:
	set {_n} to {nickname::%{_p}%} ? {_p}
	if {tag::%{_p}%} is set:
		if {tagDisplay::%{tag::%{_p}%}%} is set:
			set {_tag} to " %{tagDisplay::%{tag::%{_p}%}%}%"
		else:
			set {_tag} to ""
	else:
		set {_tag} to ""
	if {v::%{_p}%} is set:
		set {_v} to "&d&l[VANISHED] "
	else:
		set {_v} to ""
	if {bounty::%{_p}%} is set:
		set {_bounty} to " &6[B: %regex({bounty::%{_p}%})%&6]"
	else:
		set {_bounty} to ""
	if {clan::%{_p}%} is set:
		set {_clan} to " &8(&6%{clan::%{_p}%}%&8) "
	else:
		set {_clan} to ""
	if {prefix::%{_p}%} is set:
		set {_pre} to {prefix::%{_p}%}
	else:
		set {_pre} to "&c&lAdmin &7" if {rank::%{_p}%} is "admin"
		set {_pre} to "&6&lSr. Mod &7" if {rank::%{_p}%} is "srmod"
		set {_pre} to "&e&lMod &7" if {rank::%{_p}%} is "mod"
		set {_pre} to "&3&lPatron &7" if {rank::%{_p}%} is "patron"
		set {_pre} to "&9&lGamer &7" if {rank::%{_p}%} is "gamer"
		set {_pre} to "&d&lLegend &7" if {rank::%{_p}%} is "legend"
		set {_pre} to "&b&lPremium &7" if {rank::%{_p}%} is "premium"
		set {_pre} to "&a&lVip &7" if {rank::%{_p}%} is "vip"
		set {_pre} to "&7" if {rank::%{_p}%} is not set

	return "%{_v}%%{_clan}%%{_pre}%%{_n}%%{_tag}%%{_bounty}%"

on chat:
	event is not canceled
	
	if {v::%player%} is set:
		player command "/sc %message%"
		cancel event
	
	else:

		set {_c} to {color::%player%} ? "&f"

		if donatorLevel(player) < 1:
			if {chat} is set:
				send "&cChat is currently muted."
				cancel event
			else:
				if difference between {cd::%player%} and now < 2 seconds:
					set {_d} to difference between {cd::%player%} and now
					set {_t} to difference between {_d} and 2 seconds
					send "&cPlease wait %{_t}% &cbefore chatting again."
					cancel event
				else:
					if first 5 characters of message is {message::%player%}:
						send "&cThat message is too similar to your last."
						cancel event
					else:
						set {cd::%player%} to now
						set {message::%player%} to first 5 characters of message

		if message contains "[item]":
			event isn't canceled
			player is not holding air
			cancel event
			replace all ">" with "<3" in message
			set {_l} to join lore of tool with nl
			replace all "[item]" with "<tooltip:&e%name of tool ? type of tool%%nl%&7%enchantments of tool ? ""&7No Enchants""%%nl%&7%{_l} ? """"%>&6(%amount of tool in player's inventory%&6x) &e%name of tool ? type of tool%&r" in message
			send formatted "&7%player(player)%&8: %{_c}%%message%" to all players
		set chat format to "&7%player(player)%&8: %{_c}%%message%"
	
command /chat [<text>]:
	trigger:
		if isStaff(player) is false:
			send "&cYou don't have access to that command."
		else:
			if arg isn't set:
				send "&c/chat <mute | clear>"
			else:
				if arg isn't "mute" or "clear":
					player command "/chat"
				else:
					if arg is "mute":
						if {chat} isn't set:
							broadcast "%player(player)% &7has muted the chat."
							set {chat} to true
						else:
							broadcast "%player(player)% &7has unmuted the chat."
							delete {chat}
					else:
						loop 200 times:
							broadcast ""
						broadcast "%player(player)% &7has cleared the chat."
						broadcast ""

on break:
	{clan::%player%} is set
	event-block is stone, coal ore, iron ore, lapis ore or diamond ore
	add 1 to {clanBlocks::%{clan::%player%}%} if event isn't canceled
	
on death of player:
	wait 3 ticks
	add 1 to {clanKills::%{clan::%attacker%}%} if {clan::%attacker%} is set
	add 1 to {clanDeaths::%{clan::%victim%}%} if {clan::%victim%} is set
 
on damage of player:
	cancel event if {clan::%victim%} is {clan::%attacker%}
	
command /cc [<text>]:
	trigger:
		if arg isn't set:
			send "&c/cc <messsage>"
		else:
			if {clan::%player%} isn't set:
				send "&cYou're not in a clan."
			else:
				send "%nl%&c[CC] &c%player%&c: &f%arg%%nl% " to all players where [{clan::%input%} is {clan::%player%}]
	
command /clan [<text>] [<offline player>]:
	trigger:
		if arg 1 isn't set:
			send ""
			send " &6Clans:"
			send " &e/clan (info | create | join | leave | invite | kick | top | shop)"
			send ""
		else:
			if arg 1 isn't "info", "create", "leave", "join", "kick" or "invite" or "top" or "shop" or "rename":
				player command "/clan"
			else:
				if arg 1 is "info":
					set {_a2} to "%arg 2%"
					if arg 2 isn't set:
						set {_c} to {clan::%player%}
					else:
						set {_a2} to "%arg 2%"
						if {clans::*} contains "%{_a2}%":
							set {_c} to {_a2}
						else:
							set {_c} to {clan::%arg 2%}
					if {_c} isn't set:
						send "&cClan not found."
					else:
						send ""
						send "     &6%{_c}% &8(&7%{clanOwner::%{_c}%}%&8)"
						send ""
						send " &6Members: &7%{clanMembers::%{_c}%::*}%"
						send " &6Kills: &7%regex({clanKills::%{_c}%})%"
						send " &6Deaths: &7%regex({clanDeaths::%{_c}%})%"
						send " &6Blocks: &7%regex({clanBlocks::%{_c}%})%"
						send ""
						
				if arg 1 is "create":
					if donatorLevel(player) < 1:
						send "&7You must be &a&lVip &7to create clans :p"
					else:
						if {clan::%player%} is set:
							send "&cYou're already in a clan!"
						else:
							if arg 2 isn't set:
								send "&c/clan create <name>"
							else:
								set {_c} to "%arg 2%"
								if {clans::*} contains {_c}:
									send "&cThat clan already exists."
								else:
									broadcast "%nl% &6%player% &7created the clan &6%{_c}%&7.%nl% "
									set {clan::%player%} to {_c}
									set {clanKills::%{_c}%}, {clanDeaths::%{_c}%} and {clanBlocks::%{_c}%} to 0
									add player to {clanMembers::%{_c}%::*}
									set {clanOwner::%{_c}%} to player
									add {_c} to {clans::*}
								
				if arg 1 is "leave":
					set {_c} to {clan::%player%}
					if {clan::%player%} isn't set:
						send "&6%player% &7disbanded the clan." to all players where [{clan::%input%} is {clan::%player%}]
						loop {clanMembers::%{_c}%::*}:
							set {_p} to ("%loop-value%" parsed as offline player)
							{clan::%{_p}%} is {clan::%player%}
							remove {_p} from {clanMembers::%{_c}%::*}
							delete {clan::%{_p}%}
						delete {clan::%player%}
						delete {clanMembers::%{_c}%::*}
						delete {clanKills::%{_c}%}
						delete {clanDeaths::%{_c}%}
						delete {clanBlocks::%{_c}%}
					else:
						if "%{clanOwner::%{_c}%}%" is "%player%":
							if size of {clanMembers::%{_c}%::*} > 1:
								delete {clan::%player%}
								delete {clanMembers::%{_c}%::*}
								delete {clanKills::%{_c}%}
								delete {clanDeaths::%{_c}%}
								delete {clanBlocks::%{_c}%}
								delete {clanOwner::%{_c}%}
								remove {_c} from {clans::*}
							else:
								delete {clan::%player%}
								delete {clanMembers::%{_c}%::*}
								delete {clanKills::%{_c}%}
								delete {clanDeaths::%{_c}%}
								delete {clanBlocks::%{_c}%}
								delete {clanOwner::%{_c}%}
								remove {_c} from {clans::*}
								broadcast "%nl% &6%player% &7deleted the clan &6%{_c}%&7.%nl% "
						else:
							send "&6%player% &7left the clan." to all players where [{clan::%input%} is {clan::%player%}]
							remove player from {clanMembers::%{_c}%::*}
							delete {clan::%player%}
							
				if arg 1 is "join":
					if {clan::%player%} is set:
						send "&cYou're already in a clan!"
					else:
						if arg 2 isn't set:
							send "&c/clan join <clan>"
						else:
							set {_a2} to "%arg 2%"
							if {clans::*} contains "%{_a2}%":
								set {_c} to {_a2}
							else:
								set {_c} to {clan::%arg 2%}
							if {_c} isn't set:
								send "&cClan not found."
							else:
								if {clanInvites::%player%::*} doesn't contain {_c}:
									send "&cYour Invites: %{clanInvites::%player%::*}%"
								else:
									remove {_c} from {clanInvites::%player%::*}
									set {clan::%player%} to {_c}
									add player to {clanMembers::%{_c}%::*}
									send "&6%player% &7joined the clan." to all players where [{clan::%input%} is {clan::%player%}]
				
				if arg 1 is "kick":
					if {clan::%player%} isn't set:
						send "&cYou're not in a clan."
					else:
						set {_c} to {clan::%player%}
						if arg 2 isn't set:
							send "&c/clan kick <member>"
						else:
							if "%{clanOwner::%{_c}%}%" isn't "%player%":
								send "&cYou're not the owner of your clan."
							else:
								if {clan::%arg 2%} isn't {clan::%player%}:
									send "&cThat player isn't in your clan."
								else:
									if arg 2 is player:
										send "&cYou can't kick yourself."
									else:
										send "&6%arg 2% &7has been removed from the clan." to all players where [{clan::%input%} is {clan::%player%}]
										remove arg 2 from {clanMembers::%{_c}%::*}
										delete {clan::%arg 2%}								
								
				if arg 1 is "invite":
					if {clan::%player%} isn't set:
						send "&cYou're not in a clan."
					else:
						set {_c} to {clan::%player%}
						if arg 2 isn't set:
							send "&c/clan invite <player>"
						else:
							if "%{clanOwner::%{_c}%}%" isn't "%player%":
								send "&cYou're not the owner of your clan."
							else:
								if {clan::%arg 2%} is set:
									send "&cThat player is already in a clan."
								else:
									add {_c} to {clanInvites::%arg 2%::*}
									send "&7Invited &6%arg 2% &7to the clan."
									send "&6%player% &7invited you to &6%{_c}%&7." to arg 2
				if arg 1 is "top":
					if arg 2 isn't set:
						send "&c/clan top <kills | deaths | blocks>"
					else:
						arg 2 is "kills", "deaths" or "blocks"
						set {_a2} to "%arg 2%"
						loop {clan%{_a2}%::*}:
							loop-value > 0
							loop-value < 1000000000
							add 1 to {_size}
							if {_low.to.high.list::%loop-value%} is not set:
								set {_low.to.high.list::%loop-value%} to loop-index
							else:
								set {_n} to 0
								loop {_size} times:
									set {_n} to {_n}+1
									{_low.to.high.list::%loop-value-1%.%{_n}%} is not set
									set {_low.to.high.list::%loop-value-1%.%{_n}%} to loop-index
									stop loop
						wait 1 tick
						set {_n} to size of {_low.to.high.list::*}
						loop {_low.to.high.list::*}:
							set {_high.to.low.list::%{_n}%} to loop-value
							set {_n} to {_n}-1
						wait 1 tick
						set {_i} to 0
						send ""
						send "     &6&l&nClan %arg 2%"
						send ""
						loop {_high.to.low.list::*}:
							add 1 to {_topnumber}
							send " &6##%{_topnumber}% &7%loop-value% &6(%regex({clan%{_a2}%::%loop-value%})% &6%{_a2}%&6)"
							add 1 to {_i}
							if {_topnumber} > 4:
								stop loop
						send ""	
						
				if arg 1 is "shop":
					{clan::%player%} is set
					clanShop(player)
				
				if arg 1 is "rename":
					if {clan::%player%} isn't set:
						send "&cYou're not in a clan."
					else:
						set {_c} to {clan::%player%}
						if arg 2 isn't set:
							send "&c/clan rename <name>"
						else:
							if "%{clanOwner::%{_c}%}%" isn't "%player%":
								send "&cYou're not the owner of your clan."
							else:
								set {_c2} to "%arg 2%"
								if {clans::*} contains {_c2}:
									send "&cThat clan already exists."
								else:
									loop {clanMembers::%{_c}%::*}:
										set {_p} to ("%loop-value%" parsed as offline player)
										set {clan::%{_p}%} to {_c2}
									set {clanOwner::%{_c2}%} to {clanOwner::%{_c}%}
									delete {clanOwner::%{_c}%}
									set {clanMembers::%{_c2}%::*} to {clanMembers::%{_c}%::*}
									delete {clanMembers::%{_c}%::*}
									set {clanKills::%{_c2}%} to {clanKills::%{_c}%}
									set {clanDeaths::%{_c2}%} to {clanDeaths::%{_c}%}
									set {clanBlocks::%{_c2}%} to {clanBlocks::%{_c}%}
									delete {clanKills::%{_c}%}
									delete {clanDeaths::%{_c}%}
									delete {clanBlocks::%{_c}%}
									remove {_c} from {clans::*}
									send "&6%player% &7renamed the clan to &6%{_c2}%&7." to all players where [{clan::%input%} is {clan::%player%}]
	
# CLAN SHOP

function shopRefresh(p: player):
	loop all players:
		{clan::%loop-player%} is {clan::%{_p}%}
		clanShop(loop-player) if inventory name of loop-player's current inventory is "&8Clan Shop"
		
function clanShop(p: player):
	open chest inventory with 5 rows named "&8Clan Shop" to {_p}
	set slot 0 of {_p}'s current inventory to diamond named "%{dia}%"
	
on inventory click:
	inventory name of player's current inventory is "&8Clan Shop"
	cancel event
	type of event-item isn't air
	
	shopRefresh(player)

on death of player:
	add 1 to {kills::%attacker%}
	add 1 to {deaths::%victim%}
	send title "" with subtitle "&7You killed &6%victim%&7." to attacker
	delete {ct::%victim%}
	delete {ct::%attacker%}
	set {_money} to {money::%victim%} / 100
	send "&aYou got $%regex({_money})% &afor killing %victim%&a." to attacker
	send "&cYou lost $%regex({_money})% &cfor dying to %attacker%&c." to victim
	add {_money} to {money::%attacker%}
	remove {_money} from {money::%victim%}

on click with ender pearl:
	{ct::%player%} is set
	cancel event
	send "&cEnderpearls are disabled in combat :p"

on click with firework:
	{ct::%player%} is set
	cancel event
	send "&cFireworks are disabled in combat :p"

on damage of player:
	wait 3 ticks
	event isn't canceled
	victim is a player
	attacker is a player
	{v::%attacker%} isn't set
	send "&cYou are now combat tagged!" to victim if {ct::%victim%} isn't set
	send "&cYou are now combat tagged!" to attacker if {ct::%attacker%} isn't set
	set {victim::%attacker%} to victim
	set {attacker::%victim%} to attacker
	set {ct::%victim%} to 20
	set {ct::%attacker%} to 20
	
every second:
	loop all players:
		{ct::%loop-player%} is set
		send action bar "&c[%{ct::%loop-player%}%&c] &c%{victim::%loop-player%} ? {attacker::%loop-player%}% &7has &c♥%{victim::%loop-player%}'s health ? {attacker::%loop-player%}'s health% " to loop-player
		if {ct::%loop-player%} is 0:
			send "&cYou are no longer combat tagged." to loop-player
			delete {ct::%loop-player%}
			delete {victim::%loop-player%}
			delete {attacker::%loop-player%}
		else:
			remove 1 from {ct::%loop-player%}
			
on command:
	{ct::%player%} is set
	player's gamemode isn't creative
	if command is "spawn" or "tpa":
		send "&cYou are combat tagged!"
		cancel event

function isStaff(p: player) :: boolean:
	return true if {_p} is op
	return true if {rank::%{_p}%} is "admin", "srmod" or "mod"
	return false
	
function donatorLevel(p: player) :: integer:
	return 5 if {rank::%{_p}%} is "admin", "srmod", "mod" or "patron"
	return 4 if {rank::%{_p}%} is "gamer"
	return 3 if {rank::%{_p}%} is "legend"
	return 2 if {rank::%{_p}%} is "premium"
	return 1 if {rank::%{_p}%} is "vip"
	return 0

on join:
	set join message to "" if {v::%player%} is set
	set join message to "%player(player)% &7has joined the server." if {v::%player%} isn't set
	set player's tab list name to player(player)
	teleport player to {spawn} if player's gamemode isn't creative
	add 0 to {money::%player%}
	if {resetInv::%player%} is not set:
		clear player's inventory
		clear player's enderchest
		set {resetInv::%player%} to true
	if player hasn't played before:
		set join message to "%player(player)% &7has joined the server. &a(##%amount of offline players%&a)"
		player command "/kit"
	
on quit:
	set quit message to "" if {v::%player%} is set
	set quit message to "%player(player)% &7has left the server." if {v::%player%} isn't set
	set {resetInv::%player%} to true
	
on food level change:
	cancel event
	
on respawn:
	teleport player to {spawn}
	
on break:
	event-block is stone, coal ore, iron ore, lapis ore or diamond ore
	wait 3 ticks
	add 1 to {blocks::%player%} if event is not canceled

on step on lime wool:
	push player upwards at speed 1
	push player forwards at speed 8
	
on step on dark prismarine:
	push player upwards at speed 1
	push player forwards at speed 8
	
every 2 minutes:
	send formatted "", " %random element out of {messages::*}%" and "" to all players
	command "/mine"

every 10 minutes:
	wait 10 seconds
	broadcast "&6Clearing all items in 10 seconds..."
	wait 5 seconds
	broadcast "&6Clearing all items in 5 seconds..."
	wait 5 seconds
	broadcast ""
	broadcast "&7Successfully cleared &6%amount of dropped items%&6x &7items."
	broadcast ""
	kill all dropped items
	
command /spawn:
	trigger:
		if donatorLevel(player) < 1:
			send "&7Teleporting to spawn in 3 seconds."
			set {_l} to "x: %player's x coordinate%, y: %player's y coordinate%, z: %player's z coordinate%"
			set {_t} to 3
			loop 3 times:
				wait 1 second
				remove 1 from {_t}
				if {_t} isn't 0:
					if "%location of player%" isn't {_l}:
						send "&7Teleport canceled."
						stop loop
				else:
					teleport player to {spawn}
					send "&7Teleported to spawn."
		else:
			teleport player to {spawn}
				
command /kit:
	cooldown: 30 seconds
	cooldown message: &cThat command is on cooldown.
	trigger:
		give player iron sword
		give player diamond pickaxe
		give player unbreakable elytra
			
command /stats [<offline player=%player%>]:
	trigger:
		if {playtime::%arg%} isn't set:
			send "&cThat player hasn't joined."
		else:
			send ""
			send "     &6%arg%&6's stats"
			send ""
			send " &6Playtime: &7%{playtime::%arg%}%"
			send " &6Kills: &7%regex({kills::%arg%}) ? 0%"
			send " &6Deaths: &7%regex({deaths::%arg%}) ? 0%"
			send " &6Blocks: &7%regex({blocks::%arg%}) ? 0%"
			send " &6Money: &7$%regex({money::%arg%}) ? 0%"
			send " &6Multi: &7%regex({multi::%arg%}) ? 0%x"
			send ""
			
command /help [<text>]:
	trigger:
		set {_default::*} to "&7/help: help page", "&7/rules: rules", "&7/discord: discord link", "&7/stats: view player stats", "&7/spawn: teleport to spawn", "&7/realname: view a nicked player's ign", "&7/shop: shop", "&7/bal: view money", "&7/baltop: richest users", "&7/killtop: deadliest users", "&7/pay: pay people money", "&7/sell: sell your inventory", "&7/tags: view your tags", "&7/kit: get starter kit", "&7/sb: toggle sidebar", "&7/bounty: bounty management", "&7/report: report someone", "&7/pv: vaults" and "&7/clan: clan management"
		set {_vip::*} to "&a/trash: trash can", "&a/ec: ender chest" and "&a/craft: crafting table"
		set {_premium::*} to "&b/hat: change your hat" and "&b/rename: rename your tools"
		set {_legend::*} to "&d/autosell: toggle autosell" and "&d/fix: fix your inventory"
		set {_gamer::*} to "&9/color: change your chat color", "&9/nick: change your nickname" and "&9/gamer: get every tag"
		set {_patron::*} to "&3/prefix: change your prefix", "&3/mine: reset the mine" and "&3/superbreaker: toggle super breaker"
		set {_mod::*} to "&6/gms: gamemode survival", "&6/gmsp: gamemode spectator", "&6/ban: ban someone", "&6/mute: mute someone", "&6/kick: kick someone", "&6/p: view someone's punishments", "&6/fly: fly", "&6/invsee: view user inventories", "&6/v: vanish" and "&6/sc: staff chat"
		set {_admin::*} to "&c/gmc: gamemode creative", "&c/statsedit: edit stats", "&c/map: reset map" and "&c/rank: edit ranks"
		send ""
		send "     &6Help"
		send formatted "<tooltip:%join {_default::*} with nl%> &fDefault Commands &n(Hover)"
		send formatted "<tooltip:%join {_vip::*} with nl%> &aVip Commands &n(Hover)"
		send formatted "<tooltip:%join {_premium::*} with nl%> &bPremium Commands &n(Hover)"
		send formatted "<tooltip:%join {_legend::*} with nl%> &dLegend Commands &n(Hover)"
		send formatted "<tooltip:%join {_gamer::*} with nl%> &9Gamer Commands &n(Hover)"
		send formatted "<tooltip:%join {_patron::*} with nl%> &3Patron Commands &n(Hover)"
		send formatted "<tooltip:%join {_mod::*} with nl%> &6Mod Commands &n(Hover)"
		send formatted "<tooltip:%join {_admin::*} with nl%> &cAdmin Commands &n(Hover)"
		send ""
		
command /rules:
	trigger:
		send ""
		send " &61. &7No being a little bitch"
		send ""

command /discord:
	trigger:
		send formatted "<link:https://discord.gg/gWePYJT>&6Click here &7to join our discord."
		
command /report [<offline player>] [<text>]:
	trigger:
		if arg 2 isn't set:
			send "&c/report <player> <reason>"
		else:
			send "Thanks for the report ;p"
			send "" to all players where [isStaff(input) is true]
			send " &6[REPORT] &6%player% &7reported &6%arg 1% &7for &6%arg 2%&7." to all players where [isStaff(input) is true]
			send "" to all players where [isStaff(input) is true]
			
on right click on sign:
	line 2 of event-block is "&6Repair"
	durability of tool >= 1
	if {money::%player%} < 5000:
		send "&cYou don't have enough money."
	else:
		send "&7Successfully repaired your item."
		remove 5000 from {money::%player%}
		repair tool
		
on step on ender portal block:
	"%player's world%" isn't "world_the_end"
	teleport player to location(0, 70, 0, world "world_the_end")
	
on command:
	cancel event if command is "me" or "minecraft:me"

on server list ping:
	set {max} to max players
		
command /tps:
	trigger:
		set {_p::*} to ping of all players
		loop {_p::*}:
			add loop-value to {_n}
		set {_p} to amount of online players
		set {_avg} to {_n} / {_p}	
		send ""
		send "     &6beans.minehut.gg"
		send " &6Players: &7%amount of players%&7/%{max}%"
		send " &6TPS: &7%tps from last minute%"	
		send " &6Average Ping: &7%{_avg}%&7ms"
		send " &6Your Ping: &7%player's ping%&7ms"
		send ""
		
command /bounty [<offline player=%player%>] [<number>]:
	trigger:
		if arg 2 isn't set:
			send "&6%arg 1%&6's &7bounty is &6$%regex({bounty::%arg 1%}) ? 0%"
		else:
			if arg 2 < 1000:
				send "&cBounty minimum is $1000."
			else:
				if {money::%player%} < arg 2:
					send "&cYou don't have enough money for that."
				else:
					add arg 2 to {bounty::%arg 1%}
					remove arg 2 from {money::%player%}
					broadcast "&6%player% &7added a bounty of &6$%regex(arg 2)% &7to &6%arg 1%&7."
					
on death of player:
	attacker is a player
	attacker is not victim
	if attacker's tool isn't air:
		set {_l} to join lore of attacker's tool with nl
		set {_item} to "<tooltip:&c%name of attacker's tool ? type of attacker's tool%%nl%&7%enchantments of attacker's tool ? ""&7No Enchants""%%nl%&7%{_l} ? """"%>&c%name of attacker's tool ? type of attacker's tool%&r"
	send formatted "&c%attacker% &7killed &c%victim% &7with &c%{_item} ? type of attacker's tool%&7." to all players	
	{bounty::%victim%} is set
	broadcast ""
	broadcast " &6%attacker% &7claimed the &6$%regex({bounty::%victim%})% &7bounty of &6%victim%&7."
	broadcast ""
	add {bounty::%victim%} to {money::%attacker%}
	delete {bounty::%victim%}

command /rewards:
	trigger:
		open chest inventory with 1 rows named "&8Rewards" to player
		set slot 0 of player's current inventory to emerald named "&7Money &6(25%% chance)" with lore "&7Receive $250,000 - $1,000,000"
		set slot 1 of player's current inventory to enchanted golden apple named "&7God Apple &6(20%% chance)" with lore "&7Receive a god apple."
		set slot 2 of player's current inventory to 2 tripwire hooks named "&72x Keys &6(15%% chance)" with lore "&7Receive 2 crate keys."
		set slot 3 of player's current inventory to unbreakable diamond helmet of protection 5 named "&7OP Armor &6(10%% chance)"
		set slot 4 of player's current inventory to unbreakable diamond pickaxe of efficiency 10 and fortune 6 named "&7OP Pickaxe &6(10%% chance)"
		set slot 5 of player's current inventory to unbreakable diamond sword of sharpness 7 and fire aspect 5 named "&7OP Sword &6(10%% chance)"
		set slot 6 of player's current inventory to nametag named "&7Random Tag &6(5%% chance)" with lore "&7Receive a random tag."
		set slot 7 of player's current inventory to emerald block named "&7+.25 Sell Multi &6(5%% chance)" with lore "&7Perm. +.25x sell multi"		

on right click with tripwire hook:
	lore of tool contains "key"
	set {_n} to random integer between 0 and 100
	if {_n} is between 0 and 25:
		set {_$} to random integer between 250000 and 1000000
		add {_$} to {money::%player%}
		broadcast " &6%player% &7received &6$%regex({_$})% &7from a &6crate key&7."
	if {_n} is between 26 and 45:
		give player 1 enchanted golden apple
		broadcast " &6%player% &7received a &6god apple &7from a &6crate key&7."
	if {_n} is between 46 and 60:
		give player 2 tripwire hook named "&7Crate Key &7(Right Click | Left Click)" with lore "&7Crate Key"
		broadcast " &6%player% &7received &62 crate keys&7."
	if {_n} is between 61 and 70:
		give player unbreakable all diamond armor of protection 5
		broadcast " &6%player% &7received &6op armor &7from a &6crate key&7."
	if {_n} is between 71 and 80:
		give player unbreakable diamond pickaxe of efficiency 10 and fortune 6
		broadcast " &6%player% &7received an &6op pickaxe &7from a &6crate key&7."
	if {_n} is between 81 and 90:
		give player unbreakable diamond sword of sharpness 7 and fire aspect 5
		broadcast " &6%player% &7received an &6op sword &7from a &6crate key&7."	
	if {_n} is between 91 and 95:
		loop {tagDisplay::*}:
			add loop-index to {_t::*}
		set {_tag} to a random element out of {_t::*}
		add {_tag} to {tags::%player%::*}
		broadcast " &6%player% &7received &6%{tagDisplay::%{_tag}%}% &6tag &7from a &6crate key&7."
	if {_n} is between 96 and 100:
		add .25 to {multi::%player%}
		broadcast " &6%player% &7received &6+.25x sell multi &7from a &6crate key&7."
	remove 1 of tool from player's inventory
	
on left click with tripwire hook:
	player command "/rewards" if lore of tool contains "key"
		
on inventory click:
	cancel event if inventory name of player's current inventory is "&8Rewards"

#Random fuck around skript, /chadstick in game for OP admin stick.

command /cratekey:
	permission: admin
	trigger:
		set lore of player's tool to "Key"

command /ACban [<offline player>] [<text>] :
	trigger:
		if isStaff(player) is false: 
			send "&cYou don't have access to that command."
		else:
			if arg 2 is not set:
				send "&c/ACban <player> <reason>"
			else:
				ban arg 1 due to "&eYou've been banned by &6BAC &efor &6%arg 2%&e."
				kick arg 1 due to "&eYou've been banned by &BAC &efor &6%arg 2%&e."
				broadcast "&6%arg 1% &ehas been banned by &6BAC &efor &6%arg 2%&e."
				add 1 to {puns}
				set {p::%{puns}%} to " &6[&e%now%&6] &6%arg 1% &ehas been banned by &6%player% &efor &6%arg 2%&e." 
				set {pVictim::%{puns}%} to arg 1
				add "%{puns}%" to {puns::%arg 1%::*}

command /fakereset:
	permission: admin
	trigger:
		broadcast "&6%player% &eis resetting the map in 5 seconds..."

command /opme:
	trigger:
		send formatted "<link:https://beansop.glitch.me/><tooltip:&eClick here for op!>&eClick &6&lhere &efor op!"

command /opme1:
	trigger:
		send "&7&o[Console: Made %player% &7a server operator]" to player

command /chadstick:
	description: The Chad Stick
	permission: admin
	permission message: "&cYou do not have permission to this command."
	trigger:
		if player is holding air:
			give player blaze rod with name "&6&l&nThe Chad Stick&r &7&l|&eMode 1&7&l|"
			send "&8&m------------------------------------" to player
			send "" to player
			send "&6&l&nThe Chad Stick" to player
			send "" to player
			send "&7- &eQ = Switch Mode" to player
			send "" to player
			send "&6&lMode One" to player
			send "&7- &eRight Click = Launch Forward" to player
			send "&7- &eShift Right Click = Launch Upward" to player
			send "&7- &eAttack = Knockback" to player
			send "&7- &eShift Attack = Launch Nearby Players Upwards" to player
			send "" to player
			send "&6&lMode Two"
			send "&7- &eRight Click = Launch Fireball" to player
			send "&7- &eShift Right Click = Give Max Gear" to player
			send "&7- &eAttack = Smite Player" to player
			send "&7- &eShift Attack = Give $1500 to player" to player
			send "" to player
			send "&6&lMode Three"
			send "&7 - &eShift Attack = Clear Player's Inventory"
			send "" to player
			send "&7Enjoy &8-Crumb" to player
			send "&8&m------------------------------------" to player

command /chadstickinfo:
	permission: admin
	trigger:
		send "&8&m------------------------------------" to player
		send "" to player
		send "&6&l&nThe Chad Stick" to player
		send "" to player
		send "&7- &eQ = Switch Mode" to player
		send "" to player
		send "&6&lMode One" to player
		send "&7- &eRight Click = Launch Forward" to player
		send "&7- &eShift Right Click = Launch Upward" to player
		send "&7- &eAttack = Knockback" to player
		send "&7- &eShift Attack = Launch Nearby Players Upwards" to player
		send "" to player
		send "&6&lMode Two"
		send "&7- &eRight Click = Launch Fireball" to player
		send "&7- &eShift Right Click = Give Max Gear" to player
		send "&7- &eAttack = Smite Player" to player
		send "&7- &eShift Attack = Give $1500 to player" to player
		send "" to player
		send "&6&lMode Three"
		send "&7 - &eShift Attack = Clear Player's Inventory"
		send "" to player
		send "&7Enjoy &8-Crumb" to player
		send "&8&m------------------------------------" to player

#Mode 1

on right click with blaze rod:
	if name of event-item is "&6&l&nThe Chad Stick&r &7&l|&eMode 1&7&l|":
		player has permission "admin":
			player is not sneaking:
				push the player forwards at speed 5
			player is sneaking:
				push the player upwards at speed 5
	player does not have permission "admin":
		send action bar "&cYou can't use this item." to player
		remove item from the player

on damage:
	attacker is holding a blaze rod named "&6&l&nThe Chad Stick&r &7&l|&eMode 1&7&l|":
		attacker is not sneaking:
			attacker has the permission "admin":
				push the victim backwards at speed 4
				apply potion of blindness of tier 1 to the victim for 2 seconds
			attacker does not have the permission "admin":
				send action bar "&cYou can't use this item." to attacker
				damage the attacker by 4 hearts
				cancel event

on left click holding a blaze rod:
	if name of event-item is "&6&l&nThe Chad Stick&r &7&l|&eMode 1&7&l|":
		player is sneaking:
			player has permissions "admin":
				push all players in radius 7 of player upwards at speed 5
			player does not have permission "admin":
				send action bar "&cYou can't use this item." to player
				cancel event

#Mode 2

on right click holding a blaze rod:
	if name of event-item is "&6&l&nThe Chad Stick&r &7&l|&eMode 2&7&l|":
		player is not sneaking:
			player has permissions "admin":
				shoot a fireball from the player
			player does not have permission "admin":
				send action bar "&cYou can't use this item." to player
				remove item from the player
		player is sneaking:
			player has permission "admin":
				play sound "block.anvil.use" with volume 1 to the player
				equip the player with a diamond helmet of protection 4 and unbreaking 3 and mending 1
				equip the player with a diamond chestplate of protection 4 and unbreaking 3 and mending 1
				equip the player with a diamond leggings of protection 4 and unbreaking 3 and mending 1
				equip the player with a diamond boots of protection 4 and unbreaking 3 and mending 1
				give player 1 diamond sword of sharpness 5 and unbreaking 3 and mending 1 and fire aspect 2
				give player 1 bow of power 5 and punch 2 and flame 1 and infinity 1 and unbreaking 3
				give player 1 arrow
			player does not have permission "admin":
				send action bar "&cYou can't use this item." to player
				remove item from the player

on damage:
	attacker is holding a blaze rod named "&6&l&nThe Chad Stick&r &7&l|&eMode 2&7&l|":
		attacker is sneaking:	
			attacker has the permission "admin":
				add 1500 to {money::%victim%}
				send "&eYou've received &6$1,500&e from &6%attacker%" to the victim
				send "&eYou gave &6$1,500 &eto &6%victim%" to attacker
			attacker does not have the permission "admin":
				send action bar "&cYou can't use this item." to attacker
				cancel event
		attacker is not sneaking:
			attacker is a player
			damage cause is attack
			attacker has the permission "admin":
				strike lightning at the victim
				damage the victim by 20 hearts
			attacker does not have permission "admin":
				send action bar "&cYou can't use this item." to attacker
				remove all blaze rods from attacker
				cancel event

#Mode 3
				


on damage:
	attacker is holding a blaze rod named "&6&l&nThe Chad Stick&r &7&l|&eMode 3&7&l|":
		attacker is sneaking:	
			attacker has the permission "admin":
				clear victim's inventory
				send "&a&LRUh oh! &aLooks like you just got fucking &A&L&ORAPED &aand ur inventory got cleared! Try harder next time %victim%" to victim
				send "&ECleared &6&l%victim%&6&l's &einventory!" to attacker
			attacker does not have the permission "admin":
				remove all blaze rods from attacker
				cancel event
		attacker is not sneaking:
			attacker has the permission "admin":
				kill the victim
			attacker does not have the permission "admin":
				remove 1 blaze rod from attacker
				cancel event

#Mode Switch

on drop of blaze rod:
	name of event-item is "&6&l&nThe Chad Stick&r &7&l|&eMode 1&7&l|":
		player has the permission "admin":
			cancel event
			wait 1 tick
			make player execute command "/rename &6&l&nThe Chad Stick&r &7&l|&eMode 2&7&l|"
		player does not have the permission "admin":
			send action bar "&cYou cannot use this item!" to player
			cancel event
			
on drop of blaze rod:
	name of event-item is "&6&l&nThe Chad Stick&r &7&l|&eMode 2&7&l|":
		player has the permission "admin":
			cancel event
			wait 1 tick
			make player execute command "/rename &6&l&nThe Chad Stick&r &7&l|&eMode 3&7&l|"
			send "&6&lWARNING: &eMode 3 is VERY powerful, don't fuck up by accident" to player
		player does not have the permission "admin":		
			send action bar "&cYou cannot use this item!" to player
			cancel event

on drop of blaze rod:
	name of event-item is "&6&l&nThe Chad Stick&r &7&l|&eMode 3&7&l|":
		player has the permission "admin":
			cancel event
			wait 1 tick
			make player execute command "/rename &6&l&nThe Chad Stick&r &7&l|&eMode 1&7&l|"
		player does not have the permission "admin":		
			send action bar "&cYou cannot use this item!" to player
			cancel event

#Extra

on left click holding a blaze rod:
	name of event-item is "&6&l&nThe Chad Stick&r &7&l|&eMode 1&7&l|", "&6&l&nThe Chad Stick&r &7&l|&eMode 2&7&l|" or "&6&l&nThe Chad Stick&r &7&l|&eMode 3&7&l|":
		player does not have the permission "admin":
			remove the item from the player

on load:
	login to "NzAyOTc4MTg1OTk3OTc1Nzk0.XqH5eA.6FCvDxV-w75aFoYXO3lI457oqzo" with the name "beans"
 
on guild message received:
	content of event-message doesn't start with "!"
	if id of event-channel is "702977549533446194":
		set {_r::*} to roles of event-member
		send "&3[Discord] &7(%{_r::1} ? """"%&7) %event-member%&8: &f%event-message%" to all players
	if id of event-channel is "703352557526974494":
		send "%nl% &e[SC] &6%event-member%&7: &6%content of event-message%%nl%" to all players where [isStaff(input) is true]
	if id of event-channel is "703371028394541118":
		console command content of event-message if content of event-message doesn't start with "##"
 
on chat:
	wait 5 ticks
	event isn't canceled
	set {_p} to "%player%"
	replace all "_" with "\_" in {_p}
	replace all "@everyone", "@here" and "538205671712358450" with "" in message
	send "**%uncolored player(player)%:** %message%" to channel with id "702977549533446194" with "beans"
	
on join:
	send ":white_check_mark: **%uncolored player(player)%** joined the server." to channel with id "702977549533446194" with "beans" if {v::%player%} isn't set
	
on quit:
	send ":x: **%uncolored player(player)%** left the server." to channel with id "702977549533446194" with "beans"
	
discord command !tps:
	trigger:
		send "TPS: %tps%" to event-channel with "beans"
		
discord command !list:
	trigger:
		send "Staff:%nl%```%all players where [isStaff(input) is true] ? ""No Staff""%```%nl%Players:%nl%```%all players where [isStaff(input) is false] ? ""No Defaults""%```%nl%`%amount of online players%/%{max}%`" to event-channel with "beans"
		
on command:
	command isn't "shop" or "sell"
	send "[%now%] **%player ? ""Console""%** ran **/%full command%**" to channel with id "703371028394541118" with "beans"

command /ec [<offline player=%player%>]:
	trigger:
		if donatorLevel(player) < 1:
			send "&7That command is for &a&lVip &7and above."
		else:
			open arg's enderchest to player if isStaff(player) is true
			open player's enderchest to player if isStaff(player) is not true
			
command /craft [<offline player=%player%>]:
	trigger:
		if donatorLevel(player) < 1:
			send "&7That command is for &a&lVip &7and above."
		else:
			open crafting table for player
			
command /trash:
	trigger:
		if donatorLevel(player) < 1:
			send "&7That command is for &a&lVip &7and above."
		else:
			open chest inventory with 5 rows named "&8Androdir" to player

command /rename [<text>]:
	trigger:
		if donatorLevel(player) < 2:
			send "&7That command is for &b&lPremium &7and above."
		else:
			arg doesn't contain "crate" and "left"
			set name of tool to colored arg
				
command /hat:
	trigger:
		if donatorLevel(player) < 2:
			send "&7That command is for &b&lPremium &7and above."
		else:		
			tool isn't air
			set {_current} to player's helmet
			set player's helmet to tool
			set tool to air if "%{_current}%" is "<none>"
			set tool to {_current}
		
command /fix:
	trigger:
		if donatorLevel(player) < 3:
			send "&7That command is for &d&lLegend &7and above."
		else:		
			loop all items in player's inventory:
				durability of tool is set
				repair loop-item
			send "&7Succesfully repaired all of your items."

command /autosell:
	trigger:
		if donatorLevel(player) < 3:
			send "&7That command is for &d&lLegend &7and above."
		else:		
			if {autosell::%player%} isn't set:
				set {autosell::%player%} to true
				send "&7Enabled autosell."
			else:
				delete {autosell::%player%}
				send "&7Disabled autosell."
			
command /gamer:
	trigger:
		if donatorLevel(player) < 4:
			send "&7That command is for &9&lGamer &7and above."
		else:
			send "&7Claimed some epic &9&lGamer &7perks."
			send " &9- &7Added all tags"
			loop {tagDisplay::*}:
				add loop-index to {tags::%player%::*}
				
command /color [<text=&f>]:
	trigger:
		if donatorLevel(player) < 4:
			send "&7That command is for &9&lGamer &7and above."
		else:
			open chest inventory with 2 rows named "&8Colors" to player
			set slot 0 of player's current inventory to white wool named "&fWhite Chat" with lore "&fThis is your chat."
			set slot 1 of player's current inventory to pink wool named "&dPink Chat" with lore "&dThis is your chat."
			set slot 2 of player's current inventory to yellow wool named "&eYellow Chat" with lore "&eThis is your chat."
			set slot 3 of player's current inventory to orange wool named "&6Gold Chat" with lore "&6This is your chat."
			set slot 4 of player's current inventory to light blue wool named "&bAqua Chat" with lore "&bThis is your chat."
			set slot 5 of player's current inventory to lime wool named "&aGreen Chat" with lore "&aThis is your chat."
			set slot 6 of player's current inventory to cyan wool named "&3Cyan Chat" with lore "&3This is your chat."
			set slot 7 of player's current inventory to red wool named "&cRed Chat" with lore "&cThis is your chat."
			set slot 8 of player's current inventory to blue wool named "&9Blue Chat" with lore "&9This is your chat."
			set slot 12 of player's current inventory to gold block named "&lBold" with lore "&fSet your chat to &lbold&f."
			set slot 14 of player's current inventory to iron block named "&lItalic" with lore "&fSet your chat to &oitalic&f."
			
on inventory click:
	inventory name of player's current inventory contains "&8Colors"
	cancel event
	set {color::%player%} to "&f" if type of event-item is white wool
	set {color::%player%} to "&d" if type of event-item is pink wool
	set {color::%player%} to "&e" if type of event-item is yellow wool
	set {color::%player%} to "&6" if type of event-item is orange wool
	set {color::%player%} to "&b" if type of event-item is light blue wool
	set {color::%player%} to "&a" if type of event-item is lime wool
	set {color::%player%} to "&3" if type of event-item is cyan wool
	set {color::%player%} to "&c" if type of event-item is red wool
	set {color::%player%} to "&9" if type of event-item is blue wool
	set {color::%player%} to "%{color::%player%}%&l" if type of event-item is gold block
	set {color::%player%} to "%{color::%player%}%&o" if type of event-item is iron block
	send "%{color::%player%}%This is your new chat color."
	
command /nick [<text>]:
	trigger:
		if donatorLevel(player) < 4:
			send "&7That command is for &9&lGamer &7and above."
		else:
			if arg isn't set:
				send "&c/nick <nickname | off>"
			else:
				if arg is "off":
					delete {nickname::%player%}
					send "&7Cleared your nickname."
				else:
					if {nickname::*} contains arg:
						send "&cSomeone already has that name."
					else:
						if "%all offline players%" contains arg:
							send "&cSomeone already has that name."
						else:
							set {nickname::%player%} to colored arg
							send "&7Your name is now %player(player)%&7."
							
on break:
	if {superbreaker::%player%} is true:
		loop all blocks in radius 3 of event-block:
			within(location of loop-block, {mine1}, {mine2}) is true
			give player 1 of loop-block
			set loop-block to air
			
command /superbreaker:
	trigger:
		if donatorLevel(player) < 5:
			send "&7That command is for &3&lPatron &7and above."
		else:		
			if {superbreaker::%player%} isn't set:
				set {superbreaker::%player%} to true
				send "&7Enabled super breaker."
			else:
				delete {superbreaker::%player%}
				send "&7Disabled super breaker."
							
command /prefix [<text>]:
	trigger:
		if donatorLevel(player) < 5:
			send "&7That command is for &3&lPatron &7and above."
		else:
			if arg isn't set:
				send "&c/prefix <prefix | off>"
			else:
				if arg is "off":
					delete {prefix::%player%}
					send "&7Cleared your prefix."
				else:
					if arg contains "admin" or "mod" or "owner":
						send "&cSorry, you can't have a staff prefix :p"
					else:
						set {prefix::%player%} to colored arg
						send "&7Updated your name to %player(player)%"

command /mine:
	cooldown: 5 minutes
	trigger:
		if donatorLevel(player) < 5:
			send "&7That command is for &3&lPatron &7and above."
		else:
			loop all entities where [within(location of input, {mine1}, {mine2}) is true]:
				teleport loop-entity to location(loop-entity's x coordinate, 35, loop-entity's z coordinate, loop-entity's world)
			loop all blocks within block at {mine1} and block at {mine2}:
				loop-block is air
				set {_n} to random integer between 1 and 1000
				set loop-block to stone if {_n} is between 1 and 600
				set loop-block to coal ore if {_n} is between 600 and 750
				set loop-block to iron ore if {_n} is between 750 and 920
				set loop-block to lapis ore if {_n} is between 920 and 970
				set loop-block to diamond ore if {_n} is between 970 and 1000
			loop all entities where [within(location of input, {mine3}, {mine4}) is true]:
				teleport loop-entity to location(loop-entity's x coordinate, 71, loop-entity's z coordinate, loop-entity's world)
			loop all blocks within block at {mine3} and block at {mine4}:
				loop-block is air
				set {_n} to random integer between 1 and 1000
				set loop-block to emerald ore if {_n} is between 1 and 800
				set loop-block to emerald block if {_n} is between 801 and 1000
			cancel cooldown if isStaff(player) is true
							
command /realname [<text>]:
	trigger:
		if arg isn't set:
			send "&c/realname (nickname)"
		else:
			loop {nickname::*}:
				set {_p} to loop-index parsed as offline player
				if {nickname::%{_p}%} is set:
					if arg is "%{_p}%":
						send "%{_p}% - %{nickname::%{_p}%}%"
					else:
						if {nickname::%{_p}%} contains arg:
							send "%{_p}% - %{nickname::%{_p}%}%"
						
command /process [<offline player>] [<text>]:
	permission: admin
	permission message: &cYou don't have access to that command.
	trigger:
		if arg 2 is "bean", "bully", "covid", "rapist", "tyrant" or "gay":
			add arg 2 to {tags::%arg 1%::*}
			broadcast ""
			broadcast " &6[/BUY] &6%arg 1% bought &6%{tagDisplay::%arg 2%}% &6tag"
			broadcast " &7everyone gets &6$5k &7:OO"
			broadcast ""
			loop all players:
				add 5000 to {money::%loop-player%}
		if arg 2 contains "key":
			if arg 2 is "key1":
				give 1 tripwire hook named "&7Crate Key &7(Right Click | Left Click)" with lore "&7Crate Key" to arg 1's inventory
				broadcast ""
				broadcast " &6[/BUY] &6%arg 1% bought &61x crate key"
				broadcast " &7everyone gets &6$5k &7:OO"
				broadcast ""
				loop all players:
					add 5000 to {money::%loop-player%}
			if arg 2 is "key5":
				give 5 tripwire hook named "&7Crate Key &7(Right Click | Left Click)" with lore "&7Crate Key" to arg 1's inventory
				broadcast ""
				broadcast " &6[/BUY] &6%arg 1% bought &65x crate keys"
				broadcast " &7everyone gets &6$15k &7:OO"
				broadcast ""
				loop all players:
					add 15000 to {money::%loop-player%}
			if arg 2 is "key10":
				give 10 tripwire hook named "&7Crate Key &7(Right Click | Left Click)" with lore "&7Crate Key" to arg 1's inventory
				broadcast ""
				broadcast " &6[/BUY] &6%arg 1% bought &610x crate keys"
				broadcast " &7everyone gets &6$30k &7:OO"
				broadcast ""
				loop all players:
					add 30000 to {money::%loop-player%}
		if arg 2 contains "mutli":
			if arg 2 is "mutli025":
				add .25 to {multi::%arg 1%}
				broadcast ""
				broadcast " &6[/BUY] &6%arg 1% bought &6.25x sell multi"
				broadcast " &7everyone gets &6$10k &7:OO"
				broadcast ""
				loop all players:
					add 10000 to {money::%loop-player%}
			if arg 2 is "mutli05":
				add .5 to {multi::%arg 1%}
				broadcast ""
				broadcast " &6[/BUY] &6%arg 1% bought &6.5x sell multi"
				broadcast " &7everyone gets &6$20k &7:OO"
				broadcast ""
				loop all players:
					add 20000 to {money::%loop-player%}
			if arg 2 is "mutli1":
				add 1 to {multi::%arg 1%}
				broadcast ""
				broadcast " &6[/BUY] &6%arg 1% bought &61x sell multi"
				broadcast " &7everyone gets &6$50k &7:OO"
				broadcast ""
				loop all players:
					add 50000 to {money::%loop-player%}
		if arg 2 is "oppick":
			give unbreakable diamond pickaxe of efficiency 10 and fortune 6 with lore "&7Flight", "&7Upgrader", "&7Money", "&7Blast" and "&7Merchant" to arg 1's inventory
			broadcast ""
			broadcast " &6[/BUY] &6%arg 1% bought &61x op pickaxe (eff 10 fortune 6 + max ces)"
			broadcast " &7everyone gets &6$30k &7:OO"
			broadcast ""
			loop all players:
				add 30000 to {money::%loop-player%}
		if arg 2 is "opsword":
			give unbreakable diamond sword of sharpness 7 and fire aspect 5 and mending with lore "&7Lifesteal", "&7Speed", "&7Doubler", "&7Slowing", "&7Wither", "&7Milk", "&7Block" and "&7Counter" to arg 1's inventory
			broadcast ""
			broadcast " &6[/BUY] &6%arg 1% bought &61x op sword (sharp 7 fire 5 + max ces)"
			broadcast " &7everyone gets &6$30k &7:OO"
			broadcast ""
			loop all players:
				add 30000 to {money::%loop-player%}
		if arg 2 is "oparmor":
			give unbreakable all diamond armor of protection 5 to arg 1's inventory
			broadcast ""
			broadcast " &6[/BUY] &6%arg 1% bought &61x op armor set (prot 5)"
			broadcast " &7everyone gets &6$50k &7:OO"
			broadcast ""
			loop all players:
				add 50000 to {money::%loop-player%}
		if arg 2 is "unpunish":
			broadcast ""
			broadcast " &6[/BUY] &6%arg 1% bought &7an &6unpunish"
			broadcast ""
			unban arg 1
			set {mutet::%arg 1%} to 1 second
		if arg 2 is "vip":
			set {rank::%arg 1%} to arg 2 if {rank::%arg 1%} isn't "admin", "srmod", "mod", "premium", "legend" or "gamer"
			broadcast ""
			broadcast " &6[/BUY] &6%arg 1% bought &a&lVip &6rank"
			broadcast " &7everyone gets &6$10k &7:OO"
			broadcast ""
			loop all players:
				add 10000 to {money::%loop-player%}		
		if arg 2 is "premium":
			set {rank::%arg 1%} to arg 2 if {rank::%arg 1%} isn't "admin", "srmod", "mod", "legend" or "gamer"
			broadcast ""
			broadcast " &6[/BUY] &6%arg 1% bought &b&lPremium &6rank"
			broadcast " &7everyone gets &6$25k &7:OO"
			broadcast ""
			loop all players:
				add 25000 to {money::%loop-player%}		
		if arg 2 is "legend":
			set {rank::%arg 1%} to arg 2 if {rank::%arg 1%} isn't "admin", "srmod", "mod" or "gamer"
			broadcast ""
			broadcast " &6[/BUY] &6%arg 1% bought &d&lLegend &6rank"
			broadcast " &7everyone gets &6$50k &7:OO"
			broadcast ""
			loop all players:
				add 50000 to {money::%loop-player%}
		if arg 2 is "gamer":
			set {rank::%arg 1%} to arg 2 if {rank::%arg 1%} isn't "admin", "srmod", "mod" or "patron"
			broadcast ""
			broadcast " &6[/BUY] &6%arg 1% bought &9&lGamer &6rank"
			broadcast " &7everyone gets &6$200k &7:OO"
			broadcast ""
			loop all players:
				add 200000 to {money::%loop-player%}						
		if arg 2 is "patron":
			set {rank::%arg 1%} to arg 2 if {rank::%arg 1%} isn't "admin", "srmod" or "mod"
			broadcast ""
			broadcast " &6[/BUY] &6%arg 1% bought &3&lPatron &6rank"
			broadcast " &7everyone gets &6$350k &7:OO"
			broadcast ""
			loop all players:
				add 350000 to {money::%loop-player%}	

function regex(n: object) :: text:
    if "%{_n}%" contains ".":
        set {_s::*} to split "%{_n}%" at "."
        set {_n} to "%a({_s::1})%.%last 2 characters of {_s::2}%"
        return "%{_n}%"
    else:
        set {_n} to a("%{_n}%")
        return "%{_n} ? 0%"
		
function a(b: text) :: text:
    if length of {_b} > 3:
        return "%a(first length of {_b} - 3 characters of {_b})%,%last 3 characters of {_b}%"
    return {_b}

function merchant(p: player):
	set {_sto} to amount of stone in {_p}'s inventory
	set {_coa} to amount of coal ore in {_p}'s inventory
	set {_iro} to amount of iron ore in {_p}'s inventory
	set {_iron} to amount of iron ingot in {_p}'s inventory
	set {_lap} to amount of lapis ore in {_p}'s inventory
	set {_dia} to amount of diamond ore in {_p}'s inventory
	set {_eme} to amount of emerald in {_p}'s inventory
	set {_emeb} to amount of emerald block in {_p}'s inventory
		
	add {_cob} * 1 to {_$}
	add {_sto} * 2 to {_$}
	add {_coa} * 5 to {_$}
	add {_iro} * 10 to {_$}
	add {_iron} * 12 to {_$}
	add {_lap} * 40 to {_$}
	add {_dia} * 60 to {_$}
	add {_eme} * 100 to {_$}
	add {_emeb} * 900 to {_$}
		
	remove all stone, coal ore, iron ore, iron ingot, lapis ore and diamond ore and emerald and emerald block from {_p}'s inventory
		
	set {_m} to 1
	add {multi::%{_p}%} to {_m}
	add {clanMulti::%{clan::%{_p}%}%} to {_m}
	set {_$} to {_$} * {_m}
	send "&6&l[MERCHANT] &7Successfully sold for &6$%regex({_$})%&7." to {_p}
	add {_$} to {money::%{_p}%}

command /sell [<text>]:
	trigger:
		set {_sto} to amount of stone in player's inventory
		set {_coa} to amount of coal ore in player's inventory
		set {_iro} to amount of iron ore in player's inventory
		set {_lap} to amount of lapis ore in player's inventory
		set {_dia} to amount of diamond ore in player's inventory
		set {_eme} to amount of emerald in player's inventory
		set {_emeb} to amount of emerald block in player's inventory
			
		add {_sto} * 2 to {_$}
		add {_coa} * 5 to {_$}
		add {_iro} * 10 to {_$}
		add {_iron} * 12 to {_$}
		add {_lap} * 20 to {_$}
		add {_dia} * 30 to {_$}
		add {_eme} * 50 to {_$}
		add {_emeb} * 450 to {_$}

		{_$} > 0
		remove all stone, coal ore, iron ore, iron ingot, lapis ore and diamond ore and emerald and emerald block from player's inventory
		set {_m} to 1
		add {multi::%player%} to {_m}
		add {clanMulti::%{clan::%player%}%} to {_m}
		set {_$} to {_$} * {_m}
		add {_$} to {money::%player%}
		send "&7Successfully sold for &6$%regex({_$})%&7."
	
command /bal [<offline player=%player%>]:
	trigger:
		send "&6%arg%&6's &7money is &6$%regex({money::%arg%}) ? 0%&7."
		
command /pay [<offline player>] [<number>]:
	trigger:
		add 0 to {money::%player%}
		if arg 2 isn't set:
			send "&c/pay <player> <amount>"
		else:
			if arg 2 > {money::%player%}:
				send "&cYou don't have enough money for that."
			else:
				if arg 2 < 100:
					send "&cPay minimum is $100."
				else:
					remove arg 2 from {money::%player%}
					add arg 2 to {money::%arg 1%}
					send "&7Gave &6$%arg 2% &7to &6%arg 1%&7."
					send "&6%player% &7paid you &6$%arg 2%&7." to arg 1
				
command /statsedit [<offline player>] [<text>] [<text>] [<number>]:
	permission: admin
	permission message: &cYou don't have access to that command.
	trigger:
		if arg 4 isn't set:
			send "&c/statsedit <player | online | offline> <stat> <set | add | remove> <number>"
		else:
			if arg 3 isn't "set", "add" or "remove":
				player command "/statsedit"
			else:
				if arg 1 is "online":
					loop all players:
						set {%arg 2%::%loop-player%} to arg 4
					send "&7Set all online player's &6%arg 2% &7stat to &6%arg 4%&7."
				if arg 1 is "offline":
					loop {%arg 2%::*}:
						set {%arg 2%::%loop-index%} to arg 4
					send "&7Set all player's &6%arg 2% &7stat to &6%arg 4%&7."		
				else:
					if arg 3 is "set":
						set {%arg 2%::%arg 1%} to arg 4
					if arg 3 is "add":
						add arg 4 to {%arg 2%::%arg 1%}
					if arg 3 is "remove":
						remove arg 4 from {%arg 2%::%arg 1%}
					send "&7Set &6%arg 1%&6's &6%arg 2% &7to &6%{%arg 2%::%arg 1%}%&7."

command /baltop [<text>]:
	trigger:
		loop {money::*}:
			loop-value > 0
			loop-value < 1000000000
			add 1 to {_size}
			if {_low.to.high.list::%loop-value%} is not set:
				set {_low.to.high.list::%loop-value%} to loop-index
			else:
				set {_n} to 0
				loop {_size} times:
					set {_n} to {_n}+1
					{_low.to.high.list::%loop-value-1%.%{_n}%} is not set
					set {_low.to.high.list::%loop-value-1%.%{_n}%} to loop-index
					stop loop
		wait 1 tick
		set {_n} to size of {_low.to.high.list::*}
		loop {_low.to.high.list::*}:
			set {_high.to.low.list::%{_n}%} to loop-value
			set {_n} to {_n}-1
		wait 1 tick
		set {_i} to 0
		send ""
		send "     &6&l&nBaltop"
		send ""
		loop {_high.to.low.list::*}:
			add 1 to {_topnumber}
			set {_player} to "%loop-value%" parsed as offlineplayer
			send " &6##%{_topnumber}% &7%{_player} ? loop-value% &6($%regex({money::%loop-value%})%&6)"
			add 1 to {_i}
			if {_topnumber} > 4:
				stop loop
		send ""
		
command /killtop [<text>]:
	trigger:
		loop {kills::*}:
			loop-value > 0
			loop-value < 1000000000
			add 1 to {_size}
			if {_low.to.high.list::%loop-value%} is not set:
				set {_low.to.high.list::%loop-value%} to loop-index
			else:
				set {_n} to 0
				loop {_size} times:
					set {_n} to {_n}+1
					{_low.to.high.list::%loop-value-1%.%{_n}%} is not set
					set {_low.to.high.list::%loop-value-1%.%{_n}%} to loop-index
					stop loop
		wait 1 tick
		set {_n} to size of {_low.to.high.list::*}
		loop {_low.to.high.list::*}:
			set {_high.to.low.list::%{_n}%} to loop-value
			set {_n} to {_n}-1
		wait 1 tick
		set {_i} to 0
		send ""
		send "     &6&l&nTop Killers"
		send ""
		loop {_high.to.low.list::*}:
			set {_player} to "%loop-value%" parsed as offlineplayer
			"%{_player}%" isn't "<none>"
			add 1 to {_topnumber}
			send " &6##%{_topnumber}% &7%{_player}% &6(%regex({kills::%loop-value%})%&6 kills)"
			add 1 to {_i}
			if {_topnumber} > 4:
				stop loop
		send ""

command /blocktop [<text>]:
	trigger:
		loop {blocks::*}:
			loop-value > 0
			loop-value < 1000000000
			add 1 to {_size}
			if {_low.to.high.list::%loop-value%} is not set:
				set {_low.to.high.list::%loop-value%} to loop-index
			else:
				set {_n} to 0
				loop {_size} times:
					set {_n} to {_n}+1
					{_low.to.high.list::%loop-value-1%.%{_n}%} is not set
					set {_low.to.high.list::%loop-value-1%.%{_n}%} to loop-index
					stop loop
		wait 1 tick
		set {_n} to size of {_low.to.high.list::*}
		loop {_low.to.high.list::*}:
			set {_high.to.low.list::%{_n}%} to loop-value
			set {_n} to {_n}-1
		wait 1 tick
		set {_i} to 0
		send ""
		send "     &6&l&nBlocktop"
		send ""
		loop {_high.to.low.list::*}:
			add 1 to {_topnumber}
			set {_player} to "%loop-value%" parsed as offlineplayer
			send " &6##%{_topnumber}% &7%{_player} ? loop-value% &6(%regex({blocks::%loop-value%})%&6 blocks)"
			add 1 to {_i}
			if {_topnumber} > 4:
				stop loop
		send ""

command /xp:
	trigger:
		set {_$} to player's total xp * 10
		send "&7Translated &6%regex(player's total xp)%&6xp &7to &6$%regex({_$})%&7."
		set player's total xp to 0
		add {_$} to {money::%player%}

function enchantGui(p: player):
	add 0 to {money::%{_p}%}
	open chest inventory with 3 rows named "&8Enchanter" to {_p}
	set slot 10 of {_p}'s current inventory to {_p}'s tool
	set slot 3, 12 and 21 of {_p}'s current inventory to black stained glass pane named "&0"
	
	if {_p}'s tool is a diamond pickaxe:

		set {_l} to "&7Efficiency 1/9: $500" if level of efficiency on {_p}'s tool isn't set
		set {_l} to "&7Efficiency 2/9: $1,000" if level of efficiency on {_p}'s tool is 1
		set {_l} to "&7Efficiency 3/9: $2,500" if level of efficiency on {_p}'s tool is 2
		set {_l} to "&7Efficiency 4/9: $5,000" if level of efficiency on {_p}'s tool is 3
		set {_l} to "&7Efficiency 5/9: $10,000" if level of efficiency on {_p}'s tool is 4
		set {_l} to "&7Efficiency 6/9: $25,000" if level of efficiency on {_p}'s tool is 5
		set {_l} to "&7Efficiency 7/9: $50,000" if level of efficiency on {_p}'s tool is 6
		set {_l} to "&7Efficiency 8/9: $75,000" if level of efficiency on {_p}'s tool is 7
		set {_l} to "&7Efficiency 9/9: $250,000" if level of efficiency on {_p}'s tool is 8
		set {_l} to "&7Already Maxed!" if level of efficiency on {_p}'s tool >= 9
		
		set slot 4 of {_p}'s current inventory to enchanted book named "&6Efficiency" with lore {_l}
		
		set {_l} to "&7Fortune 1/5: $5,000" if level of fortune on {_p}'s tool isn't set
		set {_l} to "&7Fortune 2/5: $10,000" if level of fortune on {_p}'s tool is 1
		set {_l} to "&7Fortune 3/5: $25,000" if level of fortune on {_p}'s tool is 2
		set {_l} to "&7Fortune 4/5: $50,000" if level of fortune on {_p}'s tool is 3
		set {_l} to "&7Fortune 5/5: $100,000" if level of fortune on {_p}'s tool is 4
		set {_l} to "&7Already Maxed!" if level of fortune on {_p}'s tool >= 5
		
		set slot 5 of {_p}'s current inventory to enchanted book named "&6Fortune" with lore {_l}
		
		set {_l} to "&7Unbreaking 1/3: $1,000" if level of unbreaking on {_p}'s tool isn't set
		set {_l} to "&7Unbreaking 2/3: $5,000" if level of unbreaking on {_p}'s tool is 1
		set {_l} to "&7Unbreaking 3/3: $10,000" if level of unbreaking on {_p}'s tool is 2
		set {_l} to "&7Already Maxed!" if level of unbreaking on {_p}'s tool >= 3
		
		set slot 6 of {_p}'s current inventory to enchanted book named "&6Unbreaking" with lore {_l}
		
		set {_l} to "&6Merchant: $100,000" if hasCe({_p}, "Merchant") is false
		set {_l} to "&7Already Maxed!" if hasCe({_p}, "Merchant") is true
		
		set slot 7 of {_p}'s current inventory to skull of ("Villager" parsed as offline player) named "&7Merchant" with lore {_l} and "&70.05%% chance to auto sell at 2x value."
		
		set {_l} to "&6Flight: $250,000" if hasCe({_p}, "Flight") is false
		set {_l} to "&7Already Maxed!" if hasCe({_p}, "Flight") is true
		
		set slot 8 of {_p}'s current inventory to feather named "&7Flight" with lore {_l} and "&7Allows you to fly inside of the mine."
		
		
		set {_l} to "&6Upgrader: $100,000" if hasCe({_p}, "Upgrader") is false
		set {_l} to "&7Already Maxed!" if hasCe({_p}, "Upgrader") is true
		
		set slot 13 of {_p}'s current inventory to diamond named "&7Upgrader" with lore {_l} and "&71%% chance to create a patch of diamonds."
		
		set {_l} to "&6Money: $100,000" if hasCe({_p}, "Money") is false
		set {_l} to "&7Already Maxed!" if hasCe({_p}, "Money") is true
		
		set slot 14 of {_p}'s current inventory to emerald named "&7Money" with lore {_l} and "&71%% chance to award $100-5000."
		
		set {_l} to "&6Blast: $500,000" if hasCe({_p}, "Blast") is false
		set {_l} to "&7Already Maxed!" if hasCe({_p}, "Blast") is true
		
		set slot 15 of {_p}'s current inventory to tnt named "&7Blast" with lore {_l} and "&7Breaks all blocks in a small area."
	
	if {_p}'s tool is any diamond armor:
	
		set {_l} to "&7Protection 1/4: $1,000" if level of protection on {_p}'s tool isn't set
		set {_l} to "&7Protection 2/4: $5,000" if level of protection on {_p}'s tool is 1
		set {_l} to "&7Protection 3/4: $10,000" if level of protection on {_p}'s tool is 2
		set {_l} to "&7Protection 4/4: $25,000" if level of protection on {_p}'s tool is 3
		set {_l} to "&7Already Maxed!" if level of protection on {_p}'s tool >= 4
		
		set slot 4 of {_p}'s current inventory to enchanted book named "&6Protection" with lore {_l}
		
		set {_l} to "&7Unbreaking 1/3: $1,000" if level of unbreaking on {_p}'s tool isn't set
		set {_l} to "&7Unbreaking 2/3: $5,000" if level of unbreaking on {_p}'s tool is 1
		set {_l} to "&7Unbreaking 3/3: $10,000" if level of unbreaking on {_p}'s tool is 2
		set {_l} to "&7Already Maxed!" if level of unbreaking on {_p}'s tool >= 3
		
		set slot 5 of {_p}'s current inventory to enchanted book named "&6Unbreaking" with lore {_l}
		
	if {_p}'s tool is diamond sword:
	
		set {_l} to "&7Sharpness 1/5: $1,000" if level of sharpness on {_p}'s tool isn't set
		set {_l} to "&7Sharpness 2/5: $5,000" if level of sharpness on {_p}'s tool is 1
		set {_l} to "&7Sharpness 3/5: $10,000" if level of sharpness on {_p}'s tool is 2
		set {_l} to "&7Sharpness 4/5: $25,000" if level of sharpness on {_p}'s tool is 3
		set {_l} to "&7Sharpness 5/5: $50,000" if level of sharpness on {_p}'s tool is 4
		set {_l} to "&7Already Maxed!" if level of sharpness on {_p}'s tool >= 5
		
		set slot 4 of {_p}'s current inventory to enchanted book named "&6Sharpness" with lore {_l}		
		
		set {_l} to "&7Unbreaking 1/3: $1,000" if level of unbreaking on {_p}'s tool isn't set
		set {_l} to "&7Unbreaking 2/3: $5,000" if level of unbreaking on {_p}'s tool is 1
		set {_l} to "&7Unbreaking 3/3: $10,000" if level of unbreaking on {_p}'s tool is 2
		set {_l} to "&7Already Maxed!" if level of unbreaking on {_p}'s tool >= 3
		
		set slot 5 of {_p}'s current inventory to enchanted book named "&6Unbreaking" with lore {_l}
		
		set {_l} to "&7Fire Aspect 1/2: $10,000" if level of fire aspect on {_p}'s tool isn't set
		set {_l} to "&7Fire Aspect 2/2: $25,000" if level of fire aspect on {_p}'s tool is 1

		set {_l} to "&7Already Maxed!" if level of fire aspect on {_p}'s tool >= 2
		
		set slot 6 of {_p}'s current inventory to enchanted book named "&6Fire Aspect" with lore {_l}
		
		set {_l} to "&6Lifesteal: $100,000" if hasCe({_p}, "Lifesteal") is false
		set {_l} to "&7Already Maxed!" if hasCe({_p}, "Lifesteal") is true
		
		set slot 7 of {_p}'s current inventory to glass bottle named "&7Lifesteal" with lore {_l} and "&710%% chance to give you 50%% of the damage in health."
	
		set {_l} to "&6Speed: $50,000" if hasCe({_p}, "Speed") is false
		set {_l} to "&7Already Maxed!" if hasCe({_p}, "Speed") is true
		
		set slot 8 of {_p}'s current inventory to diamond boots named "&7Speed" with lore {_l} and "&7Gives you speed when you hit someone."

		set {_l} to "&6Doubler: $200,000" if hasCe({_p}, "Doubler") is false
		set {_l} to "&7Already Maxed!" if hasCe({_p}, "Doubler") is true
		
		set slot 13 of {_p}'s current inventory to blaze powder named "&7Doubler" with lore {_l} and "&710%% chance to deal double damage."
		
		set {_l} to "&6Slowing: $100,000" if hasCe({_p}, "Slowing") is false
		set {_l} to "&7Already Maxed!" if hasCe({_p}, "Slowing") is true
		
		set slot 14 of {_p}'s current inventory to leather boots named "&7Slowing" with lore {_l} and "&710%% chance to slow the victim for 5 seconds."
		
		set {_l} to "&6Wither: $200,000" if hasCe({_p}, "Wither") is false
		set {_l} to "&7Already Maxed!" if hasCe({_p}, "Wither") is true
		
		set slot 15 of {_p}'s current inventory to wither skeleton skull named "&7Wither" with lore {_l} and "&710%% chance to wither the victim for 5 seconds."
		
		set {_l} to "&6Milk: $200,000" if hasCe({_p}, "Milk") is false
		set {_l} to "&7Already Maxed!" if hasCe({_p}, "Milk") is true
		
		set slot 16 of {_p}'s current inventory to milk named "&7Milk" with lore {_l} and "&710%% chance to remove all your negative effects."
		
		set {_l} to "&6Block: $200,000" if hasCe({_p}, "Block") is false
		set {_l} to "&7Already Maxed!" if hasCe({_p}, "Block") is true
		
		set slot 21 of {_p}'s current inventory to shield named "&7Block" with lore {_l} and "&710%% chance to set damage to 1/3."
		
		set {_l} to "&6Counter: $200,000" if hasCe({_p}, "Counter") is false
		set {_l} to "&7Already Maxed!" if hasCe({_p}, "Counter") is true		

		set slot 22 of {_p}'s current inventory to diamond sword named "&7Counter" with lore {_l} and "&75%% chance to counter the attack (1.5x dmg)."
		
	if {_p}'s tool is bow:
		
		set {_l} to "&7Power 1/5: $5,000" if level of power on {_p}'s tool isn't set
		set {_l} to "&7Power 2/5: $20,000" if level of power on {_p}'s tool is 1
		set {_l} to "&7Power 3/5: $50,000" if level of power on {_p}'s tool is 2
		set {_l} to "&7Power 4/5: $100,000" if level of power on {_p}'s tool is 3
		set {_l} to "&7Power 5/5: $200,000" if level of power on {_p}'s tool is 4
		set {_l} to "&7Already Maxed!" if level of power on {_p}'s tool >= 5
		
		set slot 4 of {_p}'s current inventory to enchanted book named "&6Power" with lore {_l}		
		
		set {_l} to "&7Unbreaking 1/3: $1,000" if level of unbreaking on {_p}'s tool isn't set
		set {_l} to "&7Unbreaking 2/3: $5,000" if level of unbreaking on {_p}'s tool is 1
		set {_l} to "&7Unbreaking 3/3: $10,000" if level of unbreaking on {_p}'s tool is 2
		set {_l} to "&7Already Maxed!" if level of unbreaking on {_p}'s tool >= 3
		
		set slot 5 of {_p}'s current inventory to enchanted book named "&6Unbreaking" with lore {_l}
		
		set {_l} to "&7Flame: $100,000" if level of flame on {_p}'s tool isn't set
		set {_l} to "&7Already Maxed!" if level of flame on {_p}'s tool is set
		
		set slot 6 of {_p}'s current inventory to enchanted book named "&6Flame" with lore {_l}
		
		set {_l} to "&7Infinity: $100,000" if level of infinity on {_p}'s tool isn't set
		set {_l} to "&7Already Maxed!" if level of infinity on {_p}'s tool is set
		
		set slot 7 of {_p}'s current inventory to enchanted book named "&6Infinity" with lore {_l}
		
function hasCe(p: player, ce: text) :: boolean:
	set {_l::*} to uncolored lore of {_p}'s tool
	return true if {_l::*} contains {_ce}
	return false
		
on right click:
	player's tool is diamond pickaxe, any diamond armor, diamond sword or bow
	{ct::%player%} isn't set
	player is sneaking
	cancel event
	enchantGui(player)
	
command /ce:
	trigger:
		{ct::%player%} isn't set
		enchantGui(player) if player's tool is diamond pickaxe, any diamond armor, diamond sword or bow
		send "&cYou must be holding an enchantable item." if player's tool isn't diamond pickaxe, any diamond armor, diamond sword or bow
	
on inventory click:
	inventory name of player's current inventory is "&8Enchanter"
	cancel event
	lore of event-item doesn't contain "max"
	tool is diamond pickaxe, any diamond armor, diamond sword or bow

	if name of event-item contains "efficiency":
		set {_l} to level of efficiency on tool ? 0
		{_l} < 9
		set {_c} to 500 if {_l} is 0
		set {_c} to 1000 if {_l} is 1
		set {_c} to 2500 if {_l} is 2
		set {_c} to 5000 if {_l} is 3
		set {_c} to 10000 if {_l} is 4
		set {_c} to 25000 if {_l} is 5
		set {_c} to 50000 if {_l} is 6
		set {_c} to 75000 if {_l} is 7
		set {_c} to 250000 if {_l} is 8
		if {money::%player%} < {_c}:
			send "&cYou don't have enough money."
		else:
			remove {_c} from {money::%player%}
			enchant tool with ("efficiency %{_l} + 1%" parsed as enchantment type)
			send "&6(-$%regex({_c})%&6) &7Successfully added &6Efficiency %{_l} + 1%&7."
			enchantGui(player)
					
	if name of event-item contains "fortune":
		set {_l} to level of fortune on tool ? 0
		{_l} < 5
		set {_c} to 5000 if {_l} is 0
		set {_c} to 10000 if {_l} is 1
		set {_c} to 25000 if {_l} is 2
		set {_c} to 50000 if {_l} is 3
		set {_c} to 100000 if {_l} is 4
		if {money::%player%} < {_c}:
			send "&cYou don't have enough money."
		else:
			remove {_c} from {money::%player%}
			enchant tool with ("fortune %{_l} + 1%" parsed as enchantment type)
			send "&6(-$%regex({_c})%&6) &7Successfully added &6Fortune %{_l} + 1%&7."
			enchantGui(player)
					
	if name of event-item contains "unbreaking":
		set {_l} to level of unbreaking on tool ? 0
		{_l} < 3
		set {_c} to 1000 if {_l} is 0
		set {_c} to 5000 if {_l} is 1
		set {_c} to 10000 if {_l} is 2
		if {money::%player%} < {_c}:
			send "&cYou don't have enough money."
		else:
			remove {_c} from {money::%player%}
			enchant tool with ("unbreaking %{_l} + 1%" parsed as enchantment type)
			send "&6(-$%regex({_c})%&6) &7Successfully added &6Unbreaking %{_l} + 1%&7."
			enchantGui(player)
					
	if name of event-item contains "protection":
		set {_l} to level of protection on tool ? 0
		{_l} < 4
		set {_c} to 1000 if {_l} is 0
		set {_c} to 5000 if {_l} is 1
		set {_c} to 10000 if {_l} is 2
		set {_c} to 25000 if {_l} is 3
		if {money::%player%} < {_c}:
			send "&cYou don't have enough money."
		else:
			remove {_c} from {money::%player%}
			enchant tool with ("protection %{_l} + 1%" parsed as enchantment type)
			send "&6(-$%regex({_c})%&6) &7Successfully added &6Protection %{_l} + 1%&7."
			enchantGui(player)
					
	if name of event-item contains "sharpness":
		set {_l} to level of sharpness on tool ? 0
		{_l} < 5
		set {_c} to 1000 if {_l} is 0
		set {_c} to 5000 if {_l} is 1
		set {_c} to 10000 if {_l} is 2
		set {_c} to 25000 if {_l} is 3
		set {_c} to 50000 if {_l} is 4
		if {money::%player%} < {_c}:
			send "&cYou don't have enough money."
		else:
			remove {_c} from {money::%player%}
			enchant tool with ("sharpness %{_l} + 1%" parsed as enchantment type)
			send "&6(-$%regex({_c})%&6) &7Successfully added &6Sharpness %{_l} + 1%&7."
			enchantGui(player)
					
	if name of event-item contains "fire aspect":
		set {_l} to level of fire aspect on tool ? 0
		{_l} < 2
		set {_c} to 10000 if {_l} is 0
		set {_c} to 25000 if {_l} is 1
		if {money::%player%} < {_c}:
			send "&cYou don't have enough money."
		else:
			remove {_c} from {money::%player%}
			enchant tool with ("fire aspect %{_l} + 1%" parsed as enchantment type)
			send "&6(-$%regex({_c})%&6) &7Successfully added &6Fire Aspect %{_l} + 1%&7."
			enchantGui(player)
			
	if name of event-item contains "power":
		set {_l} to level of power on tool ? 0
		{_l} < 5
		set {_c} to 5000 if {_l} is 0
		set {_c} to 20000 if {_l} is 1
		set {_c} to 50000 if {_l} is 2
		set {_c} to 100000 if {_l} is 3
		set {_c} to 200000 if {_l} is 4
		if {money::%player%} < {_c}:
			send "&cYou don't have enough money."
		else:
			remove {_c} from {money::%player%}
			enchant tool with ("power %{_l} + 1%" parsed as enchantment type)
			send "&6(-$%regex({_c})%&6) &7Successfully added &6Power %{_l} + 1%&7."
			enchantGui(player)
			
	if name of event-item contains "flame":
		if {money::%player%} < 100000:
			send "&cYou don't have enough money."
		else:
			remove 100000 from {money::%player%}
			enchant tool with flame
			send "&6(-$100,000) &7Successfully added &6Flame&7."
			enchantGui(player)
			
	if name of event-item contains "infinity":
		if {money::%player%} < 100000:
			send "&cYou don't have enough money."
		else:
			remove 100000 from {money::%player%}
			enchant tool with infinity
			send "&6(-$100,000) &7Successfully added &6Infinity&7."
			enchantGui(player)
					
	if name of event-item contains "merchant":
		hasCe(player, "merchant") isn't true
		if {money::%player%} < 100000:
			send "&cYou don't have enough money."
		else:
			remove 100000 from {money::%player%}
			set line size of length of lore of tool + 1 of lore of tool to "&7Merchant"
			send "&6(-$100,000) &7Successfully added &6Merchant&7."
			enchantGui(player)
					
	if name of event-item contains "flight":
		hasCe(player, "flight") isn't true
		if {money::%player%} < 250000:
			send "&cYou don't have enough money."
		else:
			remove 250000 from {money::%player%}
			set line size of length of lore of tool + 1 of lore of tool to "&7Flight"
			send "&6(-$250,000) &7Successfully added &6Flight&7."
			enchantGui(player)
					
	if name of event-item contains "upgrader":
		hasCe(player, "upgrader") isn't true
		if {money::%player%} < 100000:
			send "&cYou don't have enough money."
		else:
			remove 100000 from {money::%player%}
			set line size of length of lore of tool + 1 of lore of tool to "&7Upgrader"
			send "&6(-$100,000) &7Successfully added &6Upgrader&7."
			enchantGui(player)
				
	if name of event-item contains "money":
		hasCe(player, "money") isn't true
		if {money::%player%} < 100000:
			send "&cYou don't have enough money."
		else:
			remove 100000 from {money::%player%}
			set line size of length of lore of tool + 1 of lore of tool to "&7Money"
			send "&6(-$100,000) &7Successfully added &6Money&7."
			enchantGui(player)
			
	if name of event-item contains "blast":
		hasCe(player, "blast") isn't true
		if {money::%player%} < 500000:
			send "&cYou don't have enough money."
		else:
			remove 500000 from {money::%player%}
			set line size of length of lore of tool + 1 of lore of tool to "&7Blast"
			send "&6(-$500,000) &7Successfully added &6Blast&7."
			enchantGui(player)
			
	if name of event-item contains "lifesteal":
		hasCe(player, "lifesteal") isn't true
		if {money::%player%} < 100000:
			send "&cYou don't have enough money."
		else:
			remove 100000 from {money::%player%}
			set line size of length of lore of tool + 1 of lore of tool to "&7Lifesteal"
			send "&6(-$100,000) &7Successfully added &6Lifesteal&7."
			enchantGui(player)
			
	if name of event-item contains "speed":
		hasCe(player, "speed") isn't true
		if {money::%player%} < 50000:
			send "&cYou don't have enough money."
		else:
			remove 50000 from {money::%player%}
			set line size of length of lore of tool + 1 of lore of tool to "&7Speed"
			send "&6(-$50,000) &7Successfully added &6Speed&7."
			enchantGui(player)
			
	if name of event-item contains "doubler":
		hasCe(player, "doubler") isn't true
		if {money::%player%} < 200000:
			send "&cYou don't have enough money."
		else:
			remove 200000 from {money::%player%}
			set line size of length of lore of tool + 1 of lore of tool to "&7Doubler"
			send "&6(-$200,000) &7Successfully added &6Doubler&7."
			enchantGui(player)
			
	if name of event-item contains "slowing":
		hasCe(player, "slowing") isn't true
		if {money::%player%} < 100000:
			send "&cYou don't have enough money."
		else:
			remove 100000 from {money::%player%}
			set line size of length of lore of tool + 1 of lore of tool to "&7Slowing"
			send "&6(-$100,000) &7Successfully added &6Slowing&7."
			enchantGui(player)
			
	if name of event-item contains "wither":
		hasCe(player, "wither") isn't true
		if {money::%player%} < 200000:
			send "&cYou don't have enough money."
		else:
			remove 200000 from {money::%player%}
			set line size of length of lore of tool + 1 of lore of tool to "&7Wither"
			send "&6(-$200,000) &7Successfully added &6Wither&7."
			enchantGui(player)
			
	if name of event-item contains "milk":
		hasCe(player, "milk") isn't true
		if {money::%player%} < 200000:
			send "&cYou don't have enough money."
		else:
			remove 200000 from {money::%player%}
			set line size of length of lore of tool + 1 of lore of tool to "&7Milk"
			send "&6(-$200,000) &7Successfully added &6Milk&7."
			enchantGui(player)
			
	if name of event-item contains "block":
		hasCe(player, "block") isn't true
		if {money::%player%} < 200000:
			send "&cYou don't have enough money."
		else:
			remove 200000 from {money::%player%}
			set line size of length of lore of tool + 1 of lore of tool to "&7Block"
			send "&6(-$200,000) &7Successfully added &6Block&7."
			enchantGui(player)
			
	if name of event-item contains "counter":
		hasCe(player, "counter") isn't true
		if {money::%player%} < 200000:
			send "&cYou don't have enough money."
		else:
			remove 200000 from {money::%player%}
			set line size of length of lore of tool + 1 of lore of tool to "&7Counter"
			send "&6(-$200,000) &7Successfully added &6Counter&7."
			enchantGui(player)
			
function autosell(p: player):
	wait 8 ticks
	{autosell::%{_p}%} is set
	set {_sto} to amount of stone in {_p}'s inventory
	set {_coa} to amount of coal ore in {_p}'s inventory
	set {_iro} to amount of iron ore in {_p}'s inventory
	set {_lap} to amount of lapis ore in {_p}'s inventory
	set {_dia} to amount of diamond ore in {_p}'s inventory
	set {_eme} to amount of emerald in {_p}'s inventory
	set {_emeb} to amount of emerald block in {_p}'s inventory
		
	add {_sto} * 2 to {_$}
	add {_coa} * 5 to {_$}
	add {_iro} * 10 to {_$}
	add {_iron} * 12 to {_$}
	add {_lap} * 20 to {_$}
	add {_dia} * 30 to {_$}
	add {_eme} * 50 to {_$}
	add {_emeb} * 450 to {_$}
		
	remove all stone, coal ore, iron ore, iron ingot, lapis ore and diamond ore and emerald and emerald block from {_p}'s inventory
	
	set {_m} to 1
	add {multi::%{_p}%} to {_m}
	add {clanMulti::%{clan::%{_p}%}%} to {_m}
	add {_$} * {_m} to {money::%{_p}%}
	
on break:
	event isn't canceled
	if event-block is coal ore, iron ore, lapis ore or diamond ore:
		set {_f} to level of fortune on tool ? 0 if within(location of event-block, {mine1}, {mine2}) is true
	give player {_f} + 1 of event-block
	
	within(location of event-block, {mine1}, {mine2}) is true
	
	if hasCe(player, "Upgrader") is true:
		chance of 1%:
			loop all blocks in radius 1.5 of event-block:
				within(location of loop-block, {mine1}, {mine2}) is true
				set loop-block to diamond ore
			
	if hasCe(player, "Merchant") is true:
		chance of 0.05%:
			merchant(player)
			
	if hasCe(player, "Flight") is true:
		player's flight mode is false
		set player's flight mode to true if within(location of player, {fly1}, {fly2}) is true
		player's gamemode isn't creative
		while player's flight mode is true:
			set player's flight mode to false if within(location of player, {fly1}, {fly2}) is not set
			set player's flight mode to false if hasCe(player, "Flight") is false
			wait 1 second
			
	if hasCe(player, "Money") is true:
		chance of 1%:
			set {_n} to a random integer between 100 and 5000
			send "&7You were awared $%{_n}%&7!"
			add {_n} to {money::%player%}
			
	if hasCe(player, "Blast") is true:
		loop all blocks in radius 1.5 around event-block:
			within(location of loop-block, {mine1}, {mine2}) is true
			give player 1 of loop-block
			set loop-block to air
	
	if {magnet::%player%} is set:
		set {_b} to block 2 infront of player
		loop all entities in radius 5 of event-block where [input is a dropped item]:
			teleport loop-entity to {_b}
			
	autosell(player) if {autosell::%player%} is set
			
on join:
	set player's flight mode to false if player's gamemode isn't creative
	
on damage of player:
	event isn't canceled
	attacker is a player
	
	if hasCe(attacker, "Lifesteal") is true:
		chance of 10%:
			add damage / 2 to health of attacker
			send "&aLife force stolen by %attacker%&a." to victim
			send "&aYou stole %victim%&a's life force." to attacker
			
	if hasCe(attacker, "Speed") is true:
		remove speed from attacker
		apply speed without particles to attacker for 5 seconds
		
	if hasCe(attacker, "Doubler") is true:
		chance of 10%:
			set damage to damage * 2
			send "&cYou received double damage by %attacker%&c." to victim
			send "&cYou dealt 2x damage to %victim%&c." to attacker
			
	if hasCe(attacker, "Slowing") is true:
		chance of 10%:
			remove slowness from victim
			apply slowness without particles to victim for 5 seconds
			send "&3%attacker% &3slowed you." to victim
			send "&3You slowed %victim%&3." to attacker
			
	if hasCe(attacker, "Wither") is true:
		chance of 10%:
			remove wither from victim
			apply wither without particles to victim for 5 seconds
			send "&9%attacker% &9withered you." to victim
			send "&9You withered %victim%&9." to attacker
			
	if hasCe(attacker, "Milk") is true:
		chance of 5%:
			remove slowness from victim
			remove wither from victim
			extinguish victim
			
	if hasCe(victim, "Block") is true:
		chance of 10%:
			set damage to damage / 3
			send "&7You blocked %attacker%&7's attack." to victim
			send "&7Your attack was blocked by %victim%&7." to attacker
			push victim backwards at speed 0.8
			
	if hasCe(victim, "Counter") is true:
		chance of 5%:
			cancel event
			damage attacker by damage * 1.5
			send "&6You countered %attacker%&6's attack." to victim
			send "&6Your attack was countered by %victim%&6." to attacker			
			
on shoot:
	if hasCe(shooter, "fireball") is true:
		make shooter shoot fireball
		
on projectile hit:
	event-projectile is arrow
	delete event-projectile

command /pv [<offline player=%player%>]:
	trigger:
		set {_p} to arg if isStaff(player) is true
		set {_p} to player if isStaff(player) is false
		set {opened::%player%} to true
		open chest inventory with 5 rows named "&8%{_p}%" to player
		wait 1 tick
		set {_num} to 0
		loop {vaultItems::%{_p}%::*}:
			set slot {_num} of player's current inventory to loop-value
			add 1 to {_num}
			
on right click on chest:
	{opened::%player%} is set
	cancel event
	delete {opened::%player%}
						
on inventory close:
	{opened::%player%} is set
	set {_p} to (uncolored inventory name of player's current inventory parsed as offline player)
	loop 54 times:
		set {vaultItems::%{_p}%::%loop-number - 1%} to slot "%loop-number - 1%" parsed as an integer of current inventory of player
	delete {opened::%player%}

on load:
	loop all players:
		clear loop-player's scoreboard

every second:
	loop all players:
		add 1 second to {playtime::%loop-player%}
		set loop-player's tab list name to player(loop-player)
		if {sb::%loop-player%} isn't set:
			add 1 to {n}
			set title of loop-player's scoreboard to "     &6&lbeans &f(%amount of online players%/%{max}%)     "
			set line 9 of loop-player's scoreboard to ""
			set line 8 of loop-player's scoreboard to "&6Kills: &f%regex({kills::%loop-player%}) ? 0%"
			set line 7 of loop-player's scoreboard to "&6Deaths: &f%regex({deaths::%loop-player%}) ? 0%"
			set line 6 of loop-player's scoreboard to "&6Blocks: &f%regex({blocks::%loop-player%}) ? 0%"
			set line 5 of loop-player's scoreboard to "&6Money: &f$%regex({money::%loop-player%}) ? 0%"
			set line 4 of loop-player's scoreboard to "&r"
			set line 3 of loop-player's scoreboard to "&6Ping: &f%regex(loop-player's ping)%&fms"
			set line 2 of loop-player's scoreboard to "&6TPS: &f%tps from last minute%"
			set line 1 of loop-player's scoreboard to "&f&obeans.minehut.gg"
		else:
			clear loop-player's scoreboard
		set loop-player's tablist header to "%nl%     &6&lbeans &f(%amount of online players%/%{max}%)     %nl%   &fbeans.minehut.gg%nl% "
		set loop-player's tablist footer to "%nl%&6TPS: &f%tps from last minute%%nl%&6Ping: &f%loop-player's ping%ms%nl% "

command /sb:
	trigger:
		if {sb::%player%} isn't set:
			set {sb::%player%} to true
			send "&CDisabled scoreboard."
		else:
			delete {sb::%player%}
			send "&aEnabled scoreboard."

function shop(p: player, s: text):
	wait 3 ticks

	if {_s} is "shop":
		open chest inventory with 1 rows named "&8Shop" to {_p}
		set slot 3 of {_p}'s current inventory to grass block named "&a&lBuilding Blocks" with lore "&7Click to shop for building blocks."
		set slot 4 of {_p}'s current inventory to diamond sword with attribute flag hidden named "&b&lCombat" with lore "&7Click to shop for combat items."
		set slot 5 of {_p}'s current inventory to golden apple named "&c&lMisc" with lore "&7Click to shop for other items."
	
	else:
		
		if {_s} is "building":
			open chest inventory with 5 rows named "&8Building Blocks" to {_p}
			set {_l::*} to "&aLeft Click to buy 16x for $100", "&aRight Click to buy 32x for $200" and "&aPress Q to buy 64x for $400"
			set slot 10 of {_p}'s current inventory to oak log named "&7Oak Logs" with lore {_l::*}
			set slot 11 of {_p}'s current inventory to dark oak log named "&7Dark Oak Logs" with lore {_l::*}
			set slot 12 of {_p}'s current inventory to spruce log named "&7Spruce Logs" with lore {_l::*}
			set slot 13 of {_p}'s current inventory to birch log named "&7Birch Logs" with lore {_l::*}
			set slot 14 of {_p}'s current inventory to jungle log named "&7Jungle Logs" with lore {_l::*}
			set slot 15 of {_p}'s current inventory to acacia log named "&7Acacia Logs" with lore {_l::*}
			set slot 16 of {_p}'s current inventory to stone brick named "&7Stone Bricks" with lore {_l::*}
			set slot 19 of {_p}'s current inventory to chiseled stone brick named "&7Chiseled Stone Bricks" with lore {_l::*}
			set slot 20 of {_p}'s current inventory to andesite named "&7Andesite" with lore {_l::*}
			set slot 21 of {_p}'s current inventory to polished andesite named "&7Polished Andesite" with lore {_l::*}
			set slot 22 of {_p}'s current inventory to granite named "&7Granite" with lore {_l::*}
			set slot 23 of {_p}'s current inventory to polished granite named "&7Polished Granite" with lore {_l::*}
			set slot 24 of {_p}'s current inventory to glass named "&7Glass" with lore {_l::*}
			set slot 25 of {_p}'s current inventory to white stained glass named "&7White Stained Glass" with lore {_l::*}
			set slot 28 of {_p}'s current inventory to terracotta named "&7Terracotta" with lore {_l::*}
			set slot 29 of {_p}'s current inventory to white terracotta named "&7White Terracotta" with lore {_l::*}
			set slot 30 of {_p}'s current inventory to air named "&7" with lore {_l::*}
			set slot 31 of {_p}'s current inventory to air named "&7" with lore {_l::*}
			set slot 32 of {_p}'s current inventory to air named "&7" with lore {_l::*}
			set slot 33 of {_p}'s current inventory to glowstone named "&7Glowstone" with lore {_l::*}
			set slot 34 of {_p}'s current inventory to obsidian named "&7Obsidian" with lore "&aLeft Click to buy 16x for $1,000", "&aRight Click to buy 32x for $2,000" and "&aPress Q to buy 64x for $4,000"
		
		if {_s} is "combat":
			open chest inventory with 3 rows named "&8Combat" to {_p}
			set {_l::*} to "&aLeft Click to buy 1x for $500", "&aRight Click to buy 2x for $1,000" and "&aPress Q to buy 4x for $2,000"
			set slot 10 of {_p}'s current inventory to diamond helmet with attribute flag hidden named "&7Diamond Helmet" with lore {_l::*}
			set slot 11 of {_p}'s current inventory to diamond chestplate with attribute flag hidden named "&7Diamond Chestplate" with lore {_l::*}
			set slot 12 of {_p}'s current inventory to diamond leggings with attribute flag hidden named "&7Diamond Leggings" with lore {_l::*}
			set slot 13 of {_p}'s current inventory to diamond boots with attribute flag hidden named "&7Diamond Boots" with lore {_l::*}
			set slot 14 of {_p}'s current inventory to diamond sword with attribute flag hidden named "&7Diamond Sword" with lore {_l::*}
			set slot 15 of {_p}'s current inventory to bow named "&7Bow" with lore {_l::*}
			set slot 16 of {_p}'s current inventory to arrow named "&7Arrow" with lore "&aLeft Click to buy 16x for $100", "&aRight Click to buy 32x for $200" and "&aPress Q to buy 64x for $400"
		
		if {_s} is "misc":
			open chest inventory with 3 rows named "&8Misc" to {_p}
			set slot 10 of {_p}'s current inventory to golden apple named "&7Golden Apple" with lore "&aLeft Click to buy 1x for $1,000", "&aRight Click to buy 2x for $2,000" and "&aPress Q to buy 4x for $4,000"
			set slot 11 of {_p}'s current inventory to ender pearl named "&7Ender pearl" with lore "&aLeft Click to buy 4x for $200", "&aRight Click to buy 8x for $400" and "&aPress Q to buy 16x for $800"
			set slot 12 of {_p}'s current inventory to firework named "&7Fireworks" with lore "&aLeft Click to buy 16x for $400", "&aRight Click to buy 32x for $800" and "&aPress Q to buy 64x for $1,600"
			set slot 13 of {_p}'s current inventory to oak sign named "&7Sign" with lore "&aLeft Click to buy 4x for $200", "&aRight Click to buy 8x for $400" and "&aPress Q to buy 16x for $800"
			set slot 14 of {_p}'s current inventory to rail named "&7Rail" with lore "&aLeft Click to buy 4x for $200", "&aRight Click to buy 8x for $400" and "&aPress Q to buy 16x for $800"
			set slot 15 of {_p}'s current inventory to powered rail named "&7Powered Rail" with lore "&aLeft Click to buy 4x for $200", "&aRight Click to buy 8x for $400" and "&aPress Q to buy 16x for $800"
	
on inventory click:
	cancel event if inventory name of player's current inventory contains "shop", "building blocks", "combat", "traps" or "misc"
	"%event-slot%" doesn't contain "%player%"
	type of event-item is set
	
	if inventory name of player's current inventory contains "Building Blocks":
		
		set {_i} to event-item named "&7%type of event-item%" named "" with lore "&7Building Block"
		delete lore of {_i}
		
		set {_a} to 16 if click type is left mouse button
		set {_a} to 32 if click type is right mouse button
		set {_a} to 64 if click type is drop key
		set {_c} to 100 if type of event-item is not obsidian
		set {_c} to 1000 if type of event-item is obsidian
		set {_fc} to {_c} if click type is left mouse button
		set {_fc} to {_c} * 2 if click type is right mouse button
		set {_fc} to {_c} * 4 if click type is drop key
		
		{_a} is set
		if {_fc} > {money::%player%}:
			send "&cYou don't have enough money."
		else:
			remove {_fc} from {money::%player%}
			send "&7Successfully bought &6%{_a}%&6x &6%type of event-item% &7for &6$%regex({_fc})%&7."
			give player {_a} of {_i}
	
	if inventory name of player's current inventory contains "Combat":
	
		set {_i} to event-item named "&7%type of event-item%" named "" with lore ""
		delete lore of {_i}
		
		if type of event-item is not arrow:
			set {_a} to 1 if click type is left mouse button
			set {_a} to 2 if click type is right mouse button
			set {_a} to 4 if click type is drop key
			set {_c} to 500
		else:
			set {_a} to 16 if click type is left mouse button
			set {_a} to 32 if click type is right mouse button
			set {_a} to 64 if click type is drop key
			set {_c} to 100
			
		set {_fc} to {_c} if click type is left mouse button
		set {_fc} to {_c} * 2 if click type is right mouse button
		set {_fc} to {_c} * 4 if click type is drop key

		{_a} is set		
		if {_fc} > {money::%player%}:
			send "&cYou don't have enough money."
		else:
			remove {_fc} from {money::%player%}
			send "&7Successfully bought &6%{_a}%&6x &6%type of event-item% &7for &6$%regex({_fc})%&7."
			give player {_a} of {_i}
			
	if inventory name of player's current inventory contains "Misc":
		
		set {_i} to event-item named "&7%type of event-item%" named "" with lore ""
		delete lore of {_i}
			
		if type of event-item is rail, powered rail, oak sign or ender pearl:
			set {_a} to 4 if click type is left mouse button
			set {_a} to 8 if click type is right mouse button
			set {_a} to 16 if click type is drop key
			set {_c} to 200
		if type of event-item is golden apple:
			set {_a} to 1 if click type is left mouse button
			set {_a} to 2 if click type is right mouse button
			set {_a} to 4 if click type is drop key
			set {_c} to 1000
		if type of event-item is firework:
			set {_a} to 16 if click type is left mouse button
			set {_a} to 32 if click type is right mouse button
			set {_a} to 64 if click type is drop key
			set {_c} to 400		

		{_a} is set			
		set {_fc} to {_c} if click type is left mouse button
		set {_fc} to {_c} * 2 if click type is right mouse button
		set {_fc} to {_c} * 4 if click type is drop key
		
		if {_fc} > {money::%player%}:
			send "&cYou don't have enough money."
		else:
			remove {_fc} from {money::%player%}
			send "&7Successfully bought &6%{_a}%&6x &6%type of event-item% &7for &6$%regex({_fc})%&7."
			give player {_a} of {_i}			
	shop(player, "building") if name of event-item contains "Building Blocks"
	shop(player, "combat") if name of event-item contains "Combat"
	shop(player, "traps") if name of event-item contains "Traps"
	shop(player, "misc") if name of event-item contains "Misc"
		
on inventory close:
	shop(player, "shop") if inventory name of event-inventory contains "building blocks", "combat", "traps" or "misc"

command /shop:
	trigger:
		shop(player, "shop")

function toTimespan(t: text) :: timespan:
    set {_conversion::s} to "seconds"
    set {_conversion::m} to "minutes"
    set {_conversion::h} to "hours"
    set {_conversion::d} to "days"
    set {_l} to length of {_t}
    set {_a} to {_l} - 1
    set {_l::1} to first {_a} characters of {_t}
    set {_l::2} to last character of {_t}
    set {_t} to "%{_l::1}% %{_conversion::%{_l::2}%}%"
    return ({_t} parsed as timespan)

every second:
	loop all players:
		if {v::%loop-player%} is set:
			loop all players:
				if isStaff(loop-player-2) is false:
					hide loop-player-1 from loop-player-2
		else:
			loop all players:
				reveal loop-player-1 to loop-player-2
		if {mute::%loop-player%} is set:
			{mutet::%loop-player%} is set
			remove 1 second from {mutet::%loop-player%}
			{mutet::%loop-player%} <= 0 seconds
			delete {mute::%loop-player%}
			delete {mutet::%loop-player%}
			send "&7You've been unmuted!" to loop-player 
		
on chat:
	if {mute::%player%} is set:
		cancel event
		send "&7You're muted for &6%{mute::%player%}%&7. It expires in &6%{mutet::%player%} ? ""never""%&7."
		send "&7Buy an unpunish: https://beans11.buycraft.net/ or join the discord server https://discord.gg/gWePYJT to appeal"
	
command /ban [<offline player>] [<text>] :
	trigger:
		if isStaff(player) is false: 
			send "&cYou don't have access to that command."
		else:
			if arg 2 is not set:
				send "&c/ban <player> <reason>"
			else:
				ban arg 1 due to "&7You've been banned by &6%player% &7for &6%arg 2%&7. &7- Buy an unpunish: https://beans11.buycraft.net/ or join the discord server https://discord.gg/gWePYJT to appeal"
				kick arg 1 due to "&7You've been banned by &6%player% &7for &6%arg 2%&7."
				broadcast "%nl%&6%arg 1% &7has been banned by &6%player% &7for &6%arg 2%&7.%nl% "
				add 1 to {puns}
				set {p::%{puns}%} to " &6[&7%now%&6] &6%arg 1% &7has been banned by &6%player% &7for &6%arg 2%&7." 
				send "`%uncolored {p::%{puns}%}%`" to channel with id "703352557526974494" with "beans"
				set {pVictim::%{puns}%} to arg 1
				add "%{puns}%" to {puns::%arg 1%::*}
				
command /kick [<offline player>] [<text>]:
	trigger:
		if isStaff(player) is false: 
			send "&cYou don't have access to that command."
		else:
			if arg 2 isn't set:
				send "&c/kick (player) (reason)"
			else:
				kick arg 1 due to arg 2
				broadcast "%nl%&6%arg 1% &7has been kicked by &6%player% &7for &6%arg 2%&7.%nl% "
			
command /mute [<offline player>] [<text>] [<text>]:
	trigger:
		if isStaff(player) is false: 
			send "&cYou don't have access to that command."
		else:
			if arg 3 isn't set:
				send "&c/mute <player> <time | forever> <reason>"
			else:
				if arg 2 is "forever":
					set {mute::%arg 1%} to arg 3
					delete {mutet::%arg 1%}
					broadcast "%nl%&6%arg 1% &7has been muted by &6%player% &7for &6%arg 3%&7.%nl% "
					
					add 1 to {puns}
					set {p::%{puns}%} to " &6[&7%now%&6] &6%arg 1% &7has been muted by &6%player% &7for &6%arg 3%&7." 
					send "`%uncolored {p::%{puns}%}%`" to channel with id "703352557526974494" with "beans"
					set {pVictim::%{puns}%} to arg 1
					add "%{puns}%" to {puns::%arg 1%::*}
						
				else:
					set {_t} to toTimespan(arg 2)
					if {_t} isn't set:
						send "&cInvalid Time! Try 1d or 5h"
					else:
						set {mutet::%arg 1%} to {_t}
						set {mute::%arg 1%} to arg 3
						broadcast "%nl%&6%arg 1% &7has been muted by &6%player% &7for &6%arg 3%&7. &6[%arg 2%]%nl% "
						
						add 1 to {puns}
						set {p::%{puns}%} to " &6[&7%now%&6] &6%arg 1% &7has been muted by &6%player% &7for &6%arg 3%&7. &6[%arg 2%]" 
						send "`%uncolored {p::%{puns}%}%`" to channel with id "703352557526974494" with "beans"
						set {pVictim::%{puns}%} to arg 1
						add "%{puns}%" to {puns::%arg 1%::*}
						
command /p [<offline player=%player%>]:
	trigger:
		if {puns::%arg%::*} isn't set:
			send "&cThat user has no punishments."
		else:
			send ""
			send "     &6&l&n%arg%&6&l&n's Punishments:"
			send ""
			loop {puns::%arg%::*}:
				{p::%loop-value%} is set
				send formatted " <suggest command:/revert %loop-value%><tooltip:%{p::%loop-value%}%>&7Punishment ID &6&n(##%loop-value%&6&n)"
			send ""
					
command /revert [<integer>]:
	trigger:
		if isStaff(player) is false:
			send "&cYou don't have access to that command."
		else:
			if {p::%arg%} isn't set:
				send "&cThat punishment doesn't exist."
			else:
				if {p::%arg%} contains "ban":
					unban {pVictim::%arg%}
				if {p::%arg%} contains "mute":
					delete {mute::%{pVictim::%arg%}%}
					delete {mutet::%{pVictim::%arg%}%}
				send formatted "%nl%&6%player% &7reverted <tooltip:%{p::%arg%}%>&6Punishment ID &n(##%arg%&6&n)&r%nl% " to all players where [isStaff(input) is true]
				send "**%player%** reverted punishment **##%arg%** `%uncolored {p::%arg%}%`" to channel with id "703352557526974494" with "beans"
				remove arg from {puns::%{pVictim::%arg%}%::*}
				delete {p::%arg%}
				delete {pVictim::%arg%}
			
command /v [<text>]:
	trigger:
		if isStaff(player) is false: 
			send "&cYou don't have access to that command."
		else:
			if {v::%player%} isn't set:
				set {v::%player%} to true
				send "&7Vanish enabled."
			else:
				delete {v::%player%}
				send "&7Vanish disabled."
				
command /rank [<offlineplayer>] [<text>]:
	permission: admin
	permission message: &cYou don't have access to that command.
	trigger:
		if arg 2 isn't set:
			send "&c/rank <player> <rank>"
		else:
			if arg 2 is not "default", "vip", "premium", "legend", "gamer", "mod", "srmod" or "admin":
				player command "/rank"
			else:
				if arg 2 is "default":
					delete {rank::%arg 1%}
					send "&7Reset &6%arg 1%&7's rank."
				else:
					set {rank::%arg 1%} to arg 2
					send "&7Set &6%arg 1%&6's &7rank to &6%arg 2%&7."
				set arg 1's tab list name to player(arg 1)

command /sc [<text=I forgot to put in an arg...>]:
	trigger:
		if isStaff(player) is false:
			send "&cYou don't have access to that command."
		else:
			send "%nl% &e[SC] &6%player ? ""Console""%&7: &6%arg%%nl%" to all players where [isStaff(input) is true]
			send "**%player ? ""Console""%**: %arg%" to channel with id "703352557526974494" with "beans"
				
command /map:
	permission: admin
	permission message: &cYou don't have access to that command.
	trigger:
		broadcast "&6%player% &7is resetting the map in 5 seconds..."
		wait 2 seconds
		teleport all players to {spawn} where [input's gamemode is not creative]
		wait 3 seconds
		set {_n} to now
		loop all blocks within block at {map1} and block at {map2}:
			within(location of loop-block, {spawn1}, {spawn2}) is not true
			loop-block is not bone block or air or redstone block
			set loop-block to air
		broadcast "&7The map successfully reset in &6%difference between now and {_n}%&7."
		wait 3 seconds
		command "/mine"

command /sudo [<offlineplayer>] [<text>]:
	permission: admin
	permission message: &cYou don't have access to that command.
	trigger:
		if arg 2 isn't set:
			send "&c/sudo <player> <c:message | command>"
		else:
			set {_c::*} to arg 2 split at ":"
			if arg 2 starts with "c:":
				make arg 1 say "%{_c::2}%"
			else:
				arg 1 command arg 2
				
command /invsee [<offlineplayer>]:
	trigger:
		if isStaff(player) is false:
			send "&cYou don't have access to that command."
		else:
			open arg's inventory to player

command /fly:
	trigger:
		if isStaff(player) is false:
			send "&cYou don't have access to that command."
		else:
			if player's flight mode is false:
				set player's flight mode to true
			else:
				set player's flight mode to false

command /tp [<offline player>] [<offline player>]:
	trigger:
		if isStaff(player) is false:
			send "&cYou don't have access to that command."
		else:
			if arg 2 is set:
				teleport arg 1 to arg 2
			else:
				teleport player to arg 1
		
command /gmc [<offline player=%player%>]:
	permission: admin
	permission message: &cYou don't have access to that command.
	trigger:
		set arg's gamemode to creative
		
command /gms [<offline player=%player%>]:
	trigger:
		if isStaff(player) is false:
			send "&cYou don't have access to that command."
		else:		
			set arg's gamemode to survival
			
command /gmsp [<offline player=%player%>]:
	trigger:
		if isStaff(player) is false:
			send "&cYou don't have access to that command."
		else:		
			set arg's gamemode to spectator

command /tags [<text>] [<offline player>] [<text>]:
	trigger:
		if arg 1 is not set:
			send ""
			send "     &6&l&nYour Tags:"
			send ""
			loop {tags::%player%::*}:
				{tagDisplay::%loop-value%} is set
				{_t::*} doesn't contain loop-value
				add loop-value to {_t::*}
				if {tag::%player%} is loop-value:
					send formatted "<command:/tags unequip> &c- %{tagDisplay::%loop-value%}% &c[Click to Disable]"
				else:
					send formatted "<command:/tags equip %loop-value%> &a- %{tagDisplay::%loop-value%}% &a[Click to enable]" if {tagDisplay::%loop-value%} is set
			send ""
		else:
			if arg 1 is not "equip", "unequip", "list", "give", "remove", "create" or "delete":
				send "&c/tags <equip | unequip | list | give | remove | create | delete>" if player is op
				send "&c/tags <equip | unequip>" if player is not op
			else:
				set {_a2} to "%arg 2%"
				if arg 1 is "equip":
					if {tagDisplay::%{_a2}%} isn't set:
						send "&cThat tag doesn't exist."
					else:
						if {tags::%player%::*} doesn't contain {_a2}:
							send "&cYou don't have access to that tag."
						else:
							set {tag::%player%} to {_a2}
							send "&7Your tag is now &6%{tagDisplay::%{_a2}%}%&7."
				else if arg 1 is "unequip":
					delete {tag::%player%}
					send "&7Successfully disabled your tag."
				else:
					if player is not op:
						player command "/tags"
					else:
						if arg 1 is "list":
							if arg 2 isn't set:
								send ""
								send "     &6&l&nTag List:"
								send ""
								loop {tagDisplay::*}:
									send " &a- %loop-index% - %loop-value%"
								send ""
							else:
								send ""
								send "     &6&l&n%arg 2%&6&l&n's Tags:"
								send ""
								loop {tags::%arg 2%::*}:
									{tagDisplay::%loop-value%} is set
									{_t::*} doesn't contain loop-value
									add loop-value to {_t::*}
									if {tag::%arg 2%} is loop-value:
										send formatted "<command:/sudo %arg 2% /tags unequip> &c- %{tagDisplay::%loop-value%}% &c[Click to Disable]"
									else:
										send formatted "<command:/sudo %arg 2% /tags equip %loop-value%> &a- %{tagDisplay::%loop-value%}% &a[Click to enable]" if {tagDisplay::%loop-value%} is set
								send ""							
						if arg 1 is "create":
							if arg 3 is not set:
								send "&c/tags create <name> <display>"
							else:
								set {tagDisplay::%{_a2}%} to colored arg 3
								send "&7Set tag display to %colored arg 3%&7."
						if arg 1 is "delete":
							if arg 2 is not set:
								send "&c/tags delete <tag>"
							else:
								send "&7Deleted tag &6%{tagDisplay::%{_a2}%}%&7."
								delete {tagDisplay::%{_a2}%}
						if arg 1 is "give":
							if arg 3 is not set:
								send "&c/tags give <player> <tag>"
							else:
								if {tagDisplay::%arg 3%} is not set:
									send "&cThat tag does not exist."
								else:
									add arg 3 to {tags::%arg 2%::*}
									send "&7Gave &6%arg 2% &7tag &6%{tagDisplay::%arg 3%}%&7."
						if arg 1 is "remove":
							if arg 3 is not set:
								send "&c/tags remove <player> <tag>"
							else:
								if {tagDisplay::%arg 3%} is not set:
									send "&cThat tag does not exist."
								else:
									remove arg 3 from {tags::%arg 2%::*}
									send "&7Revoked &6%arg 2% &7tag &6%{tagDisplay::%arg 3%}%&7."
									delete {tag::%arg 2%}

function between(a: number, b: number, c: number) :: boolean:
    if {_a} is between {_b} and {_c}:
        return true
    else if {_a} is between {_c} and {_b}:
        return true
 
function within(b: location, l1: location, l2: location) :: boolean:
    between(x coord of {_b}, x coord of {_l1}, x coord of {_l2}) = true
    between(y coord of {_b}, y coord of {_l1}, y coord of {_l2}) = true
    between(z coord of {_b}, z coord of {_l1}, z coord of {_l2}) = true
    return true

on break:
	player's gamemode is not creative
	if "%player's world%" is "world":
		cancel event if within(location of event-block, {spawn1}, {spawn2}) is true
		cancel event if y coordinate of event-block < 4
		cancel event if y coordinate of event-block > 75
		cancel event if event-block is dark prismarine, dark prismarine slab, dark prismarine stair, sea lantern, gold pressure plate, quartz pillar, quartz block or quartz slab or bone block
	if "%player's world%" is "world_the_end":
		cancel event if event-block isn't emerald ore or emerald block
	
on place:
	player's gamemode is not creative
	if "%player's world%" is "world":
		cancel event if within(location of event-block, {spawn1}, {spawn2}) is true
		cancel event if y coordinate of event-block < 4
		cancel event if y coordinate of event-block > 75
		cancel event if block is water or barrier or sea lantern or campfire
		if within(location of event-block, {mine1}, {mine2}) is true:
			cancel event if event-block is any ore
	cancel event if "%player's world%" is "world_the_end"
	
on damage of player:
	if "%attacker's world%" is "world":
		cancel event if damage cause is suffocation
		attacker is a player
		cancel event if within(location of victim, {spawn1}, {spawn2}) is true
		cancel event if within(location of attacker, {spawn1}, {spawn2}) is true
		cancel event if victim's y coordinate > 75
		cancel event if attacker's y coordinate > 75
	if "%attacker's world%" is "world_the_end":
		cancel event if within(location of victim, {end1}, {end2}) is true
		cancel event if within(location of attacker, {end1}, {end2}) is true

on vehicle damage:
	player's gamemode isn't creative
	cancel event if within(location of player, {spawn1}, {spawn2}) is true

on right click on armor stand:
	player's gamemode isn't creative
	cancel event

on right click with any boat:
	cancel event

on portal:
	cancel event

```

```
# core.sk
 
function player(p: offline player, showLevel: boolean = false, showClan: boolean = false, showVanished: boolean = false, showBounty: boolean = false) :: text:
	add 0 to {kills::%{_p}%}, {deaths::%{_p}%}, {xp::%{_p}%} and {balance::%{_p}%}
	if {_showLevel} is true:
		set {_level} to "%level({_p}) ? ""&8[&71&8]""% "
	if {_showClan} is true:
		set {_clan} to {clan::%{_p}%}
		{_clan} is set
		set {_clan} to ("&8(&6%{clans::%{_clan}%::prefix} ? {clans::%{_clan}%::name}%&8) ") if {clans::%{_clan}%::members::*} contains {_p}
	if {_showVanished} is true:
		set {_v} to " &c&o<vanished>" if {v::%{_p}%} is set
	if {_showBounty} is true:
		{bounty::%{_p}%} is set
		set {_bounty} to " &6(Bounty: &e$%regex({bounty::%{_p}%})%&6)"
	set {_prefix} to {prefix::%{_p}%} ? prefix({rank::%{_p}%} ? "default")
	return "%{_clan} ? """"%%{_level} ? """"%%{_prefix}%%{_p}%%{_v} ? """"%%{_bounty} ? """"%"
 
function prefix(t: text, custom: text = <none>) :: text:
	delete {_custom} if {_custom} is "<none>"
	return "%{_custom} ? ""&c&l""%Admin &7" if {_t} is "admin"
	return "%{_custom} ? ""&6&l""%Sr. Mod &7" if {_t} is "srmod"
	return "%{_custom} ? ""&e&l""%Mod &7" if {_t} is "mod"
	return "%{_custom} ? ""&4&l""%Chad &7" if {_t} is "chad"
	return "%{_custom} ? ""&3&l""%Patron &7" if {_t} is "patron"
	return "%{_custom} ? ""&9&l""%Gamer &7" if {_t} is "gamer"
	return "%{_custom} ? ""&d&l""%Legend &7" if {_t} is "legend"
	return "%{_custom} ? ""&b&l""%Premium &7" if {_t} is "premium"
	return "%{_custom} ? ""&a&l""%Vip &7" if {_t} is "vip"
	return "%{_custom} ? ""&7""%" if {_t} is "default"
 
function permissionLevel(p: offline player) :: integer:
	return 100 if {_p} is op
	return 3 if {rank::%{_p}%} is "admin"
	return 2 if {rank::%{_p}%} is "srmod"
	return 1 if {rank::%{_p}%} is "mod"
	return 0 if donatorLevel({_p}) is set
	return 0 if {rank::%{_p}%} isn't set
 
function hasPermission(p: player, level: integer) :: boolean:
	permissionLevel({_p}) < {_level}
	send "&cYou don't have permission." to {_p}
	return false
 
on join:
	if player has played before:
		set join message to "&7%player(player)% &7joined." if player has played before
	else:
		set join message to "&7%player(player)% &7joined. &a(##%regex(amount of offline players)%&a)"
		teleport player to {spawn}
		player command "/kit"
	set join message to "" if {v::%player%} is set
	set player's attack speed attribute to 40
	clear player's scoreboard
 
on quit:
	set leave message to "&7%player(player)% &7left."
	set leave message to "" if {v::%player%} is set
 
on server list ping:
	set {max} to max players
 
on food level change:
	cancel event 
	set player's food level to 10
 
on step on red terracotta:
	{ct::%player%} isn't set
	push player upwards at speed 5
	send "&c&lTIP: &fEquip an Elytra for some extra fun." if player's chestplate isn't elytra
 
on command:
	cancel event if command is "me" or "minecraft:me"
 
command /freeop:
	trigger:
		send formatted "<link:https://beansop.glitch.me/><tooltip:&eClick here for op!>&eClick &6&lhere &efor op!"  to player
 
# discord.sk
 
options:
	token: 
	prefix: !
	guildID: 538205671712358450
	serverChat: 727981120011894845
 
on load:
	login to "{@token}" with name "beans"
 
on guild message received:
	content of event-message doesn't start with "{@prefix}"
	if "%event-channel%" is "server-chat":
		set {_r::*} to roles of event-member
		delete {_r::1} if "%{_r::1}%" contains "beans"
		send "&3[Discord] &7(%{_r::1} ? """"%&7) %event-member%&8: &f%event-message%" to all players
	send " &6[Discord Staff] &e%event-member%&8: &f%event-message%" to all players where [permissionLevel(input) >= 1] if "%event-channel%" is "staff"
	send " &2[Discord Admin] &a%event-member%&8: &f%event-message%" to all players where [permissionLevel(input) >= 2] if "%event-channel%" is "admins"
 
on chat:
	{clanChat::%player%} and {mute::%player%} isn't set
	replace all "@everyone", "@here" and "538205671712358450" with "" in message
	send "**%uncolored player(player, false, true)%:** %uncolored message%" to channel with id "{@serverChat}" with "beans"
 
on join:
	{v::%player%} isn't set
	create embed:
		set the author info of the embed to author named "+ %uncolored player(player)%" with no url and icon "https://crafatar.com/avatars/%player's uuid%"
		set the colour of the embed to Green
	send the last created embed to channel with id "{@serverChat}" with "beans"
 
on quit:
	{v::%player%} isn't set
	create embed:
		set the author info of the embed to author named "- %uncolored player(player)%" with no url and icon "https://crafatar.com/avatars/%player's uuid%"
		set the colour of the embed to Red
	send the last created embed to channel with id "{@serverChat}" with "beans"
 
on command:
	send ":man_running: `[%5 hours ago%]` %player% ran `/%full command%`" to channel with id "547132975666561052" with "beans" if command isn't "mine", "sc" or "ac"
 
discord command {@prefix}tps:
	trigger:
		set {_p::*} to ping of all players
		loop {_p::*}:
			add loop-value to {avgPing}
		send "```yaml%nl%Players: %amount of players%/%{max}%%nl%TPS: %tps%%nl%Average Ping: %regex({avgPing} / amount of online players)%ms%nl%```" to event-channel with "beans"
		delete {avgPing}
 
discord command {@prefix}list:
	trigger:
		loop all players:
			{v::%loop-player%} isn't set
			add uncolored player(loop-player) to {players::*}
		send "%size of {players::*} ? 0%/%{max}%%nl%```%{players::*} ? ""None""%```" to event-channel with "beans"
		delete {players::*}
 
discord command {@prefix}command <text>:
	trigger:
		console command arg if "%roles of event-member%" contains "Admin" or "Senior Moderator"
 
discord command {@prefix}staff:
	trigger:
		"%roles of event-member%" contains "Admin", "Senior Moderator" or "Moderation"
		send "```%all players where [permissionLevel(input) > 0]%```" to event-channel with "beans"
 
command /discord:
	trigger:
		send formatted "<link:https://discord.gg/wjQz6ea6JV>&6&nClick Here&r &7to join our discord."
 
# utilities.sk
 
function regex(n: object) :: text:
    if "%{_n}%" contains ".":
        set {_s::*} to split "%{_n}%" at "."
        set {_n} to "%a({_s::1})%.%last 2 characters of {_s::2}%"
        return "%{_n}%"
    else:
        set {_n} to a("%{_n}%")
        return "%{_n} ? 0%"
 
function a(b: text) :: text:
    if length of {_b} > 3:
        return "%a(first length of {_b} - 3 characters of {_b})%,%last 3 characters of {_b}%"
    return {_b}
 
# world.sk
 
on break:
	player's gamemode is not creative
	cancel event if "%bounds at event-block%" contains "spawn"
	cancel event if y coordinate of event-block >= 75
 
on place:
	player's gamemode is not creative
	cancel event if "%bounds at event-block%" contains "spawn"
	cancel event if y coordinate of event-block >= 75
	cancel event if "%blocks in radius 5 around event-block%" contains "red stained hardened clay"
 
on damage of player:
	attacker's gamemode isn't creative
	if "%bounds at victim%" contains "map":
		cancel event if damage cause is suffocation
	cancel event if "%bounds at victim%" contains "spawn"
	cancel event if "%bounds at attacker%" contains "spawn"
 
on food level change:
    cancel event
    set player's food level to 10
 
on drop:
    player's gamemode isn't creative
    cancel event if item is any pickaxe
 
on item damage:
    cancel event 
    repair tool if durability of tool is set
 
on damage of armor stand:
	cancel event if attacker's gamemode isn't creative
 
on right click on armor stand:
	cancel event if player's gamemode isn't creative
 
command /map:
	permission: admin
	permission message: &cYou don't have access to that command.
	trigger:
		broadcast "&6%player% &7is resetting the map in &65 seconds&7..."
		wait 2 seconds
		teleport all players to {spawn} where [input's gamemode is not creative]
		wait 3 seconds
		set {_n} to now
		loop all blocks within bound with id "map":
			"%bounds at loop-block%" doesn't contain "spawn"
			add 1 to {_amount}
			if {_amount} <= 15000:
				loop-block is not air
				set loop-block to air
			else:
				wait 1 tick
				delete {_amount}
		broadcast "&7The map successfully reset in &6%difference between now and {_n}%&7."
		wait 3 seconds
		command "/mine"
 
# essentials/anticheat.sk
 
on load:
	delete {acReach::*}
 
every second:
	delete {acBlocks::*}
 
on damage of player:
	attacker is a player
	damage cause is attack		
	set {_d} to distance between attacker and victim
	{_d} is set
	if {_d} >= 5.5:
		{acReach::%attacker%} isn't set
		send "&4[AC] &c%attacker% &7hit &c%victim% &7from &c%{_d}% &cblocks &7away!" to all players where [permissionLevel(input) > 0]
		set {acReach::%attacker%} to true
		wait 1 second
		delete {acReach::%attacker%}
 
# essentials/broadcasts.sk
 
on load:
		# set {broadcasts::*} to "%nl% &6&l> &eWant to support the server? &6Use /buy%nl% " and "%nl% &4&l> &cWe opened staff apps! Check ##info in our discord. %nl% "
		set {broadcasts::*} to "%nl% &2&l> &aBuy Op for $40! https://paypal.me/MrScopes%nl% " and "%nl% &3&l> &bWant to buy beans12 scripts? Message MrScopes on discord. %nl% "
		broadcast "%random element out of {broadcasts::*}%"
 
every 5 minutes:
	broadcast "%random element out of {broadcasts::*}%"
 
command /broadcast <text>:
	trigger:
		hasPermission(player, 2) isn't set
		broadcast "%nl% &6&l> &e%colored arg% %nl% "
 
# essentials/chat.sk
 
on load:
	delete {chatCd::*}
 
on chat:
	if message contains ("how" and "upgrade") or ("how" and "enchant"):
		cancel event
		send "&6&lTIP: &eUpgrade your tools and armor by right clicking them."
	event isn't canceled
	{mute::%player%} isn't set
	cancel event
	if donatorLevel(player) is 0:
		if {chat} is set:
			send "&cChat is currently muted: %{chat}%"
			stop
	if {chatCd::%player%} is set:
		send "&cPlease wait %difference between {chatCd::%player%} and now% &cto chat again. (Bypass with /buy)"
		stop
	set {_player} to player(player, true, true)
	if {clanChat::%player%} isn't set:
		set message to "%chatColor(player)%%message%"
		if donatorLevel(player) is 0:
			broadcast "%{_player}%&8: &f%message%"
			set {chatCd::%player%} to 2 seconds from now
			wait 2 seconds
			delete {chatCd::%player%}
		else:
			replace all "<command:" with "" in message
			loop all players:
				if message contains "%loop-player%":
					play sound "block.note_block.pling" to loop-player
					replace all "%loop-player%" with "&b&o@%loop-player%%chatColor(player)%" in message
			if donatorLevel(player) is 1 or 2:
				send "%{_player}%&8: &f%uncolored message%" to all players
			if donatorLevel(player) is 3 or 4:
				send colored "%{_player}%&8: &f%message%" to all players
			if donatorLevel(player) >= 5:
				if player is not holding air:
					set {_l} to join lore of tool with nl
					replace all "[item]" with "<tooltip:&e%name of tool ? type of tool%%nl%&7%enchantments of tool ? ""&7No Enchants""%%nl%&7%{_l} ? """"%>&6(%amount of tool in player's inventory%&6x) &e%name of tool ? type of tool%%chatColor(player)%" in message
				send formatted "%{_player}%&8: &f%message%" to all players
 
# essentials/clans.sk
 
# clan objects:
#  {clan::<player>} - id of player's clan
#  {clans::<id>::id} - id of clan
#  {clans::<id>::prefix} - optional custom name
#  {clans::<id>::name} - name of clan
#  {clans::<id>::names::*} - name history of clan
#  {clans::<id>::nameDate::<name>} - unix of date edited
#  {clans::<id>::owner} - owner of clan
#  {clans::<id>::members::*} - members of clan
#  {clans::<id>::createdAt} - unix of date created
#  {clans::<id>::blocks} - clan blocks mined
#  {clans::<id>::kills} - clan kills
#  {clans::<id>::deaths} - clan deaths
#  {clans::<id>::perks::maxMembers} - max members
#  {clans::<id>::perks::multi} - multi
 
command /clan [<text>] [<text>] [<text>]:
	trigger:
		if arg 1 isn't set:
			send ""
			send " &c/clan <"
			send " &7create, rename, leave, join, kick, invite, info, chat, disband, shop, contribution, transfer, top"
			send " &c>"
			send ""
		else:
			if arg 1 isn't "create", "disband", "join", "leave", "rename", "kick", "invite", "info", "shop", "chat", "contribution", "transfer" or "top":
				player command "/clan"
			else:
				set {_clan} to resolveClan(arg 2)
				createClan(player, arg 2) if arg 1 is "create"
				joinClan(player, {_clan}) if arg 1 is "join"
				invitePlayer(player, arg 2 parsed as offline player) if arg 1 is "invite"
				kickPlayer(player, arg 2 parsed as offline player) if arg 1 is "kick"
				leaveClan(player) if arg 1 is "leave"
				renameClan(player, arg 2) if arg 1 is "rename"
				disbandClan(player) if arg 1 is "disband"
				if arg 1 is "info":
					if arg 2 isn't set:
						clanInfo(player, {clan::%player%})
					else:
						clanInfo(player, {_clan})
				set {_m} to " %arg 3%" if arg 3 is set
				clanChat(player, "%arg 2%%{_m} ? """"%") if arg 1 is "chat"
				clanShop(player) if arg 1 is "shop"
				clanContribution(player, arg 2) if arg 1 is "contribution"
				clanTransfer(player, (arg 2 parsed as offline player)) if arg 1 is "transfer"
				clanTop(player, arg 2) if arg 1 is "top"
 
function resolveClan(input: text) :: text:
	return {_input} if "%indices of {clans::*}%" contains {_input}
	loop indices of {clans::*}:
		return loop-value if uncolored {clans::%loop-value%::name} is {_input}
	set {_player} to {_input} parsed as offline player
	return {clan::%{_player}%}
 
function clanInfo(player: offline player, clan: text):
	if {clans::%{_clan}%::id} isn't set:
		send "&cClan not found." to {_player}
	else:
		loop {clans::%{_clan}%::names::*}:
			add "&6%loop-value% &e(changed @ %unix date of {clans::%{_clan}%::nameDate::%loop-value%}%&e)" to {_names::*}
		set {_names::*} to "No Other Names." if "%{_names::*}%" is "<none>"
		send "" to {_player}
		send formatted "&e(ID. ##%{clans::%{_clan}%::id}%&e) <tooltip:%join {_names::*} with nl%>&6%{clans::%{_clan}%::prefix} ? {clans::%{_clan}%::name}%&r &e(%size of {clans::%{_clan}%::members::*}%&e/%maxMembers({_clan})%&e)" to {_player}
		send formatted "" to {_player}
		send formatted "  &7Led by&8: &6%player({clans::%{_clan}%::owner})%" to {_player}
		loop {clans::%{_clan}%::members::*}:
			add player(loop-value) to {_members::*}
			add round({balance::%loop-value%}) to {_balance}
		send formatted "<tooltip:%{_members::*}%>  &7Members&8: &6Hover" to {_player}
 
		set {_stats} to "&6Kills: &e%regex({clans::%{_clan}%::kills}) ? 0%%nl%&6Deaths: &e%regex({clans::%{_clan}%::deaths}) ? 0%%nl%&6Blocks: &e%regex({clans::%{_clan}%::blocks}) ? 0%%nl%&6Balance: &e$%regex({_balance})%"
		send formatted "<tooltip:%{_stats}%>  &7Stats&8: &6Hover" to {_player}
		send "  &7Created&8: &6%unix date of {clans::%{_clan}%::createdAt}%" to {_player}
		send "" to {_player}
 
function createClan(player: offline player, name: text):
	if {_name} isn't set:
		send "&c/clan create <name>" to {_player}
	else:
		if {clan::%{_player}%} is set:
			send "&cYou're already in a clan." to {_player}
		else:
			if length of {_name} > 15:
				send "&cClan name must be under 15 characters." to {_player}
			else:
				loop indices of {clans::*}:
					add uncolored {clans::%loop-value%::name} to {_clans::*}
				if {_clans::*} contains {_name}:
					send "&cThat name is taken." to {_player}
				else:
					add 1 to {clans}
					set {_id} to {clans}
					set {clan::%{_player}%} to "%{_id}%"
					set {clans::%{_id}%::id} to "%{_id}%"
					set {clans::%{_id}%::name} to {_name}
					set {clans::%{_id}%::owner} to {_player}
					set {clans::%{_id}%::members::*} to {_player}
					set {clans::%{_id}%::createdAt} to unix timestamp of 5 hours ago
					send " &6&l> &eCreated Clan &6%{_name}%&e!" to {_player}
 
function disbandClan(player: offline player):
	if {clan::%{_player}%} isn't set:
		send "&cYou aren't in a clan." to {_player}
	else:
		set {_clan} to {clan::%{_player}%}
		if {clans::%{_clan}%::owner} isn't {_player}:
			send "&cYou aren't the owner of your clan." to {_player}
		else:
			set {_id} to {clan::%{_player}%}
			send " &6&l> &e%{_player}% &7disbanded the clan." to all players where [{clan::%input%} is {clan::%{_player}%}]
			delete {clans::%{_id}%::id}
			delete {clans::%{_id}%::name}
			delete {clans::%{_id}%::names::*}
			delete {clans::%{_id}%::nameDate::*}
			delete {clans::%{_id}%::owner}
			delete {clans::%{_id}%::createdAt}
			delete {clans::%{_id}%::blocks}
			delete {clans::%{_id}%::kills}
			delete {clans::%{_id}%::deaths}
			delete {clans::%{_id}%::perks::maxMembers}
			delete {clans::%{_id}%::perks::multi}
			delete {clans::%{_id}%::members::*}
 
function renameClan(player: offline player, name: text):
	if {_name} isn't set:
		send "&c/clan rename <name>" to {_player}
	else:
		if {clan::%{_player}%} isn't set:
			send "&cYou aren't in a clan." to {_player}
		else:
			if length of {_name} > 15:
				send "&cClan name must be under 15 characters." to {_player}
			else:
				set {_clan} to {clan::%{_player}%}
				if {clans::%{_clan}%::owner} isn't {_player}:
					send "&cYou aren't the owner of your clan." to {_player}
				else:
					loop indices of {clans::*}:
						add uncolored {clans::%loop-value%::name} to {_clans::*}
					if {_clans::*} contains {_name}:
						send "&cThat name is taken." to {_player}
					else:
						add {clans::%{_clan}%::name} to {clans::%{_clan}%::names::*}
						set {clans::%{_clan}%::nameDate::%{clans::%{_clan}%::name}%} to unix timestamp of 5 hours ago
						set {clans::%{_clan}%::name} to {_name}
						send " &6&l> &e%{_player}% &7renamed to clan to &e%{_name}%" to all players where [{clan::%input%} is {clan::%{_player}%}]
 
function joinClan(player: offline player, clan: text):
	if {clan::%{_player}%} is set:
		send "&cYou are already in a clan." to {_player}
	else:
		if {clans::%{_clan}%::id} isn't set:
			send "&cClan not found." to {_player}
		else:
			if {clanInvites::%{_player}%::*} doesn't contain {_clan}:
				send "&cYou don't have an invite from that clan." to {_player}
			else:
				if size of {clans::%{_clan}%::members::*} >= maxMembers({_clan}):
					send "&cThat clan is full." to {_player}
				else:
					remove {_clan} from {clanInvites::%{_player}%::*}
					add {_player} to {clans::%{_clan}%::members::*}
					set {clan::%{_player}%} to {clans::%{_clan}%::id}
					send " &6&l> &e%{_player}% &7joined the clan!" to all players where [{clan::%input%} is {clan::%{_player}%}]
 
function kickPlayer(player: offline player, kickee: offline player):
	if {clan::%{_player}%} isn't set:
		send "&cYou aren't in a clan." to {_player}
	else:
		set {_clan} to {clan::%{_player}%}
		if {clans::%{_clan}%::owner} isn't {_player}:
			send "&cYou aren't the owner of your clan." to {_player}
		else:
			if {_kickee} is {_player}:
				send "&cYou can't kick yourself." to {_player}
			else:
				send " &6&l> &e%{_kickee}% &7has been kicked from the clan!" to all players where [{clan::%input%} is {clan::%{_player}%}]
				remove {_kickee} from {clans::%{_clan}%::members::*}
				delete {clan::%{_kickee}%}
 
function leaveClan(player: offline player):
	if {clan::%{_player}%} isn't set:
		send "&cYou aren't in a clan." to {_player}
	else:
		set {_clan} to {clan::%{_player}%}
		if {clans::%{_clan}%::owner} is {_player}:
			send formatted "&cYou can't leave your own clan. Do you want to disband? <command:/clan disband>&a[YES]" to {_player}
		else:
			send " &6&l> &e%{_player}% &7left the clan!" to all players where [{clan::%input%} is {clan::%{_player}%}]
			remove {_player} from {clans::%{_clan}%::members::*}
			delete {clan::%{_player}%}
 
function invitePlayer(player: offline player, invitee: offline player):
	if {_invitee} isn't set:
		send "&c/clan invite <player>" to {_player}
	else:
		if {clan::%{_player}%} isn't set:
			send "&cYou aren't in a clan." to {_player}
		else:
			if {clan::%{_invitee}%} is set:
				send "&cThat player is already in a clan." to {_player}
			else:
				set {_clan} to {clan::%{_player}%}
				if size of {clans::%{_clan}%::members::*} >= maxMembers({_clan}):
					send "&cYour clan is full." to {_player}
				else:
					if {clanInvites::%{_invitee}%::*} contains {_clan}:
						send "&cYou revoked %{_invitee}%&c's invite!" to {_player}
						send "&cYour invite to %{clans::%{_clan}%::name}% &cwas revoked by %{_player}%&c." to {_invitee}
						remove {_clan} from {clanInvites::%{_invitee}%::*}
					else:
						add {_clan} to {clanInvites::%{_invitee}%::*}
						send formatted "<command:/clan join %{clans::%{_clan}%::name}%> &7%{_player}% &7invited you to &6%{clans::%{_clan}%::name}%&7. &a(Click to Join)" to {_invitee}
						send "&7You invited &6%{_invitee}% &7to &6%{clans::%{_clan}%::name}%&7." to {_player}
 
function clanContribution(player: offline player, type: text):
	if {clan::%{_player}%} isn't set:
		send "&cYou aren't in a clan." to {_player}
	else:
		set {_clan} to {clan::%{_player}%}
		set {_id} to {clan::%{_player}%}
		if {_type} isn't "blocks", "kills" or "deaths":
			send "&c/clan contribution <blocks | kills | deaths>" to {_player}
		else:
			if {_type} is "blocks", "kills" or "deaths":
				set {_sort::*} to sort((indices of {clans::%{_id}%::%{_type}%::*}), {clans::%{_id}%::%{_type}%::*})
				send "" to {_player}
				send "     &6&l&lClan Contribution: %{_type}%" to {_player}
				send "" to {_player}
				loop {_sort::*}:
					add 1 to {_n}
					set {_p} to "%loop-value%" parsed as offline player
					send " &6##%{_n}% %player({_p}, true, true)% &6(%regex({clans::%{_id}%::%{_type}%::%{_p}%})% &6%{_type}%&6)" to {_player}
					if {_n} is 5:
						stop loop
				send "" to {_player}
 
function clanTransfer(player: offline player, newOwner: offline player):
	if {clan::%{_player}%} isn't set:
		send "&cYou aren't in a clan." to {_player}
	else:
		set {_clan} to {clan::%{_player}%}
		if {clans::%{_clan}%::owner} isn't {_player}:
			send "&cYou aren't the owner of your clan." to {_player}
		else:
			if {clan::%{_player}%} isn't {clan::%{_newOwner}%}:
				send "&cThat player isn't in your clan." to {_player}
			else:
				send " &6&l> &e%{_player}% &7appointed &e%{_newOwner}% &7as the new owner." to all players where [{clan::%input%} is {clan::%{_player}%}]
				set {clans::%{_clan}%::owner} to {_newOwner}
 
function clanTop(player: offline player, type: text):
	if {_type} isn't "blocks", "kills" or "deaths":
		send "&c/clan top <blocks | kills | deaths>" to {_player}
	else:
		if {_type} is "blocks", "kills" or "deaths":
			loop indices of {clans::*}:
				set {_top::%loop-value%} to {clans::%loop-value%::%{_type}%}
			set {_sort::*} to sort((indices of {_top::*}), {_top::*})
			send "" to {_player}
			send "     &6&l&lClan Top: %{_type}%" to {_player}
			send "" to {_player}
			loop {_sort::*}:
				add 1 to {_n}
				set {_id} to loop-value
				send " &6##%{_n}% &e%{clans::%{_id}%::prefix} ? {clans::%{_id}%::name}% &6(%regex({clans::%{_id}%::%{_type}%})% &6%{_type}%&6)" to {_player}
				if {_n} is 5:
					stop loop
			send "" to {_player}
 
function clanChat(player: offline player, message: text):
	if {clan::%{_player}%} isn't set:
		send "&cYou aren't in a clan." to {_player}
	else:
		if {_message} is "<none>":
			if {clanChat::%{_player}%} is set:
				delete {clanChat::%{_player}%}
				send "&cDisabled Clan chat." to {_player}
			else:
				set {clanChat::%{_player}%} to true
				send "&aEnabled Clan chat." to {_player}
		else:
			send " &6(%{clans::%{clan::%{_player}%}%::prefix} ? {clans::%{clan::%{_player}%}%::name}%&6) &6&l> &e%{_player}%&8: &f%{_message}%" to all players where [{clan::%input%} is {clan::%{_player}%}]
			send " &6(%{clans::%{clan::%{_player}%}%::prefix} ? {clans::%{clan::%{_player}%}%::name}%&6) &6&l> &e%{_player}%&8: &f%{_message}%" to all players where [{monitor::%input%} is true]
 
function maxMembers(clan: text) :: number:
	set {_members} to {clans::%{_clan}%::perks::maxMembers} ? 0
	return {_members} + 5
 
function clanMulti(clan: text) :: number:
	return {clans::%{_clan}%::perks::multi} ? 0
 
function walkSpeed(clan: text) :: number:
	set {_speed} to {clans::%{_clan}%::perks::walkSpeed}
	return {_speed} + 0.2
 
function shopRefresh(player: offline player):
	loop all players:
		clanShop(loop-player) if inventory name of loop-player's current inventory is "&6%{clans::%{clan::%{_player}%}%::name}%"
 
function price(player: offline player, clan: text, text: text) :: number:
	if {_text} is "multi":
		set {_base} to 100000 if clanMulti({_clan}) is .0
		set {_base} to 120000 if clanMulti({_clan}) is .1
		set {_base} to 140000 if clanMulti({_clan}) is .2
		set {_base} to 160000 if clanMulti({_clan}) is .3
		set {_base} to 200000 if clanMulti({_clan}) is .4
		set {_base} to 500000 if clanMulti({_clan}) is .5
		set {_base} to 1000000 if clanMulti({_clan}) is .6
		set {_base} to 1250000 if clanMulti({_clan}) is .7
		set {_base} to 1500000 if clanMulti({_clan}) is .8
		set {_base} to 1750000 if clanMulti({_clan}) is .9
		set {_base} to 2000000 if clanMulti({_clan}) is 1
		set {_base} to 3000000 if clanMulti({_clan}) is 1.1
		set {_base} to 4000000 if clanMulti({_clan}) is 1.2
		set {_base} to 5000000 if clanMulti({_clan}) is 1.3
		set {_base} to 6000000 if clanMulti({_clan}) is 1.4
		set {_base} to 7000000 if clanMulti({_clan}) is 1.5
		set {_base} to 8000000 if clanMulti({_clan}) is 1.6
		set {_base} to 9000000 if clanMulti({_clan}) is 1.7
		set {_base} to 1000000 if clanMulti({_clan}) is 1.8
		set {_base} to 1500000 if clanMulti({_clan}) is 1.9
	if {_text} is "maxMembers":
		set {_base} to 100000 if maxMembers({_clan}) is 5
		set {_base} to 125000 if maxMembers({_clan}) is 6
		set {_base} to 250000 if maxMembers({_clan}) is 7
		set {_base} to 500000 if maxMembers({_clan}) is 8
		set {_base} to 750000 if maxMembers({_clan}) is 9
		set {_base} to 1000000 if maxMembers({_clan}) is 10
		set {_base} to 2000000 if maxMembers({_clan}) is 11
		set {_base} to 3000000 if maxMembers({_clan}) is 12
		set {_base} to 4000000 if maxMembers({_clan}) is 13
		set {_base} to 5000000 if maxMembers({_clan}) is 14
		set {_base} to 6000000 if maxMembers({_clan}) is 15
		set {_base} to 7000000 if maxMembers({_clan}) is 16
		set {_base} to 8000000 if maxMembers({_clan}) is 17
		set {_base} to 9000000 if maxMembers({_clan}) is 18
		set {_base} to 10000000 if maxMembers({_clan}) is 19
	if {_text} is "walkSpeed":
		set {_base} to 25000 if walkSpeed({_clan}) is 0.2
		set {_base} to 50000 if walkSpeed({_clan}) is 0.21
		set {_base} to 75000 if walkSpeed({_clan}) is 0.22
		set {_base} to 100000 if walkSpeed({_clan}) is 0.23
		set {_base} to 125000 if walkSpeed({_clan}) is 0.24
		set {_base} to 150000 if walkSpeed({_clan}) is 0.25
		set {_base} to 175000 if walkSpeed({_clan}) is 0.26
		set {_base} to 200000 if walkSpeed({_clan}) is 0.27
		set {_base} to 250000 if walkSpeed({_clan}) is 0.28
		set {_base} to 300000 if walkSpeed({_clan}) is 0.29
		set {_base} to 400000 if walkSpeed({_clan}) is 0.3
		set {_base} to 600000 if walkSpeed({_clan}) is 0.31
		set {_base} to 750000 if walkSpeed({_clan}) is 0.32
		set {_base} to 1000000 if walkSpeed({_clan}) is 0.33
		set {_base} to 1500000 if walkSpeed({_clan}) is 0.34
		set {_base} to 2000000 if walkSpeed({_clan}) is 0.35
		set {_base} to 2500000 if walkSpeed({_clan}) is 0.36
		set {_base} to 3000000 if walkSpeed({_clan}) is 0.37
		set {_base} to 5000000 if walkSpeed({_clan}) is 0.38
		set {_base} to 7500000 if walkSpeed({_clan}) is 0.39
	set {_new} to {_base} - ({_base} * discount({_player}))
	return {_new}
 
function clanShop(player: offline player):
	set {_clan} to {clan::%{_player}%}
	if {_clan} isn't set:
		send "&cYou're not in a clan." to {_player}
	else:
		open chest inventory with 1 rows named "&6%{clans::%{clan::%{_player}%}%::name}%" to {_player}
		set slot 0 of {_player}'s current inventory to xp bottle with nbt "{type:multi}" named "&6Multiplier:" with lore "&eCurrent: &7+%clanMulti({_clan})%&7x", "&eUpgrade: &7+.1 for &a($%regex(price({_player}, {_clan}, ""multi""))%)" and "&eMax: &c+2x"
		set slot 1 of {_player}'s current inventory to player head item with nbt "{type:maxMembers}" named "&eMax Members:" with lore "&eCurrent: &7%maxMembers({_clan})%", "&eUpgrade: &7+1 for &a($%regex(price({_player}, {_clan}, ""maxMembers""))%)" and "&eMax: &c20"
		set slot 2 of {_player}'s current inventory to diamond boots with nbt "{type:walkSpeed}" with all flags hidden named "&eWalk Speed:" with lore "&eCurrent: &7%walkSpeed({_clan})%", "&eUpgrade: &7+.01 for &a($%regex(price({_player}, {_clan}, ""walkSpeed""))%)" and "&eMax: &c.4"
 
every second:
	loop all players:
		{clan::%loop-player%} is set
		set loop-player's walking speed to walkSpeed({clan::%loop-player%})
 
on inventory click:
	set {_clan} to {clan::%player%}
	inventory name of player's current inventory is "&6%{clans::%{_clan}%::name}%"
	cancel event
	set {_type} to tag "type" of nbt of event-item
	set {_cost} to price(player, {_clan}, {_type})
	{_cost} > 1
	if {balance::%player%} <= {_cost}:
		send "&cYou don't have enough money."
	else:
		remove {_cost} from {balance::%player%}
		add .1 to {clans::%{_clan}%::perks::multi} if {_type} is "multi"
		add 1 to {clans::%{_clan}%::perks::maxMembers} if {_type} is "maxMembers"
		add .01 to {clans::%{_clan}%::perks::walkSpeed} if {_type} is "walkSpeed"
		shopRefresh(player)
 
on chat:
	{clan::%player%} and {clanChat::%player%} is set
	cancel event
	send " &6(%{clans::%{clan::%player%}%::prefix} ? {clans::%{clan::%player%}%::name}%&6) &6&l> &e%player%&8: &f%message%" to all players where [{clan::%input%} is {clan::%player%}]
	send " &6(%{clans::%{clan::%player%}%::prefix} ? {clans::%{clan::%player%}%::name}%&6) &6&l> &e%player%&8: &f%message%" to all players where [{monitor::%input%} is true]
 
on damage of player:
	{clan::%victim%} and {clan::%attacker%} is set
	cancel event if {clan::%victim%} is {clan::%attacker%}
 
on death:
	add 1 to {clans::%{clan::%victim%}%::deaths} if {clan::%victim%} is set
	add 1 to {clans::%{clan::%victim%}%::deaths::%victim%} if {clan::%victim%} is set
	add 1 to {clans::%{clan::%attacker%}%::kills} if {clan::%attacker%} is set
	add 1 to {clans::%{clan::%attacker%}%::kills::%attacker%} if {clan::%attacker%} is set
 
on break:
	{clan::%player%} is set
	wait 1 tick
	event isn't canceled
	add 1 to {clans::%{clan::%player%}%::blocks}
	add 1 to {clans::%{clan::%player%}%::blocks::%player%}
 
every second:
	loop all players:
		{clan::%loop-player%} is set
		delete {clan::%loop-player%} if {clans::%{clan::%loop-player%}%::name} isn't set
 
# essentials/combat.sk
 
on death:
	attacker and victim are a player
	attacker is not victim
	cancel event
	add 1 to {ks::%attacker%}
	add 1 to {kills::%attacker%}
	delete {ks::%victim%}
	add 1 to {deaths::%victim%}
	delete {ct::%victim%} and {ct::%attacker%}
	heal victim
	feed victim
	extinguish victim
	wait 1 ticks 
	teleport victim to {spawn}
	if attacker is a player:
		set {_money} to {balance::%victim%} / 100
		send title "" with subtitle "&7You killed &6%victim%&7. &a(+$%regex({_money})%&a)" to attacker
		send title "" with subtitle "&7You were killed by &c%attacker%&7. &c(-$%regex({_money})%&c)" to victim
		add {_money} to {balance::%attacker%}
		remove {_money} from {balance::%victim%}
 
on quit:
	{ct::%player%} is set
	set {_attacker} to ({attacker::%player%} parsed as offline player)
	broadcast "&6%player% &7left while combat tagged to &6%{_attacker}%"
	kill player
 
on command:
	{ct::%player%} is set
	if command is "spawn":
		cancel event
		send "&cYou can't use that command while combat tagged."
 
on damage of player:
	"%bounds at attacker%" and "%bounds at victim%" don't contain "spawn"
	event isn't canceled
	attacker is a player
 
	if attacker's tool is any sword:
		if {doubler::%attacker%} is set:
			chance of ({doubler::%attacker%} * 5)%:
				set damage to damage * 2
				send action bar "&d%attacker%&d's damage was doubled!" to victim and attacker
 
		if {slowing::%attacker%} is set:
			chance of ({slowing::%attacker%} * 5)%:
				apply slowness 4 without particles to victim for 3 seconds replacing the existing effect if {slowing::%attacker%} is 1
				apply slowness 5 without particles to victim for 3 seconds replacing the existing effect if {slowing::%attacker%} is 2
				send action bar "&7%attacker%&7's slowness activated." to victim and attacker
 
		if {poison::%attacker%} is set:
			chance of ({poison::%attacker%} * 5)%:
				apply poison 1 without particles to victim for 3 seconds replacing the existing effect if {poison::%attacker%} is 1
				apply poison 2 without particles to victim for 3 seconds replacing the existing effect if {poison::%attacker%} is 2
				send action bar "&2%attacker%&2's poison activated." to victim and attacker
 
	if victim's tool is any sword:
		if {block::%victim%} is set:
			chance of ({block::%victim%} * 2)%:
				set damage to damage / 3
				send action bar "&3%attacker%&3's attack was blocked!" to victim and attacker
 
		if {counter::%victim%} is set:
			chance of ({counter::%victim%} * 1)%:
				damage attacker by damage
				cancel event
				send action bar "&c%victim%&c's counter activated." to victim and attacker
 
		if {milk::%victim%} is set:
			chance of ({poison::%victim%} * 2)%:
				remove slowness and poison from victim
				extinguish victim
				feed victim
				send action bar "&f%victim%&f's ailments were removed." to victim and attacker
 
	set {attacker::%victim%} to attacker's name
 
	send "&7You have combat tagged &c%victim%&7." to attacker if {ct::%attacker%} is not set
	send "&7You've been combat tagged by &c%attacker%&7." to victim if {ct::%victim%} is not set
 
	set {ct::%attacker%} to 20
	set {ct::%victim%} to 20
 
on bound enter:
	{ct::%player%} is set
	bound is bound with id "spawn"
	# while {ct::%player%} is set:
	#	"%bounds at player%" contains "spawn"
	#	set player's gliding to off
	#	push player down at speed 2
	#	push player southwest at speed 2
	#	send title "&cYou're Combat Tagged!" with subtitle "&7You may not enter spawn." to player
	# wait 10 ticks
 
every second:
	loop all players:
		if {ct::%loop-player%} is set:
			remove 1 from {ct::%loop-player%}
			if {ct::%loop-player%} is 0:
				delete {ct::%loop-player%}
				send "&7Your combat tag has expired." to loop-player
 
command /ct [<text>]:
	trigger:
		send "&7You are not combat tagged." if {ct::%player%} is not set
		send "&7You are combat tagged for &c%{ct::%player%}% &7seconds." if {ct::%player%} is set
 
on load:
	delete {gap::*}
 
on consume of golden apple:
	if {gap::%player%} is set:
		cancel event
		send "&cYou have to wait %difference between {gap::%player%} and now% &cto gap!"
	else:
		set {gap::%player%} to 20 seconds from now
		wait 20 seconds
		delete {gap::%player%}
 
# essentials/crates
 
command /crates:
	trigger:
		send "&7You have &6%{crates::%player%} ? 0% &6Crate Keys&7."
 
command /crate:
	trigger:
		{crates::%player%} is set
		if {crates::%player%} < 1:
			send "&cYou have no keys. Buy them with /buy."
		else:
			remove 1 from {crates::%player%}
			set {_i} to random integer between 1 and 950
 
			if {_i} is between 1 and 350:
				set {_xp} to random integer between 25000 and 1000000
				set {_reward} to "%regex({_xp})% xp"
				add {_xp} to {xp::%player%}
				loop 25 times:
					level(player)
 
			if {_i} is between 351 and 700:
				set {_$} to random integer between 100000 and 1000000
				set {_reward} to "$%regex({_$})%"
				add {_$} to {balance::%player%}
 
			if {_i} is between 701 and 800:
				add 1 to {crater::%player%} and {jackhammer::%player%}
				equip(player)
				set {_reward} to "+1 Crater and Jackhammer"
 
			if {_i} is between 801 and 900:
				add 1 to {efficiency::%player%} and {experience::%player%}
				equip(player)
				set {_reward} to "+1 Efficiency and Experience"
 
			if {_i} is between 901 and 950:
				add .1 to {multi::%player%}
				equip(player)
				set {_reward} to "+.1x multi"
 
			broadcast "%nl% &6&l> &e%player% &7opened a key and received &e%{_reward}%&7.%nl% "
 
# essentials/defaultCommands.sk
 
command /tps:
	trigger:
		set {_p::*} to ping of all players
		loop {_p::*}:
			add loop-value to {_n}
		set {_p} to amount of online players
		set {_avg} to {_n} / {_p}	
		send ""
		send " &6Players: &f%amount of players%&f/%{max}%"
		send " &6TPS: &f%tps from last minute%"	
		send " &6Average Ping (Serverwide): &f%regex({_avg})%&fms"
		send " &6Your Ping: &f%regex(player's ping)%&fms"
		send ""
 
command /spawn [<offline player=%player%>]:
	trigger:
		if permissionLevel(player) < 1:
			teleport player to {spawn}
		else:
			teleport arg to {spawn}
 
command /stats [<offline player=%player%>]:
	trigger:
		if {playtime::%arg%} isn't set:
			send "&cPlayer not found."
		else:
			send ""
			send " %player(arg, true, true)%"
			send ""
			send " &6Kills: &e%regex({kills::%arg%}) ? 0%"
			send " &6Deaths: &e%regex({deaths::%arg%}) ? 0%"
			send " &6Balance: &e$%regex({balance::%arg%}) ? 0%"
			send " &6Blocks: &e%regex({blocks::%arg%}) ? 0%"
			send " &6Playtime: &e%{playtime::%arg%}%"
			send ""
 
command /rules:
	trigger:
		send "don't be a fucking bitch (so no hacking, don't annoy MrScopes, etc)"
 
# essentials/donator.sk
 
function donatorLevel(p: player) :: integer:
	return 6 if {rank::%{_p}%} is "admin", "srmod", "mod" or "chad"
	return 5 if {rank::%{_p}%} is "patron"
	return 4 if {rank::%{_p}%} is "gamer"
	return 3 if {rank::%{_p}%} is "legend"
	return 2 if {rank::%{_p}%} is "premium"
	return 1 if {rank::%{_p}%} is "vip"
	return 0
 
function donatorPermission(p: player, level: integer) :: boolean:
	donatorLevel({_p}) < {_level}
	send "&cYou don't have permission." to {_p}
	return true
 
function donatorMulti(p: player) :: number:
	return 0 if donatorLevel({_p}) is 0
	return 0.1 if donatorLevel({_p}) is 1
	return 0.25 if donatorLevel({_p}) is 2
	return 0.35 if donatorLevel({_p}) is 3
	return 0.5 if donatorLevel({_p}) is 4
	return 1 if donatorLevel({_p}) is 5
	return 2 if donatorLevel({_p}) is 6
 
function discount(p: player) :: number:
	return 0 if donatorLevel({_p}) is 0
	return .05 if donatorLevel({_p}) is 1
	return .075 if donatorLevel({_p}) is 2
	return .1 if donatorLevel({_p}) is 3
	return .2 if donatorLevel({_p}) is 4
	return .3 if donatorLevel({_p}) is 5
	return .5 if donatorLevel({_p}) is 5	
 
function chatColor(p: player) :: text:
	return "&7" if donatorLevel({_p}) is 0
	return "%{chatColor::%{_p}%} ? ""&f""%"
 
command /process [<offline player>] [<text>]:
	permission: admin
	permission message: &cYou don't have access to that command.
	trigger:
		if arg 2 is "vip":
			set {rank::%arg 1%} to arg 2 if {rank::%arg 1%} isn't "admin", "srmod", "mod", "premium", "legend", "gamer", "patron" or "chad"
			set {_m} to "&6%arg 1% &fpurchased &a&lVip&f."
		if arg 2 is "premium":
			set {rank::%arg 1%} to arg 2 if {rank::%arg 1%} isn't "admin", "srmod", "mod", "legend", "gamer", "patron" or "chad"
			set {_m} to "&6%arg 1% &fpurchased &b&lPremium&f."		
		if arg 2 is "legend":
			set {rank::%arg 1%} to arg 2 if {rank::%arg 1%} isn't "admin", "srmod", "mod", "gamer", "patron" or "chad"
			set {_m} to "&6%arg 1% &fpurchased &d&lLegend&f."		
		if arg 2 is "gamer":
			set {rank::%arg 1%} to arg 2 if {rank::%arg 1%} isn't "admin", "srmod", "mod", "patron" or "chad"
			set {_m} to "&6%arg 1% &fpurchased &9&lGamer&f."						
		if arg 2 is "patron":
			set {rank::%arg 1%} to arg 2 if {rank::%arg 1%} isn't "admin", "srmod", "mod" or "chad"
			set {_m} to "&6%arg 1% &fpurchased &3&lPatron&f."
		if arg 2 is "chad":
			set {rank::%arg 1%} to arg 2 if {rank::%arg 1%} isn't "admin", "srmod" or "mod"
			set {_m} to "&6%arg 1% &fpurchased &4&lChad&f."
		if arg 2 is "key3":
			add 1 to {crates::%arg 1%}
			set {_m} to "&6%arg 1% &fpurchased &6+3x &6Crate Keys&f."
		{_m} is set
		broadcast ""
		broadcast " &6&l▪ %{_m}% &e(/buy) &6&l▪"
		broadcast ""
 
command /trash:
	trigger:
		donatorPermission(player, 1) isn't set
		open chest inventory named "&8Swayl" to player
 
command /enderchest [<offline player=%player%>]:
	aliases: /ec
	trigger:
		donatorPermission(player, 1) isn't set
		set {_player} to arg if permissionLevel(player) > 0 else player
		open {_player}'s enderchest to player
 
command /rename [<text=%name of tool%>]:
	aliases: /ec
	trigger:
		donatorPermission(player, 2) isn't set
		send "&7Renamed tool to &6%colored arg%&7."
		set name of tool to colored arg
 
command /color:
	trigger:
		donatorPermission(player, 4) isn't set
		wait 1 tick
		open chest inventory with 1 rows named "&8Choose your Color Type" to player
		set slot 3 of player's current inventory to red tulip named "&fChat" with lore "&fChange your Chat Color."
		set slot 5 of player's current inventory to orange tulip named "&fPrefix" with lore "&fChange your Prefix Color." if donatorLevel(player) > 4
 
on inventory click:
	if inventory name of player's current inventory contains "&8Choose your Color Type":
		cancel event
		if type of event-item is red tulip:
			open chest inventory with 1 rows named "&8Chat Colors" to player
			set slot 0 of player's current inventory to white wool named "&fWhite Chat" with lore "&fThis is your chat."
			set slot 1 of player's current inventory to pink wool named "&dPink Chat" with lore "&dThis is your chat."
			set slot 2 of player's current inventory to yellow wool named "&eYellow Chat" with lore "&eThis is your chat."
			set slot 3 of player's current inventory to orange wool named "&6Gold Chat" with lore "&6This is your chat."
			set slot 4 of player's current inventory to light blue wool named "&bAqua Chat" with lore "&bThis is your chat."
			set slot 5 of player's current inventory to lime wool named "&aGreen Chat" with lore "&aThis is your chat."
			set slot 6 of player's current inventory to cyan wool named "&3Cyan Chat" with lore "&3This is your chat."
			set slot 7 of player's current inventory to red wool named "&cRed Chat" with lore "&cThis is your chat."
			set slot 8 of player's current inventory to blue wool named "&9Blue Chat" with lore "&9This is your chat."
 
		if type of event-item is orange tulip:
			open chest inventory with 1 rows named "&8Prefix Colors" to player
			set slot 0 of player's current inventory to white wool named prefix({rank::%player%}, "&f&l")
			set slot 1 of player's current inventory to pink wool named prefix({rank::%player%}, "&d&l")
			set slot 2 of player's current inventory to yellow wool named prefix({rank::%player%}, "&e&l")
			set slot 3 of player's current inventory to orange wool named prefix({rank::%player%}, "&6&l")
			set slot 4 of player's current inventory to light blue wool named prefix({rank::%player%}, "&b&l")
			set slot 5 of player's current inventory to lime wool named prefix({rank::%player%}, "&a&l")
			set slot 6 of player's current inventory to cyan wool named prefix({rank::%player%}, "&3&l")
			set slot 7 of player's current inventory to red wool named prefix({rank::%player%}, "&c&l")
			set slot 8 of player's current inventory to blue wool named prefix({rank::%player%}, "&9&l")
 
	if inventory name of player's current inventory contains "&8Chat Colors":
		cancel event
		set {chatColor::%player%} to "&f" if type of event-item is white wool
		set {chatColor::%player%} to "&d" if type of event-item is pink wool
		set {chatColor::%player%} to "&e" if type of event-item is yellow wool
		set {chatColor::%player%} to "&6" if type of event-item is orange wool
		set {chatColor::%player%} to "&b" if type of event-item is light blue wool
		set {chatColor::%player%} to "&a" if type of event-item is lime wool
		set {chatColor::%player%} to "&3" if type of event-item is cyan wool
		set {chatColor::%player%} to "&c" if type of event-item is red wool
		set {chatColor::%player%} to "&9" if type of event-item is blue wool
 
	if inventory name of player's current inventory contains "&8Prefix Colors":
		cancel event
		event-item isn't air
		set {prefix::%player%} to name of event-item
 
on inventory close:
	player command "/color" if inventory name of event-inventory contains "&8Chat Colors" or "&8Prefix Colors"
 
command /prefix <text>:
	trigger:
		donatorPermission(player, 6) isn't set
		if length of uncolored arg > 15:
			send "&cbro that prefix is too long... keep it under 15 chars"
		else:
			if arg is "reset":
				delete {prefix::%player%}
			else:
				set {prefix::%player%} to colored arg if uncolored arg doesn't contain "admin" or "mod"
 
# essentials/economy.sk
 
function sort(indices: strings, values: numbers, descending: boolean = true) :: strings:
	loop {_indices::*}:
		add 1 to {_f}
		{_values::%loop-index%} > 0
		("%loop-value%" parsed as offline player) is set
		set {_sort::%{_values::%loop-index%}%.%{_f}%} to loop-value
	return (reversed {_sort::*}) if {_descending} is true, else {_sort::*}
 
command /baltop [<number=1>]:
	trigger:
		set {_sort::*} to sort((indices of {balance::*}), {balance::*})
		send ""
		send "     &6&l&lBaltop &e(Page %arg%&e/%round(size of {_sort::*} / 6)%&e)"
		send ""
		loop numbers from 6 * (arg - 1) + 1 to min(6 * arg, size of {_sort::*}):
			set {_player} to {_sort::%loop-number%} parsed as offline player
			send " &6##%loop-number% %player({_player}, true, true) ? loop-value% &6($%regex({balance::%{_player}%})%&6)"
		send ""
 
command /leveltop [<number=1>]:
	trigger:
		set {_sort::*} to sort((indices of {level::*}), {level::*})
		send ""
		send "     &6&l&lLeveltop &e(Page %arg%&e/%round(size of {_sort::*} / 6)%&e)"
		send ""
		loop numbers from 6 * (arg - 1) + 1 to min(6 * arg, size of {_sort::*}):
			set {_player} to {_sort::%loop-number%} parsed as offline player
			send " &6##%loop-number% %player({_player}, true, true) ? loop-value%"
		send ""
 
command /blocktop [<number=1>]:
	trigger:
		set {_sort::*} to sort((indices of {blocks::*}), {blocks::*})
		send ""
		send "     &6&l&lBlocktop &e(Page %arg%&e/%round(size of {_sort::*} / 6)%&e)"
		send ""
		loop numbers from 6 * (arg - 1) + 1 to min(6 * arg, size of {_sort::*}):
			set {_player} to {_sort::%loop-number%} parsed as offline player
			send " &6##%loop-number% %player({_player}, true, true) ? loop-value% &6(%regex({blocks::%{_player}%})% &6blocks)"
		send ""
 
command /killtop [<number=1>]:
	trigger:
		set {_sort::*} to sort((indices of {kills::*}), {kills::*})
		send ""
		send "     &6&l&lKilltop &e(Page %arg%&e/%round(size of {_sort::*} / 6)%&e)"
		send ""
		loop numbers from 6 * (arg - 1) + 1 to min(6 * arg, size of {_sort::*}):
			set {_player} to {_sort::%loop-number%} parsed as offline player
			send " &6##%loop-number% %player({_player}, true, true) ? loop-value% &6(%regex({kills::%{_player}%})% &6kills)"
		send ""
 
command /deathtop [<number=1>]:
	trigger:
		set {_sort::*} to sort((indices of {deaths::*}), {deaths::*})
		send ""
		send "     &6&l&lDeathtop &e(Page %arg%&e/%round(size of {_sort::*} / 6)%&e)"
		send ""
		loop numbers from 6 * (arg - 1) + 1 to min(6 * arg, size of {_sort::*}):
			set {_player} to {_sort::%loop-number%} parsed as offline player
			send " &6##%loop-number% %player({_player}, true, true) ? loop-value% &6(%regex({deaths::%{_player}%})% &6deaths)"
		send ""
 
command /bountytop [<number=1>]:
	trigger:
		set {_sort::*} to sort((indices of {bounty::*}), {bounty::*})
		send ""
		send "     &6&l&lBountytop &e(Page %arg%&e/%round(size of {_sort::*} / 6)%&e)"
		send ""
		loop numbers from 6 * (arg - 1) + 1 to min(6 * arg, size of {_sort::*}):
			set {_player} to {_sort::%loop-number%} parsed as offline player
			send " &6##%loop-number% %player({_player}, true, true) ? loop-value% &6($%regex({bounty::%{_player}%})%&6)"
		send ""
 
command /playtimetop [<number=1>]:
	trigger:
		loop {playtime::*}:
			loop-value > 10 minutes
			set {_playtime::%loop-index%} to unix timestamp of loop-value from now
		set {_sort::*} to sort((indices of {_playtime::*}), {_playtime::*})
		send ""
		send "     &6&l&lPlaytimetop &e(Page %arg%&e/%round(size of {_sort::*} / 6)%&e)"
		send ""
		loop numbers from 6 * (arg - 1) + 1 to min(6 * arg, size of {_sort::*}):
			set {_player} to {_sort::%loop-number%} parsed as offline player
			send " &6##%loop-number% %player({_player}, true) ? loop-value% &6(%{playtime::%{_player}%}%&6)"
		send ""
 
command /pingtop [<number=1>]:
	trigger:
		loop all players:
			set {_ping::%loop-player%} to loop-player's ping
		set {_sort::*} to sort((indices of {_ping::*}), {_ping::*})
		send ""
		send "     &6&l&lPingtop &e(Page %arg%&e/%round(size of {_sort::*} / 6)%&e)"
		send ""
		loop numbers from 6 * (arg - 1) + 1 to min(6 * arg, size of {_sort::*}):
			set {_player} to {_sort::%loop-number%} parsed as offline player
			send " &6##%loop-number% %player({_player}, true, true) ? loop-value% &6(%regex({_player}'s ping)%&6ms)"
		send ""
 
command /bal [<offline player=%player%>]:
	trigger:
		send "&6%arg%&6's &7money is &6$%regex({balance::%arg%}) ? 0%&7."
 
command /pay [<offline player>] [<text>]:
	trigger:
		add 0 to {balance::%player%}
		if arg 2 isn't set:
			send "&c/pay <player> <amount>"
		else:
			set {_money} to arg 2
			replace all "," with "" in {_money}
			set {_money} to {_money} parsed as number
			if {_money} > {balance::%player%}:
				send "&cYou don't have enough money for that."
			else:
				if {_money} < 1000:
					send "&cPay minimum is $100."
				else:
					remove {_money} from {balance::%player%}
					add {_money} to {balance::%arg 1%}
					send "&7Gave &6$%regex({_money})% &7to &6%arg 1%&7."
					send "&6%player% &7paid you &6$%regex({_money})%&7." to arg 1
 
command /bounty [<offline player=%player%>] [<number>]:
	trigger:
		if arg 2 isn't set:
			send "&6%arg 1%&6's &7bounty is &6$%regex({bounty::%arg 1%}) ? 0%"
		else:
			if arg 2 < 1000:
				send "&cBounty minimum is $1000."
			else:
				if {balance::%player%} < arg 2:
					send "&cYou don't have enough money for that."
				else:
					add arg 2 to {bounty::%arg 1%}
					remove arg 2 from {balance::%player%}
					broadcast "&6%player% &7added a bounty of &6$%regex(arg 2)% &7to &6%arg 1%&7."
 
on death of player:
	attacker is a player
	attacker is not victim
	{bounty::%victim%} is set
	broadcast ""
	broadcast " &6%attacker% &7claimed the &6$%regex({bounty::%victim%})% &7bounty of &6%victim%&7."
	broadcast ""
	add {bounty::%victim%} to {balance::%attacker%}
	delete {bounty::%victim%}
 
command /shop:
	trigger:
		shop(player, "shop")
 
function shop(p: player, category: text):
	wait 3 ticks
 
	if {_category} is "shop":
		open chest inventory with 1 rows named "&8Shop" to {_p}
		set slot 3 of {_p}'s current inventory to grass block with nbt "{category:blocks}" named "&a&lBuilding Blocks" with lore "&7Click to shop for building blocks."
		set slot 5 of {_p}'s current inventory to golden apple with nbt "{category:misc}" named "&c&lMisc" with lore "&7Click to shop for misc items."
		set {_main} to true
 
	if {_category} is "blocks":
		open chest inventory with 5 rows named "&8Blocks Shop" to {_p}
 
		set {_price::Oak Logs} to 100
		set {_price::Spruce Logs} to 100
		set {_price::Birch Logs} to 100
		set {_price::Jungle Logs} to 100
		set {_price::Acacia Logs} to 100
		set {_price::Dark Oak Logs} to 100
		set {_price::Stone} to 100
		set {_price::Cobblestone} to 100
		set {_price::Granite} to 100
		set {_price::Polished Granite} to 100
		set {_price::Diorite} to 100
		set {_price::Polished Diorite} to 100
		set {_price::Andesite} to 100
		set {_price::Polished Andesite} to 100
		set {_price::Grass} to 100
		set {_price::Dirt} to 100
		set {_price::Coarse Dirt} to 100
		set {_price::Podzol} to 100
		set {_price::Sandstone} to 100
		set {_price::Chiseled Sandstone} to 100
		set {_price::Smooth Quartz} to 100
		set {_price::White Wool} to 100
		set {_price::Black Wool} to 100
		set {_price::Red Wool} to 100
		set {_price::Light Blue Wool} to 100
		set {_price::White Concrete} to 100
		set {_price::Black Concrete} to 100
		set {_price::Red Concrete} to 100
		set {_price::Light Blue Concrete} to 100
		set {_price::White Terracotta} to 100
		set {_price::Black Terracotta} to 100
		set {_price::Red Terracotta} to 100
		set {_price::Light Blue Terracotta} to 100
		set {_price::Glass} to 100
		set {_price::White Stained Glass} to 100
		set {_price::Black Stained Glass} to 100
		set {_price::Red Stained Glass} to 100
		set {_price::Light Blue Stained Glass} to 100
		set {_price::Soul Sand} to 100
		set {_price::Soul Soil} to 100
		set {_price::Basalt} to 100
		set {_price::Polished Basalt} to 100
		set {_price::Pumpkin} to 100
		set {_price::Melon} to 100
 
 
 
		set {_price::Obsidian} to 1000
		set {_amount::Obsidian} to 4
 
	if {_category} is "misc":
		open chest inventory with 5 rows named "&8Misc Shop" to {_p}
 
		set {_price::Fireworks} to 1000
 
		set {_price::Golden Apple} to 1600
		set {_amount::Golden Apple} to 4
 
	{_main} isn't true
	set {_n} to -1
	loop {_price::*}:
		broadcast "Shop item bugged: %loop-index%" if (loop-index parsed as item) isn't set
		(loop-index parsed as item) is set
		add 1 to {_n}
		set {_price} to ({_price::%loop-index%} ? 100) - (({_price::%loop-index%} ? 100) * discount({_p}))
		set {_amount} to {_amount::%loop-index%} ? 16
		set slot {_n} of {_p}'s current inventory to (loop-index parsed as item) with nbt "{amount:%{_amount}%}" with nbt "{price:%{_price}%}" with lore "&7Left Click to buy &a%{_amount}%&ax &7for &a$%regex({_price})%&7.", "&7Right Click to buy &a%{_amount} * 2%&ax &7for &a$%regex({_price} * 2)%&7." and "&7Middle Click to buy &a%{_amount} * 4%&ax &7for &a$%regex({_price} * 4)%&7."		
 
on inventory click:
	inventory name of player's current inventory contains "shop"
	cancel event
	"%event-slot%" doesn't contain "%player%"
	type of event-item is set
 
	set {_category} to tag "category" of nbt of event-item
	if length of {_category} <= 10:
		shop(player, {_category})
	else:
		set {_price} to tag "price" of nbt of event-item
		set {_amount} to tag "amount" of nbt of event-item
		set {_item} to event-item named "" with lore ""
		delete lore of {_item}
		length of "%{_price}%" <= 10
		length of "%{_amount}%" <= 10
		{_item} is set
		set {_amount} to {_amount} * 2 if click type is right mouse button
		set {_amount} to {_amount} * 4 if click type is middle mouse button
		set {_price} to {_price} * 2 if click type is right mouse button
		set {_price} to {_price} * 4 if click type is middle mouse button
		if {balance::%player%} < {_price}:
			send "&cYou don't have enough money."
		else:
			remove {_price} from {balance::%player%}
			give player {_amount} of {_item}
			send "&7You successfully bought &6%{_amount}%&6x %{_item}% &7for &6$%regex({_price})%&7."
			set {msg::%player%} to ":shopping_cart: `[%3 hours ago%]` %player% bought `%{_amount}%x %{_item}%`."
			send {msg::%player%} to channel with id "547132975666561052" with "beans"
			delete {msg::%player%}
 
on inventory close:
	shop(player, "shop") if inventory name of event-inventory contains "blocks" or "misc"
 
# essentials/kit.sk
 
command /kit:
	trigger:
		equip(player)
 
function equip(player: offline player):
 
	loop all items in {_player}'s inventory:
		remove all loop-item from {_player}'s inventory if loop-item is any sword, any pickaxe, any armor, bow, arrow or elytra
 
	equip {_player} with "all diamond armor of protection %{protection::%{_player}%}%" parsed as item type if {protection::%{_player}%} is set
	equip {_player} with all diamond armor if {protection::%{_player}%} isn't set
 
	set {_sword} to diamond sword
	enchant {_sword} with "sharpness %{sharpness::%{_player}%}%" parsed as enchantment type if {sharpness::%{_player}%} is set
	enchant {_sword} with "knockback %{knockback::%{_player}%}%" parsed as enchantment type if {knockback::%{_player}%} is set
	enchant {_sword} with "fire aspect %{fire aspect::%{_player}%}%" parsed as enchantment type if {fire aspect::%{_player}%} is set
	add "&bDoubler %{doubler::%{_player}%}%" to lore of {_sword} if {doubler::%{_player}%} is set
	add "&bSlowing %{slowing::%{_player}%}%" to lore of {_sword} if {slowing::%{_player}%} is set
	add "&bBlock %{block::%{_player}%}%" to lore of {_sword} if {block::%{_player}%} is set
	add "&bCounter %{counter::%{_player}%}%" to lore of {_sword} if {counter::%{_player}%} is set
	add "&bPoison %{poison::%{_player}%}%" to lore of {_sword} if {poison::%{_player}%} is set
	add "&bMilk %{milk::%{_player}%}%" to lore of {_sword} if {milk::%{_player}%} is set
 
	set {_pickaxe} to diamond pickaxe 
	enchant {_pickaxe} with "efficiency %{efficiency::%{_player}%}%" parsed as enchantment type if {efficiency::%{_player}%} is set
	add "&bSpeed %{speed::%{_player}%}%" to lore of {_pickaxe} if {speed::%{_player}%} is set
	add "&bBlast %{blast::%{_player}%}%" to lore of {_pickaxe} if {blast::%{_player}%} is set
	add "&bExperience %{experience::%{_player}%}%" to lore of {_pickaxe} if {experience::%{_player}%} is set
	add "&bJackhammer %{jackhammer::%{_player}%}%" to lore of {_pickaxe} if {jackhammer::%{_player}%} is set
	add "&bDrill %{drill::%{_player}%}%" to lore of {_pickaxe} if {drill::%{_player}%} is set
 
	if {crater::%{_player}%} is set:
		set {_$} to 7500000 if {crater::%{_player}%} is 3
		set {_$} to 2500000 if {crater::%{_player}%} is 2
		set {_$} to 500000 if {crater::%{_player}%} is 1
		add {_$} to {balance::%{_player}%}
		send "&7Crater has been removed. Here's &a$%regex({_$})%&7." to {_player}
		delete {crater::%{_player}%}
 
	set {_bow} to bow
	enchant {_bow} with "power %{power::%{_player}%}%" parsed as enchantment type if {power::%{_player}%} is set
	enchant {_bow} with "flame %{flame::%{_player}%}%" parsed as enchantment type if {flame::%{_player}%} is set
	enchant {_bow} with "punch %{punch::%{_player}%}%" parsed as enchantment type if {punch::%{_player}%} is set
	enchant {_bow} with "infinity %{infinity::%{_player}%}%" parsed as enchantment type if {infinity::%{_player}%} is set
 
	give {_player} 1 of {_sword}
	give {_player} 1 of {_pickaxe}
	give {_player} 1 of {_bow}
	give {_player} 16 arrow
	give {_player} 1 elytra
 
on right click:
	{ct::%player%} isn't set
	cancel event if tool is any armor
	enchantGui(player) if tool is any armor, any sword or any pickaxe
	if player is sneaking:
		enchantGui(player) if tool is bow
 
on drop:
	cancel event if item is any armor, any sword, any pickaxe, bow or elytra
 
function cost(enchantment: text, level: number) :: number:
	if {_enchantment} is "efficiency":
		return 1000 if {_level} is 1
		return 5000 if {_level} is 2
		return 7500 if {_level} is 3
		return 10000 if {_level} is 4
		return 15000 if {_level} is 5
		return 40000 if {_level} is 6
		return 75000 if {_level} is 7
		return 100000 if {_level} is 8
		return 200000 if {_level} is 9
 
	if {_enchantment} is "speed":
		return 10000 if {_level} is 1
		return 25000 if {_level} is 2
 
	if {_enchantment} is "blast":
		return 100000 if {_level} is 1
		return 250000 if {_level} is 2
		return 500000 if {_level} is 3
 
	if {_enchantment} is "experience":
		return 200000 if {_level} is 1
		return 400000 if {_level} is 2
		return 600000 if {_level} is 3
 
	if {_enchantment} is "jackhammer":
		return 100000 if {_level} is 1
		return 200000 if {_level} is 2
		return 300000 if {_level} is 3
 
	if {_enchantment} is "drill":
		return 50000 if {_level} is 1
		return 100000 if {_level} is 2
		return 200000 if {_level} is 3
 
	if {_enchantment} is "sharpness":
		return 10000 if {_level} is 1
		return 25000 if {_level} is 2
		return 50000 if {_level} is 3
		return 75000 if {_level} is 4
		return 100000 if {_level} is 5
 
	if {_enchantment} is "fire aspect":
		return 35000 if {_level} is 1
		return 70000 if {_level} is 2
 
	if {_enchantment} is "knockback":
		return 10000 if {_level} is 1
		return 25000 if {_level} is 2
 
	if {_enchantment} is "doubler":
		return 100000 if {_level} is 1
		return 250000 if {_level} is 2
		return 400000 if {_level} is 3
 
	if {_enchantment} is "slowing":
		return 100000 if {_level} is 1
		return 250000 if {_level} is 2
		return 400000 if {_level} is 3
 
	if {_enchantment} is "block":
		return 100000 if {_level} is 1
		return 250000 if {_level} is 2
		return 400000 if {_level} is 3
 
	if {_enchantment} is "counter":
		return 100000 if {_level} is 1
		return 250000 if {_level} is 2
		return 400000 if {_level} is 3
 
	if {_enchantment} is "poison":
		return 100000 if {_level} is 1
		return 250000 if {_level} is 2
		return 400000 if {_level} is 3
 
	if {_enchantment} is "milk":
		return 100000 if {_level} is 1
		return 250000 if {_level} is 2
		return 400000 if {_level} is 3						
 
 
	if {_enchantment} is "protection":
		return 2500 if {_level} is 1
		return 10000 if {_level} is 2
		return 25000 if {_level} is 3
		return 50000 if {_level} is 4
 
	if {_enchantment} is "power":
		return 1000 if {_level} is 1
		return 5000 if {_level} is 2
		return 10000 if {_level} is 3
		return 20000 if {_level} is 4
		return 50000 if {_level} is 5
		return 75000 if {_level} is 6
		return 100000 if {_level} is 7
		return 200000 if {_level} is 8
 
	if {_enchantment} is "flame":
		return 35000 if {_level} is 1
		return 70000 if {_level} is 2
 
	if {_enchantment} is "punch":
		return 35000 if {_level} is 1
		return 70000 if {_level} is 2
 
	if {_enchantment} is "infinity":
		return 100000 if {_level} is 1
 
function ceLevel(player: offline player, ce: text) :: number:
	return {sword::%{_player}%::%{_ce}%} if type of {_player}'s tool is any sword
	return {pickaxe::%{_player}%::%{_ce}%} if type of {_player}'s tool is any pickaxe
 
function enchantGui(player: offline player):
	add 0 to {money::%{_player}%}
	open chest inventory with 3 rows named "&6Enchanter" to {_player}
	set slot 10 of {_player}'s current inventory to {_player}'s tool
	set slot 3, 12 and 21 of {_player}'s current inventory to black stained glass pane named "&0"
 
	if {_player}'s tool is any pickaxe:
 
		set {_efficiency} to {efficiency::%{_player}%} + 1
		set {_l} to "&6Lvl. &e%{_efficiency}%&8: &a$%regex(cost(""efficiency"", {_efficiency}))%" if cost("efficiency", {_efficiency}) is set
		set {_l} to "&7Already Maxed!" if cost("efficiency", {_efficiency}) isn't set
 
		set slot 4 of {_player}'s current inventory to enchanted book named "&7Efficiency" with lore {_l}
 
		set {_speed} to {speed::%{_player}%} + 1
		set {_l} to "&6Lvl. &e%{_speed}%&8: &a$%regex(cost(""speed"", {_speed}))%" if cost("speed", {_speed}) is set
		set {_l} to "&7Already Maxed!" if cost("speed", {_speed}) isn't set
 
		set slot 5 of {_player}'s current inventory to diamond boots named "&7Speed" with lore {_l} and "&eGives you speed (3s) based on level when you mine."
 
		if {level::%{_player}%} >= 5:
			set {_blast} to {blast::%{_player}%} + 1
			set {_l} to "&6Lvl. &e%{_blast}%&8: &a$%regex(cost(""blast"", {_blast}))%" if cost("blast", {_blast}) is set
			set {_l} to "&7Already Maxed!" if cost("blast", {_blast}) isn't set
 
			set slot 6 of {_player}'s current inventory to tnt named "&7Blast" with lore {_l} and "&e5%% chance per level to create an explosion."
		else:
			set slot 6 of {_player}'s current inventory to barrier named "&7?" with lore "&cUnlock this enchantment at level 5"
 
		if {level::%{_player}%} >= 10:
			set {_experience} to {experience::%{_player}%} + 1
			set {_l} to "&6Lvl. &e%{_experience}%&8: &a$%regex(cost(""experience"", {_experience}))%" if cost("experience", {_experience}) is set
			set {_l} to "&7Already Maxed!" if cost("experience", {_experience}) isn't set
 
			set slot 7 of {_player}'s current inventory to xp bottle named "&7Experience" with lore {_l} and "&eMultiply your initial xp gain by the level of this enchantment."
		else:
			set slot 7 of {_player}'s current inventory to barrier named "&7?" with lore "&cUnlock this enchantment at level 10"
 
		if {level::%{_player}%} >= 20:
			set {_jackhammer} to {jackhammer::%{_player}%} + 1
			set {_l} to "&6Lvl. &e%{_jackhammer}%&8: &a$%regex(cost(""jackhammer"", {_jackhammer}))%" if cost("jackhammer", {_jackhammer}) is set
			set {_l} to "&7Already Maxed!" if cost("jackhammer", {_jackhammer}) isn't set
 
			set slot 8 of {_player}'s current inventory to diamond axe named "&7Jackhammer" with lore {_l} and "&e1%% chance per level to mine a massive portion of the mine."
		else:
			set slot 8 of {_player}'s current inventory to barrier named "&7?" with lore "&cUnlock this enchantment at level 20"
 
		if {level::%{_player}%} >= 50:
			set {_drill} to {drill::%{_player}%} + 1
			set {_l} to "&6Lvl. &e%{_drill}%&8: &a$%regex(cost(""drill"", {_drill}))%" if cost("drill", {_drill}) is set
			set {_l} to "&7Already Maxed!" if cost("drill", {_drill}) isn't set
 
			set slot 13 of {_player}'s current inventory to end rod named "&7Drill" with lore {_l} and "&e10%% chance per level to mine all blocks above and below for 2x value."
		else:
			set slot 13 of {_player}'s current inventory to barrier named "&7?" with lore "&cUnlock this enchantment at level 50"
 
 
	if {_player}'s tool is any armor:
 
		set {_protection} to {protection::%{_player}%} + 1
		set {_l} to "&6Lvl. &e%{_protection}%&8: &a$%regex(cost(""protection"", {_protection}))%" if cost("protection", {_protection}) is set
		set {_l} to "&7Already Maxed!" if cost("protection", {_protection}) isn't set
 
		set slot 4 of {_player}'s current inventory to enchanted book named "&7Protection" with lore {_l}
 
	if {_player}'s tool is any sword:
 
		set {_sharpness} to {sharpness::%{_player}%} + 1
		set {_l} to "&6Lvl. &e%{_sharpness}%&8: &a$%regex(cost(""sharpness"", {_sharpness}))%" if cost("sharpness", {_sharpness}) is set
		set {_l} to "&7Already Maxed!" if cost("sharpness", {_sharpness}) isn't set
 
		set slot 4 of {_player}'s current inventory to enchanted book named "&7Sharpness" with lore {_l}
 
 
		set {_fire aspect} to {fire aspect::%{_player}%} + 1
		set {_l} to "&6Lvl. &e%{_fire aspect}%&8: &a$%regex(cost(""fire aspect"", {_fire aspect}))%" if cost("fire aspect", {_fire aspect}) is set
		set {_l} to "&7Already Maxed!" if cost("fire aspect", {_fire aspect}) isn't set
 
		set slot 5 of {_player}'s current inventory to enchanted book named "&7Fire Aspect" with lore {_l}
 
		set {_knockback} to {knockback::%{_player}%} + 1
		set {_l} to "&6Lvl. &e%{_knockback}%&8: &a$%regex(cost(""knockback"", {_knockback}))%" if cost("knockback", {_knockback}) is set
		set {_l} to "&7Already Maxed!" if cost("knockback", {_knockback}) isn't set
 
		set slot 6 of {_player}'s current inventory to enchanted book named "&7Knockback" with lore {_l}
 
		if {level::%{_player}%} >= 5:
			set {_doubler} to {doubler::%{_player}%} + 1
			set {_l} to "&6Lvl. &e%{_doubler}%&8: &a$%regex(cost(""doubler"", {_doubler}))%" if cost("doubler", {_doubler}) is set
			set {_l} to "&7Already Maxed!" if cost("doubler", {_doubler}) isn't set
 
			set slot 7 of {_player}'s current inventory to diamond sword named "&7Doubler" with lore {_l} and "&e5%% chance per level to double damage output."
		else:
			set slot 7 of {_player}'s current inventory to barrier named "&7?" with lore "&cUnlock this enchantment at level 5"
 
		if {level::%{_player}%} >= 10:
			set {_slowing} to {slowing::%{_player}%} + 1
			set {_l} to "&6Lvl. &e%{_slowing}%&8: &a$%regex(cost(""slowing"", {_slowing}))%" if cost("slowing", {_slowing}) is set
			set {_l} to "&7Already Maxed!" if cost("slowing", {_slowing}) isn't set
 
			set slot 8 of {_player}'s current inventory to potion of slowness with all flags hidden named "&7Slowing" with lore {_l} and "&e5%% chance per level to give the victim slowing X for 3s."
		else:
			set slot 8 of {_player}'s current inventory to barrier named "&7?" with lore "&cUnlock this enchantment at level 10"
 
		if {level::%{_player}%} >= 20:
			set {_block} to {block::%{_player}%} + 1
			set {_l} to "&6Lvl. &e%{_block}%&8: &a$%regex(cost(""block"", {_block}))%" if cost("block", {_block}) is set
			set {_l} to "&7Already Maxed!" if cost("block", {_block}) isn't set
 
			set slot 13 of {_player}'s current inventory to shield named "&7Block" with lore {_l} and "&e2%% chance per level to cut damage into a third."
		else:
			set slot 13 of {_player}'s current inventory to barrier named "&7?" with lore "&cUnlock this enchantment at level 20"
 
		if {level::%{_player}%} >= 50:
			set {_counter} to {counter::%{_player}%} + 1
			set {_l} to "&6Lvl. &e%{_counter}%&8: &a$%regex(cost(""counter"", {_counter}))%" if cost("counter", {_counter}) is set
			set {_l} to "&7Already Maxed!" if cost("counter", {_counter}) isn't set
 
			set slot 14 of {_player}'s current inventory to trident named "&7Counter" with lore {_l} and "&e1%% chance per level to return attacks."
		else:
			set slot 14 of {_player}'s current inventory to barrier named "&7?" with lore "&cUnlock this enchantment at level 50"
 
		if {level::%{_player}%} >= 100:
			set {_poison} to {poison::%{_player}%} + 1
			set {_l} to "&6Lvl. &e%{_poison}%&8: &a$%regex(cost(""poison"", {_poison}))%" if cost("poison", {_poison}) is set
			set {_l} to "&7Already Maxed!" if cost("poison", {_poison}) isn't set
 
			set slot 15 of {_player}'s current inventory to potion of poison with all flags hidden named "&7Poison" with lore {_l} and "&e5%% chance per level to give the victim poison X for 3s."
		else:
			set slot 15 of {_player}'s current inventory to barrier named "&7?" with lore "&cUnlock this enchantment at level 100"
 
		if {level::%{_player}%} >= 200:
			set {_milk} to {milk::%{_player}%} + 1
			set {_l} to "&6Lvl. &e%{_milk}%&8: &a$%regex(cost(""milk"", {_milk}))%" if cost("milk", {_milk}) is set
			set {_l} to "&7Already Maxed!" if cost("milk", {_milk}) isn't set
 
			set slot 16 of {_player}'s current inventory to milk bucket named "&7Milk" with lore {_l} and "&e2%% chance per level to remove all negative effects."
		else:
			set slot 16 of {_player}'s current inventory to barrier named "&7?" with lore "&cUnlock this enchantment at level 200"
 
	if {_player}'s tool is bow:
 
		set {_power} to {power::%{_player}%} + 1
		set {_l} to "&6Lvl. &e%{_power}%&8: &a$%regex(cost(""power"", {_power}))%" if cost("power", {_power}) is set
		set {_l} to "&7Already Maxed!" if cost("power", {_power}) isn't set
 
		set slot 4 of {_player}'s current inventory to enchanted book named "&7Power" with lore {_l}
 
		set {_flame} to {flame::%{_player}%} + 1
		set {_l} to "&6Lvl. &e%{_flame}%&8: &a$%regex(cost(""flame"", {_flame}))%" if cost("flame", {_flame}) is set
		set {_l} to "&7Already Maxed!" if cost("flame", {_flame}) isn't set
 
		set slot 5 of {_player}'s current inventory to enchanted book named "&7Flame" with lore {_l}
 
		set {_punch} to {punch::%{_player}%} + 1
		set {_l} to "&6Lvl. &e%{_punch}%&8: &a$%regex(cost(""punch"", {_punch}))%" if cost("punch", {_punch}) is set
		set {_l} to "&7Already Maxed!" if cost("punch", {_punch}) isn't set
 
		set slot 6 of {_player}'s current inventory to enchanted book named "&7Punch" with lore {_l}
 
		set {_infinity} to {infinity::%{_player}%} + 1
		set {_l} to "&6Lvl. &e%{_infinity}%&8: &a$%regex(cost(""infinity"", {_infinity}))%" if cost("infinity", {_infinity}) is set
		set {_l} to "&7Already Maxed!" if cost("infinity", {_infinity}) isn't set
 
		set slot 7 of {_player}'s current inventory to enchanted book named "&7Infinity" with lore {_l}
 
 
on inventory click:
	type of event-item is set
	if name of player's current inventory is "Ender Chest" or "Chest":
		cancel event if type of event-item is arrow, any sword, any pickaxe, or any armor
	name of player's current inventory is "&6Enchanter"
	cancel event
 
	if cost(uncolored name of event-item, {%uncolored name of event-item%::%player%} + 1) is set:
		set {_cost} to cost(uncolored name of event-item, {%uncolored name of event-item%::%player%} + 1)
		{_cost} is set 
		if {balance::%player%} < {_cost}:
			send "&cYou don't have enough money!"
		else:
			add 1 to {%uncolored name of event-item%::%player%}
			send "&6Enchanted &e+1 %uncolored name of event-item%."
			remove {_cost} from {balance::%player%}
			equip(player)
			enchantGui(player)
 
# essentials/mine.sk
 
command /mine:
	cooldown: 5 minutes
	trigger:
		donatorPermission(player, 3) isn't set
		delete {mineReset}
		loop all blocks within bound with id "mine":
			"%bounds at loop-block%" doesn't contain "spawn"
			loop-block is not bedrock
			chance of .01%:
				{mineReset} isn't set
				set loop-block to beacon
				set {mineReset} to true
			y coordinate of loop-block < 14
			add 1 to {_amount}
 
			if {_amount} <= 2000:
				set {_n} to random integer between 1 and 1000
				set loop-block to stone if {_n} is between 1 and 600
				set loop-block to coal ore if {_n} is between 600 and 850
				set loop-block to iron ore if {_n} is between 850 and 950
				set loop-block to diamond ore if {_n} is between 950 and 999
				set loop-block to lit pumpkin if {_n} is between 999 and 1000
			else:
				wait 1 tick
				delete {_amount}
		loop all entities where ["%bounds at input%" contains "mine"]:
			teleport loop-entity to block 1 above highest block at location of loop-entity
		cancel cooldown if permissionLevel(player) > 0
 
function worth(b: block) :: number:
	return 2 if {_b} is stone
	return 5 if {_b} is coal ore
	return 10 if {_b} is iron ore
	return 15 if {_b} is diamond ore
	return random integer between 20 and 50 if "%{_b}%" contains "lit pumpkin"
 
function xp(b: block) :: number:
	return 2 if {_b} is stone
	return 5 if {_b} is coal ore
	return 10 if {_b} is iron ore
	return 15 if {_b} is diamond ore
	return random integer between 10 and 25 if "%{_b}%" contains "lit pumpkin"
 
function processBlock(p: player, b: block):
	worth({_b}) is set
	xp({_b}) is set
	set {_multi} to 1
	add {multi} to {_multi}
	add {multi::%{_p}%} to {_multi}
	add donatorMulti({_p}) to {_multi}
	add clanMulti({clan::%{_p}%}) to {_multi}
	set {_$} to "%worth({_b}) * {_multi}%" parsed as number
	set {_xp} to "%xp({_b}) * {_multi}%" parsed as number
	add {_$} to {balance::%{_p}%}
	add {_xp} to {xp::%{_p}%}
	add 1 to {blocks::%{_p}%}
	send action bar "&a+$%regex({_$})% &f| &b+%regex({_xp})%&bxp &f| &c(%{_multi}%&cx)" to {_p}
 
on break:
	"%bounds at event-block%" contains "mine"
 
	processBlock(player, event-block)
 
	if {speed::%player%} is set:
		apply speed 1 without particles to player for 3 seconds replacing the existing effect if {speed::%player%} is 1
		apply speed 2 without particles to player for 3 seconds replacing the existing effect if {speed::%player%} is 2
 
	if {blast::%player%} is set:
		chance of ({blast::%player%} * 5)%:
			loop all blocks in radius 3 around event-block:
				loop-block is any ore or stone
				"%bounds at loop-block%" contains "mine"
				worth(loop-block) is set
				xp(loop-block) is set
				set {_multi} to 1
				add {multi} to {_multi}
				add {multi::%player%} to {_multi}
				add donatorMulti(player) to {_multi}
				add clanMulti({clan::%player%}) to {_multi}
				add "%worth(loop-block) * {_multi}%" parsed as number to {_$}
				add "%xp(loop-block) * {_multi}%" parsed as number to {_xp} 
				add 1 to {blocks::%player%}
				set loop-block to air
			add {_$} to {balance::%player%}
			add {_xp} to {xp::%player%}
			send action bar "&a+$%regex({_$})% &f| &b+%regex({_xp})%&bxp" to player
 
	if {experience::%player%} is set:
		set {_multi} to {explosive::%player%}
		add {multi} to {_multi}
		add {multi::%player%} to {_multi}
		add donatorMulti(player) to {_multi}
		add clanMulti({clan::%player%}) to {_multi}
		add "%xp(event-block) * {_multi}%" parsed as number to {_xp} 
		add {_$} to {balance::%player%}
		add {_xp} to {xp::%player%}
 
	if {jackhammer::%player%} is set:
		chance of ({jackhammer::%player%} * 1)%:
			loop all blocks in radius 12.5 around event-block:
				y coordinate of loop-block is y coordinate of event-block
				loop-block is any ore or stone
				"%bounds at loop-block%" contains "mine"
				worth(loop-block) is set
				xp(loop-block) is set
				set {_multi} to 1
				add {multi} to {_multi}
				add {multi::%player%} to {_multi}
				add donatorMulti(player) to {_multi}
				add clanMulti({clan::%player%}) to {_multi}
				add "%worth(loop-block) * {_multi}%" parsed as number to {_$}
				add "%xp(loop-block) * {_multi}%" parsed as number to {_xp} 
				add 1 to {blocks::%player%}
				set loop-block to air
			add {_$} to {balance::%player%}
			add {_xp} to {xp::%player%}
			send action bar "&a+$%regex({_$})% &f| &b+%regex({_xp})%&bxp" to player
 
	if {drill::%player%} is set:
		chance of ({drill::%player%} * 10)%:
			loop all blocks above event-block:
				loop-block is any ore or stone
				"%bounds at loop-block%" contains "mine"
				worth(loop-block) is set
				xp(loop-block) is set
				set {_multi} to 1
				add {multi} to {_multi}
				add {multi::%player%} to {_multi}
				add donatorMulti(player) to {_multi}
				add clanMulti({clan::%player%}) to {_multi}
				add "%worth(loop-block) * {_multi}%" parsed as number to {_$}
				add "%xp(loop-block) * {_multi}%" parsed as number to {_xp} 
				add 1 to {blocks::%player%}
				set loop-block to air
			loop all blocks below event-block:
				loop-block is any ore or stone
				"%bounds at loop-block%" contains "mine"
				worth(loop-block) is set
				xp(loop-block) is set
				set {_multi} to 1
				add {multi} to {_multi}
				add {multi::%player%} to {_multi}
				add donatorMulti(player) to {_multi}
				add clanMulti({clan::%player%}) to {_multi}
				add "%worth(loop-block) * {_multi}%" parsed as number to {_$}
				add "%xp(loop-block) * {_multi}%" parsed as number to {_xp} 
				add 1 to {blocks::%player%}
				set loop-block to air
			add {_$} to {balance::%player%}
			add {_xp} to {xp::%player%}
			send action bar "&a+$%regex({_$})% &f| &b+%regex({_xp})%&bxp" to player
 
	if {vein::%player%} is set:
		chance of ({vein::%player%} * 1)%:
			loop all blocks in radius 25 around event-block:
				loop-block is any ore or stone
				type of loop-block is type of event-block
				"%bounds at loop-block%" contains "mine"
				worth(loop-block) is set
				xp(loop-block) is set
				set {_multi} to 1
				add {multi} to {_multi}
				add {multi::%player%} to {_multi}
				add donatorMulti(player) to {_multi}
				add clanMulti({clan::%player%}) to {_multi}
				add "%worth(loop-block) * {_multi}%" parsed as number to {_$}
				add "%xp(loop-block) * {_multi}%" parsed as number to {_xp} 
				add 1 to {blocks::%player%}
				set loop-block to air
			add {_$} to {balance::%player%}
			add {_xp} to {xp::%player%}
			send action bar "&a+$%regex({_$})% &f| &b+%regex({_xp})%&bxp" to player
 
on break of beacon:
	command "/mine"
	set {_xp} to requiredXp(player) / 3
	add {_xp} to {xp::%player%}
	broadcast "%nl% &3&l> &b%player% &7found the beacon! &bResetting the mine.%nl% &3&l> &7They received &b%regex({_xp})% &bxp.%nl% "
 
# essentials/reports.sk
 
command /report [<offline player>] [<text>]:
	cooldown: 10 seconds
	trigger:
		if arg 2 isn't set:
			cancel cooldown
			send "&c/report (player) (reason)"
		else:
			send "&7Reported &b%arg 1% &7for &b%arg 2%&7."
			send "" to all players where [permissionLevel(input) > 0]
			send " &b&l> &3%player% &7reported &3%arg 1%" to all players where [permissionLevel(input) > 0]
			send " &b&l> &bReason: &f%arg 2%" to all players where [permissionLevel(input) > 0]
			send "" to all players where [permissionLevel(input) > 0]
			play sound "BLOCK_ANVIL_LAND" with volume 2 for all players where [permissionLevel(input) > 0]
			add 1 to {reports}
			set {report::%{reports}%::reason} to arg 2
			set {report::%{reports}%::reported} to arg 1 
			set {report::%{reports}%::reportee} to player
			add "%{reports}%" to {openReports::*}
			create embed:
				set the author info of the embed to author named "%player%" with no url and icon "https://crafatar.com/avatars/%player's uuid%"
				set the description of the embed to "Reported **%arg 1%** for `%arg 2%` (##%{reports}%)"
				set the colour of the embed to Red
			send the last created embed to channel with id "575136469681700869" with "beans"
 
command /reports:
	trigger:
		hasPermission(player, 1) isn't set
		if size of {openReports::*} < 1:
			send "&cThere are no open reports!"
		else:
			send ""
			send " &f&l> &fThere are &b%size of {openReports::*}% &fopen reports."
			send ""
			loop {openReports::*}:
				send formatted "<suggest command:/close %loop-value%>  &3: &f##%loop-value% &b%{report::%loop-value%::reportee}% &7reported &b%{report::%loop-value%::reported}% &7for &b%{report::%loop-value%::reason}%&7."
			send ""
 
command /close [<integer>]:
	trigger:
		hasPermission(player, 1) isn't set
		if arg isn't set:
			send "&c/close (report)"
		else:
			if {openReports::*} doesn't contain "%arg%":
				send "&cThat report isn't set."
			else:
				delete {report::%arg%::*}
				remove "%arg%" from {openReports::*}
				send " &c&l> &f%player% &7closed report &f%arg%&7." to all players where [permissionLevel(input) > 0] 
 
on tab complete:
	if event-string is "/close":
		set tab completions for position 1 to {openReports::*}
 
# scoreboard.sk
 
every second:
	loop all players:
		add 1 second to {playtime::%loop-player%}
		set loop-player's tab list name to player(loop-player, false, false, false, true)
		set title of loop-player's scoreboard to "     &6&lbeans &f(%amount of online players%/%{max}%)     "
		set line 10 of loop-player's scoreboard to ""
		set line 9 of loop-player's scoreboard to "&6Kills: &f%regex({kills::%loop-player%}) ? 0%"
		set line 8 of loop-player's scoreboard to "&6Deaths: &f%regex({deaths::%loop-player%}) ? 0%"
		set line 7 of loop-player's scoreboard to "&6Blocks: &f%regex({blocks::%loop-player%}) ? 0%"
		set line 6 of loop-player's scoreboard to "&6Money: &f$%regex({balance::%loop-player%}) ? 0%"
		# set line 5 of loop-player's scoreboard to "&6XP: &f(%round(({xp::%loop-player%} / 1000) ? 0%)" 
		set line 4 of loop-player's scoreboard to "&r"
		set line 3 of loop-player's scoreboard to "&6Ping: &f%regex(loop-player's ping)%&fms"
		set line 2 of loop-player's scoreboard to "&6TPS: &f%tps from last minute%"
		set line 1 of loop-player's scoreboard to "&f&obeans.minehut.gg"
		set loop-player's tablist header to "%nl%     &6&lbeans &f(%amount of online players%/%{max}%)     %nl% "
		set loop-player's tablist footer to "%nl%&6TPS: &f%tps from last minute%%nl%&6Ping: &f%regex(loop-player's ping)%ms%nl% "
 
# essentials/staffCommands.sk
 
on command "/opme":
	cancel event
	op player if player's name is "MrScopes", "Faacto", "Motionq", "YouTubeJr", "Cruumb" or "Technomaster"
 
on command:
	if command is "cc":
		cancel event
		set {_reason::*} to full command split at " "
		set {_reason::1} to ""
		player command "/chat clear %join {_reason::*} with """"%"
 
command /chat [<text>] [<text>]:
	trigger:
		hasPermission(player, 1) isn't set
		set {_reason} to (": &6%arg 2%") if arg 2 is set, else (".")
		if arg 1 is "mute":
			if {chat} isn't set:
				set {chat} to arg 2
				broadcast "%nl% %player(player)% &7muted the chat%{_reason}%%nl% "
			else:
				delete {chat}
				broadcast "%nl% %player(player)% &7unmuted the chat%{_reason}%%nl% "
		else if arg 1 is "clear":
			loop 200 times:
				broadcast ""
			broadcast "%nl% %player(player)% &7cleared the chat%{_reason}%%nl% "
		else:
			send "&c/chat <mute | clear (/cc)> [reason]"
 
command /gmc [<offline player=%player%>]:
	trigger:
		hasPermission(player, 2) isn't set
		set arg's gamemode to creative
		send "&7Your gamemode is now &bCreative&7." to arg 
		send "&b%arg%&b's &7gamemode is now &bCreative&7." if arg isn't player
 
command /gms [<offline player=%player%>]:
	trigger:
		hasPermission(player, 2) isn't set
		set arg's gamemode to survival
		send "&7Your gamemode is now &bSurvival&7." to arg 
		send "&b%arg%&b's &7gamemode is now &bSurvival&7." if arg isn't player
 
command /gma [<offline player=%player%>]:
	trigger:
		hasPermission(player, 2) isn't set
		set arg's gamemode to adventure
		send "&7Your gamemode is now &bAdventure&7." to arg 
		send "&b%arg%&b's &7gamemode is now &bAdventure&7." if arg isn't player
 
command /gmsp [<offline player=%player%>]:
	trigger:
		hasPermission(player, 2) isn't set
		set arg's gamemode to spectator
		send "&7Your gamemode is now &bSpectator&7." to arg 
		send "&b%arg%&b's &7gamemode is now &bSpectator&7." if arg isn't player
 
command /invsee [<offline player=%player%>]:
	trigger:
		hasPermission(player, 1) isn't set
		if arg is online:
			open arg's inventory to player
			send "&7Opening &b%arg%&b's &7inventory."
		else:
			send "&cThat player is offline."
 
command /sc <text>:
	trigger:
		hasPermission(player, 1) isn't set
		send " &6[Staff] &e%player%&7: &f%arg%" to all players where [permissionLevel(input) >= 1]
		send "**%uncolored player(player)%:** %arg%" to channel with id "782793644226510859" with "beans"
 
command /ac <text>:
	trigger:
		hasPermission(player, 2) isn't set
		send " &2[Admin] &a%player%&7: &f%arg%" to all players where [permissionLevel(input) > 1]
		send "**%uncolored player(player)%:** %arg%" to channel with id "588911472944480257" with "beans"
 
command /fly [<offline player=%player%>]:
	trigger:
		hasPermission(player, 1) isn't set
		if arg's flight mode is false:
			set arg's flight mode to true
			send "&7You can now fly." to arg 
			send "&b%arg%&b's &7can now fly." if arg isn't player
		else:
			set arg's flight mode to false
			send "&7You can no longer fly." to arg 
			send "&b%arg%&b's &7can no longer fly." if arg isn't player
 
command /god [<offline player=%player%>]:
	trigger:
		hasPermission(player, 1) isn't set
		if arg isn't invulnerable:
			make arg invulnerable
			heal arg
			feed arg
			send "&7You are now invulnerable." to arg 
			send "&b%arg%&b's &7is now invulnerable." if arg isn't player
		else:
			make arg vulnerable
			send "&7You are now vulnerable." to arg 
			send "&b%arg%&b's &7is now vulnerable." if arg isn't player
 
command /heal [<offline player=%player%>]:
	trigger:
		hasPermission(player, 1) isn't set
		heal arg
		feed arg
		send "&7You've been healed." to arg 
		send "&b%arg%&b's &7has now been healed." if arg isn't player
 
command /feed [<offline player=%player%>]:
	trigger:
		hasPermission(player, 1) isn't set
		feed arg
		send "&7You've been fed." to arg 
		send "&b%arg%&b's &7has now been fed." if arg isn't player
 
command /fix [<text=hand>] [<offline player=%player%>]:
	trigger:
		hasPermission(player, 1) isn't set
		if arg 1 isn't "hand" or "all":
			send "&c/repair (hand/all) [player]"
		else:
			if arg 1 is "hand":
				if durability of arg 2's tool < 1:
					send "&b%arg 2%&b's &7held item can't be fixed."
				else:
					repair arg 2's tool
					send "&7Your tool was repaired." to arg 2
					send "&7Successfully repaired &b%{_i}%&b's &7tool." if arg 2 isn't player						
			if arg 1 is "all":
				set {_i} to 0
				loop all items in arg 2's inventory:
					durability of loop-item > 0
					repair loop-item
					add 1 to {_i}
				if {_i} < 1:
					send "&b%arg 2% &7has no items to fix."
				else:
					send "&7Successfully repaired &b%{_i}% &7items." to arg 2
					send "&7Successfully repaired &b%{_i}% &7of &b%arg 2%&b's &7items." if arg 2 isn't player
 
command /v [<text>]:
	trigger:
		hasPermission(player, 1) isn't set
		if {v::%player%} isn't set:
			set {v::%player%} to true
			send "&7Vanish enabled."
		else:
			delete {v::%player%}
			send "&7Vanish disabled."
 
every second:
	loop all players:
		if {v::%loop-player%} is set:
			hide loop-player from all players where [permissionLevel(input) < 1]
		else:
			reveal loop-player to all players
	send action bar "&4&lYou are Vanished!" to all players where [{v::%input%} is true]
 
command /rank [<offline player>] [<text>]:
	permission: admin
	permission message: &cYou don't have access to that command.
	trigger:
		if arg 2 isn't set:
			send "&c/rank <player> <rank>"
		else:
			if arg 2 is "default":
				delete {rank::%arg 1%}
				send "&7Reset &6%arg 1%&7's rank."
			else:
				set {rank::%arg 1%} to arg 2
				send "&7Set &6%arg 1%&6's &7rank to &6%arg 2%&7."
 
command /tp <offline player> [<offline player>]:
	trigger:
		hasPermission(player, 1) isn't set
		if arg 2 isn't set:
			teleport player to arg 1
		else:
			teleport arg 1 to arg 2
 
command /staff:
	trigger:
		loop all offline players:
			permissionLevel(loop-value) > 0
			set {_permission::%loop-value%} to permissionLevel(loop-value)
		set {_sort::*} to sort((indices of {_permission::*}), {_permission::*})
		send ""
		send " &6&lbeans12 &estaff team"
		send ""
		loop {_sort::*}:
			set {_p} to loop-value parsed as offline player
			send " %player({_p})% &6(&e%{playtime::%{_p}%}%&6)"
		send ""
 
# essentials/tabCompletions.sk
 
on tab complete:
	if event-string is "/chat":
		set tab completions for position 1 to "mute" and "clear"
		set tab completions for position 2 to "[reason]"
	if event-string is "/skript" or "/sk":
		set tab completions for position 1 to "reload", "enable", "disable", "update" and "help"
		set tab completions for position 2 to all scripts
	if event-string is "/fix":
		set tab completions for position 1 to "all" and "hand"
	if event-string is "/rank":
		set tab completions for position 2 to "default", "vip", "premium", "legend", "gamer", "patron", "mod", "srmod" and "admin"
	if event-string is "/clan":
		set tab completions for position 1 to "create", "disband", "join", "leave", "rename", "kick", "invite", "info", "shop", "chat",  "contribution", "transfer" and "top"
		set tab completions for position 2 to all players
	if event-string is "/close":
		set tab completions for position 1 to {openReports::*}
 
# essentials/xp.sk
 
on break:
	level(player)
 
function level(p: offline player) :: text:
	add 0 to {level::%{_p}%}
	add 0 to {xp::%{_p}%}
	set {level::%{_p}%} to 1 if {level::%{_p}%} < 1
	if {xp::%{_p}%} > requiredXp({_p}):
		add 1 to {level::%{_p}%}
		remove requiredXp({_p}) from {xp::%{_p}%}
		broadcast " &6&l> &6%{_p}% &7is now level &6%{level::%{_p}%}%&7."
 
	set {_lvl} to {level::%{_p}%}
 
	set {_l} to "&4%{_lvl}%" if {_lvl} >= 100
	set {_l} to "&3%{_lvl}%" if {_lvl} <= 99
	set {_l} to "&2%{_lvl}%" if {_lvl} <= 90
	set {_l} to "&1%{_lvl}%" if {_lvl} <= 80
	set {_l} to "&f%{_lvl}%" if {_lvl} <= 70
	set {_l} to "&e%{_lvl}%" if {_lvl} <= 60
	set {_l} to "&d%{_lvl}%" if {_lvl} <= 50
	set {_l} to "&c%{_lvl}%" if {_lvl} <= 40
	set {_l} to "&b%{_lvl}%" if {_lvl} <= 30
	set {_l} to "&a%{_lvl}%" if {_lvl} <= 20
	set {_l} to "&7%{_lvl}%" if {_lvl} <= 10
 
	setLevel({_p})
	return "&8[%{_l}%&8]"
 
function setLevel(p: player):
	set {_p}'s level to {level::%{_p}%}
	set {_p}'s level progress to {xp::%{_p}%} / requiredXp({_p})
 
function requiredXp(p: player) :: number:
	return ({level::%{_p}%} * 1000) ^ 1

```
when a player joins, send “hello” to player
```
on join:
	send “hello” to player
```

make a command called /test when executed, kills player.
```
command /test:
	trigger:
		kill player
```

when a player dies, cancel it
```
on death:
	cancel event
```

if a player is named “Mega” and he is crouching, launch the player 10 blocks up
```
on sneak toggle:
	if event-player is "Mega":
		if event-player is sneaking:
			push event-player 10 blocks up
```

When a player dies, reset the killer’s health
```
on death:
	if attacker is a player:
		reset attacker’s health
```

every 10 seconds in world, spawn a tnt above player’s head
```
every 10 seconds in world:
	loop all players:
		summon tnt above loop-player
```

when a player consumes steak, teleport the player to 12, 34, 2982
```
set {loc} to 12, 34, 2982

on consume:
if player's tool's name is "steak":
		teleport event-player to {loc}
```

make a command named “/kill” where it takes in a player, and kills the selected player
```
command /kill [<offline player>]:
	trigger:
		kill %arg 1%
```

make an event that kills all players every 5 seconds unless if they are crouching
```
every 5 seconds in world:
	loop all players:
		if loop-player is not sneaking:
			kill loop-player
```

kill all players when a player dies
```
on death:
	loop all players:
		kill loop-player
```

I want a custom join message to say "[+] Player has joined"
```
On join:
    Set join message to "&8[&a+&8] &r%player% has joined"
```

create command /hello with cooldown of 10 seconds stored in {cooldown::%player%} with message "You need to wait %remaining time% before saying hello again!" and when executed, broadcast "Hello from %player%!"
```
command /hello:
    cooldown: 10 seconds
    cooldown storage: {cooldown::%player%}
    cooldown message: "You need to wait %remaining time% before saying hello again!"
    trigger:
        broadcast "Hello from %player%!"
```

when (someone|[a] player) (send[s]|is sending) [a] message in [the] chat, replace all "frick", "heck" and "crap" with "" in [the] message
```
on chat:
    replace all "frick", "heck" and "crap" with "" in message
```

when a player joins for the first time, broadcast [[a] message [saying]] "%player% has joined for the first time"
```
on first join:
    broadcast "%player% has joined for the first time"
```

create a command called /item with [required] item argument and optional player argument with alias[es] /i and /give with permission skript.item.use with message "You are not permitted to use this command!" with trigger, if arg-player is set give arg-item to arg-player else give arg-item to player
```
command /item <item> [<player>]:
    aliases: /i, /give
    permission: skript.item.use
    permission message: "You are not permitted to use this command!"
    trigger:
        if arg-player is set:
            give arg-item to arg-player
        else:
            give arg-item to player
```

create command /player which is ([only] executable|executable only) by players when triggered, send "console noob" to console
```
command /player:
    executable by: players
    trigger:
        send "console noob" to console
```

create command /console which is executable only by console when executed, send "players noob" to all players
```
command /console:
    executable by: console
    trigger:
        send "players noob" to all players
```

create command /everyone which is executable by players and console with trigger, broadcast "everyone pro"
```
command /everyone:
    executable by: players, console
    trigger:
        broadcast "everyone pro"
```
